[{"title":"Day1-两数之和","url":"/2025/04/23/Day1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"🔗 LeetCode 1 - Two Sum\n📌 题目描述给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例：\n输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1]\n\n💡 解题思路\n使用哈希表（字典）存储已访问的数字及其下标；\n遍历数组，对于每个元素 x，检查 target - x 是否存在于哈希表中；\n如果存在，说明找到了答案；\n否则将当前数字和下标加入哈希表继续查找。\n\n时间复杂度：O(n)空间复杂度：O(n)\n\n✅ JavaScript 实现var twoSum = function(nums, target) &#123;    const map = &#123;&#125;;    for (let i = 0; i &lt; nums.length; i++) &#123;        let complement = target - nums[i];        if (map[complement] !== undefined) &#123;            return [map[complement], i];        &#125;        map[nums[i]] = i;    &#125;    return [];&#125;;\n\n\n🟣 Swift 实现class Solution &#123;    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;        var map = [Int: Int]()        for (i, num) in nums.enumerated() &#123;            let complement = target - num            if let index = map[complement] &#123;                return [index, i]            &#125;            map[num] = i        &#125;        return []    &#125;&#125;\n\n\n🧠 思考与拓展\n如果要求返回所有满足条件的数对呢？\n 可以在遍历时记录所有匹配的组合，存储在数组中。\n\n如果输入数据有多个解，你该如何处理？\n\n当前题目假设「只有一个解」，但在实际项目中通常需要找到所有解。\n可采用双层循环或在 map 中记录所有下标（数组），进行组合尝试。\n\n\n如果不能使用额外空间，只能 O(1) 空间？\n\n先对数组进行排序（需要额外记录原始下标），然后使用 双指针 思路解决；\n时间复杂度为 O(nlogn)，但空间复杂度可降为 O(1)（如果允许修改原数组）。\n\n\n高频拓展题\n\nLeetCode 15. 三数之和\nLeetCode 18. 四数之和\nLeetCode 167. 两数之和 II - 输入有序数组\nLeetCode 653. 两数之和 IV - 输入 BST\n\n\n\n","categories":["算法"],"tags":["算法"]},{"title":"Day1-UIKit事件传递机制 & Responder Chain","url":"/2025/04/23/Day1-UIKit%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6-Responder-Chain/","content":"UIKit 事件传递机制 &amp; Responder Chain一、事件类型UIKit 中主要的事件类型包括：\n\n触摸事件（Touch Events）：如 tap、swipe、pinch 等。\n运动事件（Motion Events）：如摇动设备。\n远程控制事件（Remote-Control Events）：如耳机控制、CarPlay。\n按键事件（Press Events）（仅限 tvOS 或支持硬件键盘时的 iOS）。\n\n\n二、事件传递流程\n事件产生：\n\n事件由硬件（屏幕、传感器等）检测后交给系统。\niOS 将事件加入到主线程的 UIApplication 对象中进行分发。\n\n\n事件分发路径：\n\nUIApplication → UIWindow → UIView\n\n\n命中测试（Hit-Testing）：\n\n从根视图（window 的 rootView）开始递归查找目标视图。\n使用两个方法：\npoint(inside:with:)\nhitTest(_:with:)\n\n\n最终找到最合适的视图接收触摸事件。\n\n\n\n\n三、Responder Chain（响应者链）1. 什么是 Responder Chain？Responder Chain 是一条事件响应链，用来处理视图无法响应的事件。\n2. Responder Chain 构成一个 UIResponder 对象（如 UIView、UIViewController）可以传递事件给其上层响应者：UIView → UIViewController → UIWindow → UIApplication → AppDelegate\n如果某个对象无法处理事件，它会把事件传递给下一个响应者。\n3. UIResponder 方法\n\n\n方法名\n说明\n\n\n\ntouchesBegan(_:with:)\n开始触摸\n\n\ntouchesMoved(_:with:)\n触摸移动\n\n\ntouchesEnded(_:with:)\n触摸结束\n\n\ntouchesCancelled(_:with:)\n触摸被取消\n\n\n还可以通过 canBecomeFirstResponder 和 becomeFirstResponder() 控制焦点。\n\n四、自定义事件传递（常见场景）1. UIView 不响应事件可能是因为以下原因：\n\nisUserInteractionEnabled = false\nalpha &lt; 0.01\nhidden = true\n\n2. 自定义控件事件传递可重写以下方法：\n\nhitTest(_:with:)：决定谁是事件的最终响应者。\npoint(inside:with:)：判断点是否在当前视图内。\n\n\n五、Responder Chain 应用场景\n控件事件传递：如 UIButton 点击事件向上传递。\n菜单处理：如复制粘贴菜单响应。\n键盘响应管理。\n自定义事件路由（target-action 无法处理时）。\n\n\n六、调试技巧\n使用 View Debugger 检查视图层级。\n打断点调试 hitTest 和 touchesBegan。\n查看 next 属性追踪 Responder Chain。\n\n\n七、总结\nUIKit 事件从 UIApplication 开始，经过 UIWindow 最终传递给具体的 UIView。\nResponder Chain 是事件冒泡机制的实现，支持事件的多级处理。\n通过合理利用 hitTest: 和 Responder Chain，可以实现复杂交互需求。\n\n","categories":["基础"]},{"title":"Day10-GCD 进阶","url":"/2025/05/08/Day10-GCD-%E8%BF%9B%E9%98%B6/","content":"一、GCD 队列底层原理1.1 队列类型\n串行队列：一次只执行一个任务。\n并发队列：可以并发执行多个任务。\n主队列：主线程的串行队列，用于更新 UI。\n\n1.2 队列背后的线程\nGCD 使用 线程池 管理线程，具体由 libdispatch + pthread 实现。\n并发队列任务实际是串行调度、并发执行（由系统根据线程池和资源自动调度）。\n\n二、常见 GCD 高级用法2.1 dispatch_barrier（栅栏函数）dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.queue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123;    // 任务1&#125;);dispatch_barrier_async(queue, ^&#123;    // 栅栏任务：写操作&#125;);dispatch_async(queue, ^&#123;    // 任务2&#125;);\n\n2.2 dispatch_group（任务组）dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_group_async(group, queue, ^&#123;    // 任务1&#125;);dispatch_group_async(group, queue, ^&#123;    // 任务2&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;    // 所有任务完成后执行&#125;);\n\n2.3 dispatch_semaphore（信号量）dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);dispatch_async(queue, ^&#123;    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);    // 临界区    dispatch_semaphore_signal(semaphore);&#125;);\n\n三、避免死锁与优雅使用3.1 死锁示例（主队列同步调用）dispatch_sync(dispatch_get_main_queue(), ^&#123;    // 死锁：当前已经在主线程，又等主队列执行&#125;);\n\n3.2 dispatch_once（线程安全的单例初始化）static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;    // 初始化逻辑&#125;);\n\n四、GCD 优化技巧与实践4.1 控制最大并发数（结合 semaphore）dispatch_semaphore_t sema = dispatch_semaphore_create(3);for (int i = 0; i &lt; 10; i++) &#123;    dispatch_async(queue, ^&#123;        dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);        // 下载任务        dispatch_semaphore_signal(sema);    &#125;);&#125;\n\n4.2 使用 QoS（服务质量）dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0);dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.qosqueue&quot;, attr);\n\n五、和 NSOperation 比较\n\n\n特性\nGCD\nNSOperation\n\n\n\n简洁性\n✅\n❌（更复杂）\n\n\n依赖管理\n❌\n✅（operation.addDependency）\n\n\n取消任务\n❌\n✅（operation.cancel）\n\n\n重用性&#x2F;扩展性\n❌\n✅（子类化）\n\n\n并发控制（数量）\n借助 semaphore\n✅（maxConcurrentOperationCount）\n\n\nGCD 的底层实现原理Grand Central Dispatch（GCD）是苹果提供的一个多线程并发编程框架，其底层实现原理可以从几个关键的技术点来理解，包括：\n\n一、核心结构与实现基础1. GCD 基于 libdispatch 实现GCD 的底层是开源的 libdispatch 库，核心用 C 和 C++ 编写，运行在系统内核之上，封装了线程调度、任务分发、队列管理等功能。\n\n二、任务与队列模型1. 任务：Block 形式的封装代码（实质是闭包）每个任务是一个 dispatch_block_t，本质是封装在结构体中的函数指针和上下文数据。\n2. 队列：串行 or 并发\n串行队列：任务一个个顺序执行。\n并发队列：任务可同时执行，具体是否并行取决于系统资源。\n\n底层由结构体 dispatch_queue_s 表示，内部包含：\n\n队列名称\n优先级（QoS）\nTarget Queue（用于继承行为）\n队列状态（是否正在执行任务）\n队列类型（串行&#x2F;并发）\n\n\n三、线程调度原理1. 线程池机制GCD 不直接创建线程，而是复用一个系统管理的线程池（Managed Thread Pool）：\n\nApple 使用内核的 pthread 和 kqueue 机制动态创建和调度线程。\n调用 dispatch_async 等方法时任务进入队列，等待调度器（libdispatch）判断是否需要从线程池中取线程执行。\n\n2. 结合内核的调度器\n使用 XNU 内核提供的 workloop（基于 kqueue）来监视队列变化。\n利用信号量、原子操作、互斥锁控制任务同步。\n\n\n四、队列的调度机制1. dispatch_async &#x2F; dispatch_sync 的区别\n\n\n方法\n调度行为\n是否阻塞线程\n\n\n\ndispatch_async\n异步入队\n否\n\n\ndispatch_sync\n同步执行，当前线程等待任务完成\n是\n\n\n底层通过：\n\ndispatch_async：创建任务对象 -&gt; 放入目标队列 -&gt; 唤醒线程池中的线程处理\ndispatch_sync：直接调用任务，并使用 semaphore 阻塞当前线程，直到任务执行完\n\n\n五、QoS（服务质量）控制GCD 支持 QoS（Quality of Service）等级，例如：\n\nuserInteractive（最高）\nuserInitiated\ndefault\nutility\nbackground（最低）\n\n这些优先级通过底层设置线程调度属性，在内核中会影响线程抢占和执行顺序。\n\n六、关键数据结构（源码角度）1. dispatch_queue_s（队列结构体）包含：\nstruct dispatch_queue_s &#123;    ...    dispatch_object_t _head;    // 队列头部    dispatch_object_t _tail;    // 队列尾部    pthread_priority_t _priority; // 优先级    ...&#125;;\n\n2. dispatch_continuation_s（封装 block 的任务结构体）struct dispatch_continuation_s &#123;    void *dc_func;     // block 函数指针    void *dc_ctxt;     // block 上下文    ...&#125;;\n\n\n七、并发控制：信号量、栅栏、组\ndispatch_semaphore：底层基于 semaphore_t（Mach 信号量）\ndispatch_barrier：写操作时阻塞其他任务，底层使用任务依赖和标记机制实现\ndispatch_group：通过计数器追踪任务组状态，配合信号量实现通知\n\n\n总结GCD 是基于 libdispatch 构建的线程池 + 队列调度框架，其核心优势包括：\n\n高效的线程复用\n简洁的 API 封装（block）\n动态优先级管理（QoS）\n底层结合内核机制（如 kqueue 和 pthread）\n\n","categories":["基础"]},{"title":"Day10-三数之和","url":"/2025/05/08/Day10-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"🔗 LeetCode 15 - 三数之和\n📌 题目描述给你一个整数数组 nums，判断是否存在三元组 [nums[i], nums[j], nums[k]]，满足：\ni ≠ j、i ≠ k 且 j ≠ knums[i] + nums[j] + nums[k] == 0\n\n请你返回所有和为 0 且不重复的三元组。你不能包含重复的三元组。\n示例：\n输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]\n\n\n💡 解题思路\n先将数组排序；\n固定一个数 nums[i]，再用双指针在 i+1...n-1 范围内找两个数的和为 -nums[i]；\n注意跳过重复数字以避免重复结果。\n\n时间复杂度为 O(n^2)。\n\n✅ JavaScript 实现var threeSum = function(nums) &#123;    nums.sort(function(a, b) &#123; return a - b; &#125;);    let res = [];    for (let i = 0; i &lt; nums.length - 2; i++) &#123;        if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue;        let left = i + 1, right = nums.length - 1;        while (left &lt; right) &#123;            let sum = nums[i] + nums[left] + nums[right];            if (sum === 0) &#123;                res.push([nums[i], nums[left], nums[right]]);                while (left &lt; right &amp;&amp; nums[left] === nums[left + 1]) left++;                while (left &lt; right &amp;&amp; nums[right] === nums[right - 1]) right--;                left++;                right--;            &#125; else if (sum &lt; 0) &#123;                left++;            &#125; else &#123;                right--;            &#125;        &#125;    &#125;    return res;&#125;;\n\n\n🟣 Swift 实现class Solution &#123;    func threeSum(_ nums: [Int]) -&gt; [[Int]] &#123;        let nums = nums.sorted()        var res = [[Int]]()        for i in 0..&lt;nums.count &#123;            if i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &#123; continue &#125;            var left = i + 1            var right = nums.count - 1            while left &lt; right &#123;                let sum = nums[i] + nums[left] + nums[right]                if sum == 0 &#123;                    res.append([nums[i], nums[left], nums[right]])                    while left &lt; right &amp;&amp; nums[left] == nums[left + 1] &#123; left += 1 &#125;                    while left &lt; right &amp;&amp; nums[right] == nums[right - 1] &#123; right -= 1 &#125;                    left += 1                    right -= 1                &#125; else if sum &lt; 0 &#123;                    left += 1                &#125; else &#123;                    right -= 1                &#125;            &#125;        &#125;        return res    &#125;&#125;","categories":["算法"]},{"title":"Day11-GCD vs NSOperation 框架对比","url":"/2025/05/09/Day11-GCD-vs-NSOperation-%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/","content":"一、基本介绍\n\n\n方面\nGCD\nNSOperation\n\n\n\n所属框架\nC 语言底层 API，Foundation 框架\nFoundation 框架的面向对象封装\n\n\n编程范式\n函数式（Block）\n面向对象（Operation 对象）\n\n\n线程管理\n自动管理线程\n基于 NSOperationQueue，封装良好\n\n\n适用场景\n性能优先，轻量并发控制\n更复杂的任务依赖和管理需求\n\n\n二、核心组件对比\n\n\n功能\nGCD\nNSOperation\n\n\n\n执行体\ndispatch_async + Block\n自定义 NSOperation 子类 或 BlockOperation\n\n\n队列管理\ndispatch_queue\nNSOperationQueue\n\n\n最大并发数控制\n不支持（除非用信号量）\n支持（maxConcurrentOperationCount）\n\n\n任务取消\n不支持\n支持（cancel 方法 + 自定义取消逻辑）\n\n\n任务依赖\n不支持\n支持（addDependency:）\n\n\n任务状态监控\n不支持\n支持（如 isReady, isExecuting, isFinished）\n\n\nQoS 支持\n支持\n支持\n\n\n同步、异步支持\n支持\n主要是异步，依赖队列控制\n\n\n定时调度\n支持（dispatch_after, dispatch_timer）\n不直接支持\n\n\n三、使用对比示例GCD 示例：DispatchQueue.global(qos: .background).async &#123;    // 后台线程任务    DispatchQueue.main.async &#123;        // 回到主线程更新 UI    &#125;&#125;\n\nNSOperation 示例：let operationQueue = OperationQueue()let operation = BlockOperation &#123;    // 后台任务    OperationQueue.main.addOperation &#123;        // 更新 UI    &#125;&#125;operationQueue.addOperation(operation)\n\n四、使用建议\n\n\n场景\n推荐框架\n理由\n\n\n\n简单异步任务\nGCD\n轻量、简洁、性能好\n\n\n需要取消&#x2F;暂停任务\nNSOperation\n内建支持取消、暂停、状态管理\n\n\n需要任务依赖\nNSOperation\n提供 addDependency\n\n\n任务较为独立\nGCD\n开销小\n\n\n复杂的任务调度系统\nNSOperation\n面向对象，利于维护和扩展\n\n\n五、总结\n\n\n项目\nGCD\nNSOperation\n\n\n\n简洁性\n✅ 高\n❌ 相对复杂\n\n\n灵活性\n❌ 低\n✅ 高\n\n\n性能\n✅ 高（偏底层）\n❌ 稍逊一筹\n\n\n可读性&#x2F;可维护性\n❌ 差（block 链嵌套）\n✅ 高（封装明确）\n\n\n控制能力\n❌ 限\n✅ 完整\n\n\n","categories":["基础"]},{"title":"Day11-环形链表","url":"/2025/05/09/Day11-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","content":"🔗 LeetCode 141 - Linked List Cycle\n📌 题目描述给定一个链表，判断链表中是否有环。\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。\n示例：\n输入：head = [3,2,0,-4], pos = 1输出：true\n\n\n💡 解题思路使用快慢指针：\n\n慢指针一次走一步；\n\n快指针一次走两步；\n\n如果链表有环，快慢指针最终会在某个节点相遇；\n\n如果无环，快指针会先走到 null。\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n\n✅ JavaScript 实现（快慢指针）var hasCycle = function(head) &#123;    if (!head || !head.next) return false;    let slow = head;    let fast = head.next;    while (slow !== fast) &#123;        if (!fast || !fast.next) return false;        slow = slow.next;        fast = fast.next.next;    &#125;    return true;&#125;;\n\n\n🧠 思考拓展\n如果需要找出环的入口节点怎么做？（参见 LeetCode 142）\n如果想统计环的长度呢？\n使用哈希表是否也能解决？时间与空间复杂度如何变化？\n\n","categories":["算法"]},{"title":"Day12-ARC 本质、Weak 实现、循环引用处理","url":"/2025/05/12/Day12-ARC-%E6%9C%AC%E8%B4%A8%E3%80%81Weak-%E5%AE%9E%E7%8E%B0%E3%80%81%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%A4%84%E7%90%86/","content":"一、ARC 的本质（Automatic Reference Counting）ARC 是编译器级别的内存管理机制，由 Clang 编译器在编译时插入 retain&#x2F;release&#x2F;autorelease 相关的代码。\n核心机制\n每个对象都有一个 引用计数（retain count）。\n强引用（strong）+1（retain），释放 -1（release）。\n引用计数为 0 时，调用 dealloc 释放对象。\nARC 只管理对象内存，不管理 malloc&#x2F;free 的非对象内存。\n\n\n二、Weak 的实现原理__weak 不增加引用计数，用于避免循环引用，自动在对象销毁时置为 nil。\nweak_table_t 全局结构\n存储所有 weak 引用对象与对应指针地址。\n每个对象记录在一个 weak_entry_t 中：\n\nstruct weak_entry_t &#123;    DisguisedPtr&lt;objc_object&gt; referent;    weak_referrer_t *referrers;&#125;;\n\nobjc_storeWeak(id *location, id obj)\n清除旧值\n设置新值，并注册到 weak_table_t\n\n对象销毁时：\n调用 objc_clearWeakRefs，将所有 weak 指针置 nil\n\n\n三、循环引用及处理方式循环引用定义\n当两个对象互相强引用，引用计数永远不为 0，导致内存泄漏。\n\n解决方法\n使用 __weak 或 __unsafe_unretained\n在 block 中使用 [weak self] 或 [unowned self]\ndelegate 常使用 weak\n\n\n四、底层实现：引用计数存储与操作isa_t 结构（64 位系统）union isa_t &#123;    uintptr_t bits;    struct &#123;        uintptr_t nonpointer        : 1;        uintptr_t has_assoc         : 1;        uintptr_t has_cxx_dtor      : 1;        uintptr_t shiftcls          : 44;        uintptr_t magic             : 6;        uintptr_t weakly_referenced : 1;        uintptr_t deallocating      : 1;        uintptr_t has_sidetable_rc  : 1;        uintptr_t extra_rc          : 8;    &#125;;&#125;;\n\nextra_rc\n引用计数快速路径，最大 255。\n超过后，引用计数信息存入 SideTable。\n\nSideTable 结构struct SideTable &#123;    spinlock_t slock;    RefcountMap refcnts;    weak_table_t weak_table;&#125;;\n\n\n五、objc_retain 和 objc_release 底层逻辑objc_retain(id obj)id objc_retain(id obj) &#123;    if (obj == nil) return nil;    if (obj-&gt;isa.tryRetain()) return obj;    return retainSlow(obj);&#125;\n\nobjc_release(id obj)void objc_release(id obj) &#123;    if (obj == nil) return;    if (obj-&gt;isa.tryRelease()) return;    releaseSlow(obj);&#125;\n\n\n六、__weak 与 __unsafe_unretained 对比\n\n\n特性\n__weak\n__unsafe_unretained\n\n\n\n是否增加引用计数\n否\n否\n\n\n对象释放后指针\n自动 nil\n悬垂指针\n\n\n安全性\n高\n低\n\n\n性能\n稍低\n高\n\n\n\n七、调试与优化建议调试工具\n[object retainCount]\npo [obj retainCount] (LLDB)\n设置环境变量：\n\nexport OBJC_PRINT_RETAIN_RELEASE=YES\n\n优化建议\nweak 有性能开销，频繁使用需谨慎。\nblock 捕获 self 时建议使用 [weak self]。\n\n\n八、总结架构图示（文字版）┌──────────────┐│ ARC 编译器插入 │└──────┬───────┘       ↓┌─────────────┐│ isa_t 的 extra_rc │  &lt;───&lt;255 快路径└──────┬──────┘       ↓┌──────────────┐│ SideTable 存储引用计数 │└──────┬───────┘       ↓┌─────────────┐│ weak_table_t │ ← weak引用管理└─────────────┘\n","categories":["基础"]},{"title":"Day13-内存泄漏排查、僵尸对象与 MRC 回顾","url":"/2025/05/13/Day13-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E3%80%81%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%E4%B8%8E-MRC-%E5%9B%9E%E9%A1%BE/","content":"一、iOS内存泄漏排查1. 常见内存泄漏场景\n循环引用：对象之间相互强引用（如父子对象、Block捕获self未使用weak修饰），导致无法释放516。\n未释放Core Foundation对象：使用CF框架（如CFArrayRef、CGImageRef）时未调用CFRelease17。\nNSTimer&#x2F;CADisplayLink强引用：未在适当时机调用invalidate，导致持有者无法释放516。\n大对象未释放：如缓存图片、视频资源未及时清理416。\nARC下的隐式泄漏：指针提前置nil，导致堆对象未被释放（如Person *p = [Person new]; p = nil;）3。\n\n2. 排查工具与方法\n静态分析（Analyze）：通过Xcode的Product -&gt; Analyze检测代码逻辑错误（如访问未初始化指针、未释放路径）1113。\n动态分析（Instruments）：\nLeaks：检测未释放的内存泄漏，结合Call Tree定位代码位置61215。\nAllocations：监控内存分配趋势，识别异常增长区域17。\n\n\nDebug Memory Graph：可视化对象引用关系，快速发现循环引用613。\n第三方工具：如腾讯的MLeaksFinder，自动化检测页面泄漏6914。\n\n\n二、僵尸对象（Zombie Objects）1. 定义与成因\n僵尸对象：已被释放（dealloc）但仍在被访问的对象，访问时会导致EXC_BAD_ACCESS崩溃818。\n常见场景：\n过度释放：对同一对象多次调用release（MRC下）8。\n野指针：指针指向已释放对象后未置nil（如MRC下悬垂指针）818。\n\n\n\n2. 检测与解决\n启用Zombie Instrument：在Instruments中选择Zombies模式，捕获访问僵尸对象的行为817。\nARC下的防护：通过weak修饰符避免野指针，自动置nil58。\nMRC下的规范：遵循retain&#x2F;release配对原则，释放后指针置nil38。\n\n\n三、MRC（Manual Reference Counting）回顾1. 核心规则\n手动管理引用计数：通过retain增加计数，release减少计数，autorelease延迟释放17。\n所有权原则：谁创建（alloc&#x2F;new&#x2F;copy）、谁释放；其他情况需显式retain79。\nSetter方法规范：- (void)setObject:(id)newObject &#123;    [_object release];      // 释放旧值    _object = [newObject retain]; // 保留新值&#125;\n需注意旧值可能已被释放的风险9。\n\n2. 常见问题与陷阱\n不平衡的retain&#x2F;release：导致内存泄漏或过度释放17。\n循环引用：需手动打破强引用链（如使用assign替代retain）516。\nAutorelease Pool管理：大量临时对象需手动控制释放时机，避免内存峰值9。\n\n3. ARC的优势\n自动化：编译器自动插入retain&#x2F;release代码，减少人为错误17。\n安全性：通过weak和strong修饰符管理所有权，避免僵尸对象57。\n\n\n四、总结与建议\n优先使用ARC：减少手动管理风险，但需注意与Core Foundation交互时的桥接（__bridge、CFRelease）17。\n规范代码习惯：\n避免循环引用，使用weak&#x2F;unowned修饰Block捕获对象5。\n及时释放非OC对象（如C语言malloc分配的内存）17。\n\n\n结合工具排查：定期使用静态分析、动态检测和内存图谱，定位复杂泄漏问题61317。\n\n通过上述方法，开发者可有效降低内存泄漏风险，提升应用稳定性。\n","categories":["基础"]},{"title":"Day12-二叉树的最大深度","url":"/2025/05/12/Day12-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","content":"🔗 LeetCode 104 - Maximum Depth of Binary Tree\n📌 题目描述给定一个二叉树，找出其最大深度。\n\n最大深度是从根节点到最远叶子节点的最长路径上的节点数。\n\n示例：\n输入：[3,9,20,null,null,15,7]输出：3解释：最大路径是 3 -&gt; 20 -&gt; 7\n\n\n\n💡 解题思路我们可以使用 递归 或 BFS 层序遍历 来解决：\n\n递归法：最大深度 &#x3D; 1 + max(左子树深度, 右子树深度)\n层序遍历：每遍历一层，深度加一\n时间复杂度：O(n)\n空间复杂度：O(h)，h 为树的高度（递归栈）\n\n\n✅ JavaScript 实现（递归）var maxDepth = function(root) &#123;    if (root === null) return 0;    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));&#125;;\n\n\n✅ JavaScript 实现（BFS）var maxDepth = function(root) &#123;    if (!root) return 0;    let queue = [root];    let depth = 0;    while (queue.length &gt; 0) &#123;        let size = queue.length;        for (let i = 0; i &lt; size; i++) &#123;            let node = queue.shift();            if (node.left) queue.push(node.left);            if (node.right) queue.push(node.right);        &#125;        depth++;    &#125;    return depth;&#125;;\n\n\n🧠 思考拓展\n如果要求“最小深度”呢？（LeetCode 111）\n如何找出最长路径上的具体节点？\n可否使用 DFS 的非递归写法？\n\n","categories":["算法"]},{"title":"Day14-移动零","url":"/2025/05/14/Day14-%E7%A7%BB%E5%8A%A8%E9%9B%B6/","content":"🔗 LeetCode 283 - Move Zeroes\n📌 题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序不变。\n示例：\n输入: [0,1,0,3,12]输出: [1,3,12,0,0]\n\n\n💡 解题思路\n用一个指针 lastNonZeroIndex 来记录下一个应该放非零元素的位置；\n遍历一遍数组，遇到非零就放到该位置；\n遍历结束后，从该位置开始补零。\n\n\n✅ JavaScript 实现var moveZeroes = function(nums) &#123;    let lastNonZeroIndex = 0;    for (let i = 0; i &lt; nums.length; i++) &#123;        if (nums[i] !== 0) &#123;            nums[lastNonZeroIndex++] = nums[i];        &#125;    &#125;    for (let i = lastNonZeroIndex; i &lt; nums.length; i++) &#123;        nums[i] = 0;    &#125;&#125;;\n\n\n🧠 思考拓展\n如果不能修改原数组呢？怎么做？\n如何最少操作次数完成移动？\n是否可以双指针优化版本？\n\n","categories":["算法"]},{"title":"Day13-相交链表","url":"/2025/05/13/Day13-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","content":"🔗 LeetCode 160 - Intersection of Two Linked Lists\n📌 题目描述给你两个单链表的头节点 headA 和 headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null。\n示例：\nA:       a1 → a2↘c1 → c2 → c3↗B: b1 → b2 → b3输出：c1\n\n\n💡 解题思路我们可以使用“双指针法”：\n\n分别从两个链表的头开始遍历\n当指针 A 到尾部时，转到 B 链表头；指针 B 到尾部时，转到 A 链表头\n如果有交点，最终两个指针会在交点相遇\n否则，都会变为 null，表示没有相交\n\n核心思想：两个指针走过的路程一样，最终会在交点重合或同时为 null\n\n✅ JavaScript 实现var getIntersectionNode = function(headA, headB) &#123;    if (!headA || !headB) return null;    let pA = headA, pB = headB;    while (pA !== pB) &#123;        pA = pA === null ? headB : pA.next;        pB = pB === null ? headA : pB.next;    &#125;    return pA;&#125;;\n\n\n🧠 思考拓展\n如果不允许修改原链表结构，还能怎么做？\n空间复杂度可以为 O(1) 吗？\n如果链表有环，还能找到相交节点吗？（结合 LeetCode 142）\n\n","categories":["算法"]},{"title":"Day14-RunLoop&多线程&内存管理","url":"/2025/05/14/Day14-RunLoop-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"一、核心概念1. RunLoop\nRunLoop 是线程的事件处理循环，是 NSRunLoop 和 CFRunLoopRef 的封装。\n默认只在主线程自动启动。\n管理事件源（Timer、Input Source、Observer）。\n保持线程活跃、延迟执行任务、监听输入等都依赖 RunLoop。\n\n2. 多线程\niOS 支持多线程方式有：\nNSThread\nGCD（主流）\nNSOperationQueue\n\n\n每条线程都有自己独立的 RunLoop，但默认只有主线程的 RunLoop 自动运行。\n\n3. 内存管理（以 ARC 为基础）\n使用 retain/release 管理对象生命周期。\nstrong/weak/unowned 控制引用关系。\n多线程场景中注意引用循环、野指针、线程同步问题。\n\n\n二、三者之间的联系RunLoop 与 多线程\n子线程若需处理 Timer、事件监听，必须手动开启 RunLoop。\n子线程默认 RunLoop 不启动，任务执行完就退出。\n示例：- (void)startBackgroundThread &#123;    NSThread *thread = [[NSThread alloc] initWithBlock:^&#123;        NSLog(@&quot;Start thread&quot;);        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];        [[NSRunLoop currentRunLoop] run];    &#125;];    [thread start];&#125;\n\n多线程 与 内存管理\nARC 负责线程安全地管理引用计数。\nGCD 的 Block 默认强引用捕获外部变量，注意内存泄漏。\n多线程中访问共享资源要小心并发读写带来的内存访问异常。\n\nRunLoop 与 内存管理\nRunLoop 会持有它注册的事件源（Timer、Port 等）。\n若 Timer target 对象被强引用，容易造成循环引用：// 错误示例self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(fire) userInfo:nil repeats:YES];\n\n\n三、典型场景解析\n\n\n场景\n涉及点\n注意事项\n\n\n\n子线程保持活跃\nRunLoop + 多线程\n添加 Port &#x2F; Timer 后手动启动 RunLoop\n\n\n定时器导致内存泄漏\nRunLoop + 内存管理\n使用 weak self，或中介对象解耦\n\n\n异步任务中回调 UI\n多线程 + RunLoop\n回到主线程，主线程的 RunLoop 驱动 UI 刷新\n\n\nGCD 死锁\n多线程\ndispatch_sync 嵌套调用主队列容易死锁\n\n\nRunLoop 的生命周期管理\nRunLoop + 内存管理\n注意强引用阻止线程退出\n\n\n\n四、面试问题举例Q1: 子线程中 Timer 不执行，为什么？\nA: 子线程默认 RunLoop 没有启动，Timer 依赖 RunLoop 执行。\n\nQ2: NSTimer 为什么可能引起内存泄漏？如何避免？\nA: 因为 NSTimer 强引用 target，target 又强引用 timer。使用 weak 或中间对象（如 NSProxy）解决循环引用。\n\nQ3: GCD 的异步任务中为何 UI 更新失败？\nA: UI 更新必须在主线程中执行，异步任务默认不在主线程，需要使用 dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;)。\n\nQ4: RunLoop 如何保持线程常驻？\nA: 使用 [[NSRunLoop currentRunLoop] run]，或者添加事件源如 Port 或 Timer 保持 RunLoop 活跃。\n\n\n五、总结图示线程（Thread）   └── RunLoop（每个线程一个）        ├── Timer（引用 target，需避免循环引用）        ├── Input Source（事件、Port）        └── Observer（监听状态）多线程 ↔ RunLoop（任务调度、常驻线程）  多线程 ↔ 内存管理（同步访问、Block 捕获）  RunLoop ↔ 内存管理（Timer target 循环引用）\n","categories":["基础"]},{"title":"Day15-环形链表 II","url":"/2025/05/15/Day15-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/","content":"🔗 LeetCode 142 - 环形链表 II\n📌 题目描述给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\n示例：\n输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n💡 解题思路本题是经典的“快慢指针”问题。\n\n判断是否有环：\n\n使用两个指针，slow 每次移动一步，fast 每次移动两步。\n如果 fast 和 slow 相遇，说明链表中存在环。\n\n\n找到入环点：\n\n当 fast 和 slow 相遇时，将其中一个指针移到链表头部，另一个指针保持在相遇点。\n两个指针每次都移动一步，最终相遇的节点即为入环点。\n\n\n\n\n✅ JavaScript 实现var detectCycle = function(head) &#123;    let slow = head;    let fast = head;    while (fast &amp;&amp; fast.next) &#123;        slow = slow.next;        fast = fast.next.next;        if (slow === fast) &#123;            let ptr = head;            while (ptr !== slow) &#123;                ptr = ptr.next;                slow = slow.next;            &#125;            return ptr;        &#125;    &#125;    return null;&#125;;\n\n\n🟣 Swift 实现class Solution &#123;    func detectCycle(_ head: ListNode?) -&gt; ListNode? &#123;        var slow = head        var fast = head        while let nextFast = fast?.next?.next, let nextSlow = slow?.next &#123;            slow = nextSlow            fast = nextFast            if slow === fast &#123;                var ptr = head                while ptr !== slow &#123;                    ptr = ptr?.next                    slow = slow?.next                &#125;                return ptr            &#125;        &#125;        return nil    &#125;&#125;\n\n\n🧠 思考拓展\n如果链表中存在多个环，算法是否仍然适用？\n如何在不修改链表结构的情况下检测环？\n能否在 O(1) 空间复杂度下解决此问题？\n\n","categories":["算法"]},{"title":"Day15-NSURLSession 断点续传 + 网络封装","url":"/2025/05/15/Day15-NSURLSession-%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0-%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85/","content":"一、NSURLSession 下载机制原理类型回顾：\nNSURLSessionDataTask: 用于请求和响应小数据。\nNSURLSessionDownloadTask: 用于下载大文件，支持断点续传。\nNSURLSessionUploadTask: 用于上传数据。\n\n对于断点续传，NSURLSessionDownloadTask 是唯一支持此功能的类型。\n\n二、断点续传机制详解1. 如何中断任务生成 Resume Data[downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123;    // 将 resumeData 写入本地    [resumeData writeToFile:@&quot;xxx.resume&quot; atomically:YES];&#125;];\n\nResume Data 生成条件：\n\n任务必须是 downloadTask。\n必须使用 cancelByProducingResumeData。\nSession 配置必须是 defaultSessionConfiguration，不是 background。\n网络中断导致取消并不会自动生成 resumeData。\n\n2. Resume Data 本质是什么？\nresumeData 实际是一个带有 HTTP Range 请求头的二进制 plist 数据，内容包含：\n请求 URL\n上次下载的 Range\n已下载的文件路径\n请求 Header\n临时文件信息等\n\n\n\n你可以用如下代码解析 resumeData（调试用）：\nNSError *error = nil;NSDictionary *resumeDict = [NSPropertyListSerialization propertyListWithData:resumeData options:0 format:nil error:&amp;error];NSLog(@&quot;Resume Info: %@&quot;, resumeDict);\n\n\n三、Resume Data 的问题与兼容性iOS 10-13 常见问题：\niOS 10-11 resumeData 会“损坏”，Apple Bug。\niOS 13 后 Resume Data 更加严格：URL、Header 一点点改动就不能用。\nresumeData 不能跨机器或跨进程恢复。\n\n校验 Resume Data 可用性（推荐封装方法中加判断）：- (BOOL)isValidResumeData:(NSData *)data &#123;    if (data.length == 0) return NO;    NSDictionary *dict = [NSPropertyListSerialization propertyListWithData:data options:0 format:nil error:nil];    return dict[@&quot;NSURLSessionResumeInfoTempFileName&quot;] != nil;&#125;\n\n\n四、网络封装架构设计（DownloadManager）1. 设计目标\n支持多任务同时下载\n支持任务暂停、恢复、取消\n下载进度可观察\n稳定保存 resumeData\n支持后台下载可选（非断点续传）\n\n2. 数据结构设计@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, NSURLSessionDownloadTask *&gt; *downloadTasks;@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, NSData *&gt; *resumeDataDict;@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, NSNumber *&gt; *progressDict;@property (nonatomic, strong) NSURLSession *session;\n\n3. 方法定义- (void)startDownloadWithURL:(NSURL *)url identifier:(NSString *)identifier;- (void)pauseDownloadWithIdentifier:(NSString *)identifier;- (void)resumeDownloadWithIdentifier:(NSString *)identifier;- (void)cancelDownloadWithIdentifier:(NSString *)identifier;\n\n4. DownloadManager.m 实现要点创建下载任务- (void)startDownloadWithURL:(NSURL *)url identifier:(NSString *)identifier &#123;    if (self.downloadTasks[identifier]) return;    NSURLSessionDownloadTask *task = [self.session downloadTaskWithURL:url];    self.downloadTasks[identifier] = task;    [task resume];&#125;\n\n暂停任务- (void)pauseDownloadWithIdentifier:(NSString *)identifier &#123;    NSURLSessionDownloadTask *task = self.downloadTasks[identifier];    [task cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123;        if (resumeData) &#123;            self.resumeDataDict[identifier] = resumeData;            [resumeData writeToFile:[self resumeDataPathForIdentifier:identifier] atomically:YES];        &#125;        [self.downloadTasks removeObjectForKey:identifier];    &#125;];&#125;\n\n恢复任务- (void)resumeDownloadWithIdentifier:(NSString *)identifier &#123;    NSData *resumeData = self.resumeDataDict[identifier];    if (!resumeData) &#123;        resumeData = [NSData dataWithContentsOfFile:[self resumeDataPathForIdentifier:identifier]];    &#125;    NSURLSessionDownloadTask *task = nil;    if ([self isValidResumeData:resumeData]) &#123;        task = [self.session downloadTaskWithResumeData:resumeData];    &#125; else &#123;        // fallback：重新下载        NSURL *url = [self downloadURLForIdentifier:identifier];        task = [self.session downloadTaskWithURL:url];    &#125;    self.downloadTasks[identifier] = task;    [task resume];&#125;\n\n代理方法处理下载完成&#x2F;进度- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask              didWriteData:(int64_t)bytesWritten         totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite &#123;    NSString *identifier = [self identifierForTask:downloadTask];    CGFloat progress = (CGFloat)totalBytesWritten / totalBytesExpectedToWrite;    self.progressDict[identifier] = @(progress);        // 回调通知 UI&#125;\n\n- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location &#123;    NSString *identifier = [self identifierForTask:downloadTask];    NSURL *destinationURL = [self finalFilePathForIdentifier:identifier];    [[NSFileManager defaultManager] moveItemAtURL:location toURL:destinationURL error:nil];    [self.downloadTasks removeObjectForKey:identifier];    [self.resumeDataDict removeObjectForKey:identifier];&#125;\n\n\n五、后台下载与断点续传的冲突后台下载使用：\nNSURLSessionConfiguration *config = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;bg.download&quot;];\n\n限制：\n\n不支持 cancelByProducingResumeData，取消任务不会生成 resumeData。\n暂停任务只能取消，不能 resume。\n适合非断点续传的被动文件下载，比如 OS 更新、邮件附件等。\n\n\n六、进阶优化建议1. 文件分片多线程下载（适合大文件，如视频）\n先获取文件大小（HEAD 请求）\n分成多个 Range 任务并发下载\n自行合并片段\n\n2. 添加 SHA&#x2F;MD5 校验\n防止 resume 后的数据不一致\n下载完成校验数据一致性\n\n3. 使用数据库记录下载任务状态（可选：SQLite&#x2F;FMDB）\nidentifier、状态、进度、路径\n恢复 App 后能自动恢复任务\n\n\n七、工具&#x2F;类库推荐\nAFURLSessionManager：AFNetworking 内封 NSURLSessionDownloadTask 封装\nAlamofire：Swift 中的封装，使用 DownloadRequest 支持断点\nZLDownloadManager：高级断点续传管理器（OC）\n\n","categories":["基础"]},{"title":"Day16-AFNetworking底层原理","url":"/2025/05/16/Day16-AFNetworking%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","content":"AFNetworking 是基于 Apple 提供的 NSURLSession 和 NSURLConnection 封装的网络库（AFNetworking 3.0 以后完全基于 NSURLSession），它对网络请求、JSON&#x2F;XML 解析、文件上传下载、网络监测等功能做了封装，使 iOS 开发者能够更方便地处理网络通信。\n一、AFNetworking 架构总览AFNetworking 核心组件包括：\n\nAFURLSessionManager：对 NSURLSession 的封装，处理请求任务和回调\nAFHTTPSessionManager：对 AFURLSessionManager 进一步封装，专注于 HTTP 请求\nAFNetworkReachabilityManager：网络状态监测\nAFURLRequestSerialization：请求序列化（如设置请求头、参数编码）\nAFURLResponseSerialization：响应反序列化（如 JSON&#x2F;XML 的解析）\n\n二、AFURLSessionManager（核心类）1. NSURLSession 的封装AFNetworking 的请求是基于 NSURLSession 实现的，内部通过以下方式处理：\n\n创建 NSURLSession 对象，并设置 delegateQueue\n实现了 NSURLSessionDataDelegate、NSURLSessionTaskDelegate 等代理方法\n将代理方法中的回调统一到 block 中，便于使用者调用\n\n2. 任务回调处理机制AFNetworking 通过维护一个 NSMutableDictionary&lt;NSNumber *, AFURLSessionManagerTaskDelegate *&gt; 来管理每一个 NSURLSessionTask 的 delegate，保证每个任务的回调被正确分发。\n@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;\n\n当一个任务开始时，AF 会：\n\n创建对应的 delegate（AFURLSessionManagerTaskDelegate）\n保存到上面的字典中\n当代理方法回调时，通过 taskIdentifier 查找对应 delegate 处理\n\n三、AFHTTPSessionManager（HTTP 请求封装）继承自 AFURLSessionManager，并进一步封装了 HTTP 请求方法：\n\n提供了常见的 GET、POST、PUT、DELETE 等方法\n自动将请求参数序列化（使用 AFHTTPRequestSerializer）\n自动解析响应数据（使用 AFJSONResponseSerializer、AFXMLParserResponseSerializer 等）\n\n示例：\n[self.manager GET:@&quot;url&quot; parameters:nil headers:nil progress:nil success:^(NSURLSessionDataTask *task, id responseObject) &#123;    // 处理成功&#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123;    // 处理失败&#125;];\n\n四、请求序列化器（AFURLRequestSerialization）主要负责：\n\n设置请求头（如 Content-Type、Authorization 等）\n参数编码（query string 编码、JSON 编码等）\n构建 multipart&#x2F;form-data 请求体（文件上传）\n\n其核心类有：\n\nAFHTTPRequestSerializer\nAFJSONRequestSerializer\nAFPropertyListRequestSerializer\n\n五、响应序列化器（AFURLResponseSerialization）主要负责将返回的原始 NSData 转换为可用的对象，比如：\n\nJSON → NSDictionary &#x2F; NSArray\nXML → NSXMLParser\nImage → UIImage\n\n其核心类有：\n\nAFJSONResponseSerializer\nAFXMLParserResponseSerializer\nAFImageResponseSerializer\n\n通过设置 AFURLSessionManager.responseSerializer 来决定如何解析响应数据。\n六、网络状态监控（AFNetworkReachabilityManager）底层基于 SystemConfiguration.framework 中的 SCNetworkReachability 实现：\n\n可以监控 WiFi、蜂窝网络的变化\n通过 block 回调形式告知外部状态变化\n\n[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;    // 网络状态发生变化&#125;];\n\n七、线程安全设计AFNetworking 使用 dispatch_queue_t 和 NSLock 保证线程安全：\n\n对字典 mutableTaskDelegatesKeyedByTaskIdentifier 的访问通过锁保护\n使用 completionQueue &#x2F; completionGroup 控制回调在哪个线程执行\n\n八、AFNetworking 与断点续传AFNetworking 本身不直接封装断点续传逻辑，但它支持通过 NSURLSessionDownloadTask 实现断点续传：\n\n利用 resumeData 保存中断的数据\n通过 downloadTaskWithResumeData: 恢复下载任务\n\n你可以自己封装逻辑，比如监听下载失败时 resumeData，保存后续再恢复。\n总结\n\n\n模块\n说明\n\n\n\nAFURLSessionManager\n对 NSURLSession 的封装，统一任务管理和回调\n\n\nAFHTTPSessionManager\n提供 HTTP 请求方法的封装\n\n\n请求序列化\n设置请求头、参数编码等（AFHTTPRequestSerializer）\n\n\n响应序列化\n将 NSData 转为对象（如 JSON&#x2F;XML）\n\n\n网络监控\n基于 SCNetworkReachability 监测网络状态\n\n\n并发处理\n使用锁、队列保证线程安全\n\n\n","categories":["基础"]},{"title":"Day16-无重复字符的最长子串","url":"/2025/05/16/Day16-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","content":"🔗 LeetCode 3 - Longest Substring Without Repeating Characters\n📌 题目描述给定一个字符串 s，请你找出其中不含有重复字符的最长子串的长度。\n示例：\n输入: s = &quot;abcabcbb&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n\n\n💡 解题思路使用 滑动窗口 方法：\n\n使用一个 Set 记录当前窗口内的字符；\n定义两个指针 left 和 right，初始都为 0；\n如果 s[right] 不在 Set 中，加入 set 并更新最大长度；\n如果存在重复字符，移动 left 指针并从 Set 中移除字符，直到不再重复；\n重复此过程直到遍历完整个字符串。\n\n时间复杂度：O(n)空间复杂度：O(n)\n\n✅ JavaScript 实现var lengthOfLongestSubstring = function(s) &#123;    let set = new Set();    let left = 0, maxLen = 0;    for (let right = 0; right &lt; s.length; right++) &#123;        while (set.has(s[right])) &#123;            set.delete(s[left]);            left++;        &#125;        set.add(s[right]);        maxLen = Math.max(maxLen, right - left + 1);    &#125;    return maxLen;&#125;;\n\n\n✅ Swift 实现func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123;    var set = Set&lt;Character&gt;()    var left = s.startIndex    var maxLength = 0    var right = left    while right &lt; s.endIndex &#123;        if !set.contains(s[right]) &#123;            set.insert(s[right])            maxLength = max(maxLength, s.distance(from: left, to: right) + 1)            right = s.index(after: right)        &#125; else &#123;            set.remove(s[left])            left = s.index(after: left)        &#125;    &#125;    return maxLength&#125;\n\n\n🧠 思考拓展\n如何在出现中文字符（Unicode 多字节）时保持算法有效？\n如果要求输出最长子串本身，而不是长度，应该如何修改代码？\n如果对性能有极致要求，有哪些方式能减少空间占用？\n\n","categories":["算法"]},{"title":"Day17-最大子数组和","url":"/2025/05/17/Day17-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","content":"🔗 LeetCode 53 - Maximum Subarray\n📌 题目描述给你一个整数数组 nums，请你找出一个具有最大和的 连续子数组，并返回其最大和。\n\n🔍 示例输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n💡 解题思路：动态规划（Kadane’s Algorithm）\ndp[i] 表示以 nums[i] 结尾的最大子数组和\n转移公式：dp[i] = max(nums[i], dp[i-1] + nums[i])\n可优化为 O(1) 空间，仅用两个变量\n\n\n✅ JavaScript 实现var maxSubArray = function(nums) &#123;    let maxSum = nums[0];    let currSum = nums[0];    for (let i = 1; i &lt; nums.length; i++) &#123;        currSum = Math.max(nums[i], currSum + nums[i]);        maxSum = Math.max(maxSum, currSum);    &#125;    return maxSum;&#125;;\n\n\n\n✅ Swift 实现func maxSubArray(_ nums: [Int]) -&gt; Int &#123;    var currSum = nums[0]    var maxSum = nums[0]    for i in 1..&lt;nums.count &#123;        currSum = max(nums[i], currSum + nums[i])        maxSum = max(maxSum, currSum)    &#125;    return maxSum&#125;\n\n\n\n🧠 思考拓展\n如何返回最大子数组的下标范围？\n如果数组是环形（头尾可以相连），如何求最大和？\n分治法如何实现？（O(nlogn)）\n\n","categories":["算法"]},{"title":"Day17-缓存策略 + URLProtocol 拦截","url":"/2025/05/17/Day17-%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5-URLProtocol-%E6%8B%A6%E6%88%AA/","content":"一、iOS 缓存策略（NSURLRequest.CachePolicy）缓存策略决定了 请求是否使用缓存，以及如何使用缓存。它在 NSURLRequest 初始化时设置，对 NSURLSession 和 NSURLConnection 都生效。\n常见策略说明：\n\n\n策略\n描述\n\n\n\n.useProtocolCachePolicy\n默认策略，遵循 HTTP 协议头（如 Cache-Control、Expires）决定是否使用缓存。\n\n\n.reloadIgnoringLocalCacheData\n忽略本地缓存，总是从服务器加载数据。\n\n\n.returnCacheDataElseLoad\n如果有缓存使用缓存；否则从网络加载。\n\n\n.returnCacheDataDontLoad\n只使用缓存，没有缓存则请求失败（用于离线模式）。\n\n\n.reloadRevalidatingCacheData\n本地有缓存会尝试跟服务器确认其有效性（用 ETag、Last-Modified 等头）。\n\n\n\n二、URLProtocol 拦截机制（URLProtocol 子类）URLProtocol 是 NSURL 加载系统的低层钩子，允许你拦截并处理系统所有通过 NSURL 系列发出的请求（包括 NSURLSession，如果配置正确）。\n主要用途：\n请求&#x2F;响应数据 mock（如单元测试）\n日志埋点、监控网络请求\n自定义缓存策略（如写入&#x2F;读取磁盘缓存）\n拦截请求添加统一 Header、Token\n\n基本使用步骤：\n自定义类继承 URLProtocol\n实现必要方法：\n\n+ (BOOL)canInitWithRequest:(NSURLRequest *)request;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;- (void)startLoading;- (void)stopLoading;\n\n\n注册协议类：\n\n[NSURLProtocol registerClass:[MyCustomProtocol class]];\n\n\nNSURLSession 特别注意：使用自定义配置注册 URLProtocol\n\nNSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];config.protocolClasses = @[MyCustomProtocol.class];NSURLSession *session = [NSURLSession sessionWithConfiguration:config];\n\n\n三、URLProtocol 与缓存策略结合实践@implementation MyCustomProtocol+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;    if ([NSURLProtocol propertyForKey:@&quot;HandledKey&quot; inRequest:request]) return NO;    return YES;&#125;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;    return request;&#125;- (void)startLoading &#123;    NSURLRequest *request = self.request;    // 示例：优先查找本地磁盘缓存    NSData *cachedData = [self readCacheForRequest:request];    if (cachedData) &#123;        NSURLResponse *response = [[NSURLResponse alloc] initWithURL:request.URL                                                            MIMEType:@&quot;application/json&quot;                                               expectedContentLength:cachedData.length                                                    textEncodingName:nil];        [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];        [self.client URLProtocol:self didLoadData:cachedData];        [self.client URLProtocolDidFinishLoading:self];        return;    &#125;    // 没有缓存，继续请求网络    NSMutableURLRequest *newRequest = [request mutableCopy];    [NSURLProtocol setProperty:@YES forKey:@&quot;HandledKey&quot; inRequest:newRequest];    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];    NSURLSession *session = [NSURLSession sessionWithConfiguration:config];    NSURLSessionDataTask *task = [session dataTaskWithRequest:newRequest                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;        if (data) &#123;            [self saveCache:data forRequest:request];            [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];            [self.client URLProtocol:self didLoadData:data];        &#125;        if (error) &#123;            [self.client URLProtocol:self didFailWithError:error];        &#125; else &#123;            [self.client URLProtocolDidFinishLoading:self];        &#125;    &#125;];    [task resume];&#125;- (void)stopLoading &#123;    // 清理任务或操作&#125;@end\n\n\n四、补充建议\n使用 setProperty:forKey: 防止请求递归处理。\n可实现“先缓存再刷新”策略：先返回缓存再异步更新。\n可扩展支持磁盘缓存路径、缓存有效期等功能。\n\n\n","categories":["基础"]},{"title":"Day18-组合总和","url":"/2025/05/18/Day18-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","content":"🔗 LeetCode 39 - Combination Sum\n📌 题目描述给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为 target 的所有不同组合。\n你可以无限次使用 candidates 中的数字。\n\n🔍 示例输入: candidates = [2,3,6,7], target = 7输出: [[2,2,3],[7]]解释: 2 和 3 可以重复使用。\n\n\n💡 解题思路采用 回溯算法（Backtracking）：\n\n每次从当前位置开始尝试加入元素，继续递归\n若总和超过 target，剪枝返回\n若等于 target，记录路径\n\n\n✅ JavaScript 实现var combinationSum = function(candidates, target) &#123;    const res = [];    const dfs = (start, path, sum) =&gt; &#123;        if (sum === target) &#123;            res.push([...path]);            return;        &#125;        if (sum &gt; target) return;        for (let i = start; i &lt; candidates.length; i++) &#123;            path.push(candidates[i]);            dfs(i, path, sum + candidates[i]); // 可以重复选            path.pop();        &#125;    &#125;;    dfs(0, [], 0);    return res;&#125;;\n\n\n✅ Swift 实现func combinationSum(_ candidates: [Int], _ target: Int) -&gt; [[Int]] &#123;    var res = [[Int]]()    func dfs(_ start: Int, _ path: [Int], _ sum: Int) &#123;        if sum == target &#123;            res.append(path)            return        &#125;        if sum &gt; target &#123;            return        &#125;        for i in start..&lt;candidates.count &#123;            dfs(i, path + [candidates[i]], sum + candidates[i])        &#125;    &#125;    dfs(0, [], 0)    return res&#125;\n\n\n🧠 思考拓展\n如何加速搜索？尝试将 candidates 排序 + 剪枝优化\n如果每个数最多只能选一次，应该如何修改逻辑？（提示：LeetCode 40）\n如何改为动态规划解法？\n\n","categories":["算法"]},{"title":"Day19-岛屿数量","url":"/2025/05/19/Day19-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","content":"🔗 LeetCode 200 - Number of Islands\n📌 题目描述给你一个由 ‘1’（陆地）和 ‘0’（水）组成的二维网格 grid，请你计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向或垂直方向相邻的陆地连接而成。\n\n🔍 示例输入: grid = [  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出: 3\n\n\n\n💡 解题思路经典的 深度优先搜索（DFS） 问题：\n\n从每个未访问的 ‘1’ 出发进行 DFS，将连通的所有 ‘1’ 标记为 ‘0’；\n每次遍历完整个岛屿，岛屿数量加 1；\n或可使用 BFS、并查集进行拓展解法。\n\n时间复杂度：O(m × n)空间复杂度：O(m × n)\n\n✅ JavaScript 实现var numIslands = function(grid) &#123;    let count = 0;    const rows = grid.length, cols = grid[0].length;    const dfs = (i, j) =&gt; &#123;        if (i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || grid[i][j] === &#x27;0&#x27;) return;        grid[i][j] = &#x27;0&#x27;;        dfs(i + 1, j);        dfs(i - 1, j);        dfs(i, j + 1);        dfs(i, j - 1);    &#125;;    for (let i = 0; i &lt; rows; i++) &#123;        for (let j = 0; j &lt; cols; j++) &#123;            if (grid[i][j] === &#x27;1&#x27;) &#123;                dfs(i, j);                count++;            &#125;        &#125;    &#125;    return count;&#125;;\n\n\n✅ Swift 实现func numIslands(_ grid: [[Character]]) -&gt; Int &#123;    var grid = grid    let rows = grid.count    let cols = grid[0].count    var count = 0    func dfs(_ i: Int, _ j: Int) &#123;        if i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || grid[i][j] == &quot;0&quot; &#123;            return        &#125;        grid[i][j] = &quot;0&quot;        dfs(i + 1, j)        dfs(i - 1, j)        dfs(i, j + 1)        dfs(i, j - 1)    &#125;    for i in 0..&lt;rows &#123;        for j in 0..&lt;cols &#123;            if grid[i][j] == &quot;1&quot; &#123;                dfs(i, j)                count += 1            &#125;        &#125;    &#125;    return count&#125;\n\n🧠 思考拓展\n如何使用 BFS 实现？\n如何使用并查集（Union-Find）来解决？\n如果要求标出每个岛屿的坐标集，该如何修改算法？\n\n","categories":["算法"]},{"title":"Day2-View 布局流程","url":"/2025/04/24/Day2-View-%E5%B8%83%E5%B1%80%E6%B5%81%E7%A8%8B/","content":"View 布局流程详解一、布局流程总览iOS 的视图布局流程由 UIKit 管理，核心遵循「从父到子、从外向内」的递归更新方式。涉及的关键方法有：\n\nlayoutSubviews：真正进行子视图位置布局的地方\nsetNeedsLayout：标记视图为需要重新布局\nlayoutIfNeeded：立即强制布局\n\n布局流程如下：属性变化（如 frame）或手动触发↓调用 setNeedsLayout（标记需要布局）↓下一个 runloop 执行 layoutIfNeeded↓系统递归调用 layoutSubviews 进行布局\n\n二、关键方法详解1. setNeedsLayout\n作用：标记当前视图为“需要重新布局”\n调用时机：当视图状态或依赖数据变化时\n注意：不会立即执行 layoutSubviews，而是在下一个 runloop 进行布局\n\n[self.view setNeedsLayout];\n\n2. layoutIfNeeded\n作用：立即执行布局流程（如果已标记）\n常用场景：动画中强制更新 layout，确保视图状态正确  [self.view layoutIfNeeded];\n\n3. layoutSubviews\n作用：布局子视图，子类通过重写此方法来自定义布局逻辑\n调用方式：系统自动调用，或通过 layoutIfNeeded 间接触发  - (void)layoutSubviews &#123;    [super layoutSubviews];    self.label.frame = CGRectMake(10, 10, 100, 40);&#125;\n\n三、布局触发时机布局流程会在以下情况下自动触发：\n\n视图初始化完成后首次添加到视图层级中\nframe &#x2F; bounds &#x2F; center 属性改变\n调用 setNeedsLayout + layoutIfNeeded\n屏幕旋转、设备方向变化\nAuto Layout 约束变化\n\n四、Auto Layout 参与布局流程当使用 Auto Layout（自动布局）时：\n\n不推荐在 layoutSubviews 中设置 frame\n更新约束应在 updateConstraints 方法中完成\nupdateConstraints → layoutSubviews → drawRect 是完整的调用链  - (void)updateConstraints &#123;    // 更新约束    [super updateConstraints];&#125;\n\n五、UIView 与 CALayer 的关系\n每个 UIView 都有一个对应的 CALayer\nUIView.frame 实际上是操作 CALayer.frame\n布局本质上是在更新图层的属性  NSLog(@&quot;%@&quot;, NSStringFromCGRect(self.view.layer.frame));\n\n六、文字版布局流程图[视图属性变更]      ↓[setNeedsLayout] → 标记布局      ↓[下一个 runloop]      ↓[layoutIfNeeded] → 判断并触发布局      ↓[layoutSubviews] → 更新子视图 frame\n\n七、面试高频问题整理Q1：layoutSubviews 和 drawRect 有什么区别？\nlayoutSubviews：用于更新子视图的布局\ndrawRect：用于自定义视图绘图（如 Core Graphics）\n\nQ2：如何立即触发布局？[self.view setNeedsLayout];[self.view layoutIfNeeded];\n\nQ3：什么时候会调用 layoutSubviews？\n添加到父视图后\nframe 改变\nsetNeedsLayout + layoutIfNeeded\nAuto Layout 触发\n\nQ4：如何在动画中确保布局生效？[UIView animateWithDuration:0.3 animations:^&#123;    // 修改布局前置条件    [self.view layoutIfNeeded]; // 强制立即布局&#125;];\n\n八、参考资料\nApple Developer 文档：UIView Class Reference\n官方指南：View Programming Guide for iOS\n\n","categories":["基础"]},{"title":"Day19-离线缓存架构图 + 实际场景总结","url":"/2025/05/19/Day19-%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84%E5%9B%BE-%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/","content":"一、iOS 离线缓存架构图（逻辑层级）┌────────────────────────────┐│         用户操作层         │├────────────────────────────┤│ ViewController / ViewModel │├─────────────┬──────────────┤│     请求数据接口（Manager） │├─────────────┴──────────────┤│       离线缓存协调模块     │ ◄─ 控制数据来源逻辑│  (CacheMediator/CacheLogic)│├──────┬────────────┬────────┤│ 网络模块 │ 本地缓存模块 │ 数据同步模块 ││ (NSURLSession/AFN等) │ (SQLite/Realm/File) │ (版本/时间戳/校验) │├──────┴────────────┴────────┤│      数据存储层（DataLayer） ││   本地数据库 / 文件系统等    │└────────────────────────────┘\n\n\n二、核心模块说明1. 网络模块\n使用 NSURLSession &#x2F; AFNetworking &#x2F; Alamofire 发起请求。\n支持断点续传、etag、Last-Modified 等缓存策略。\n\n2. 缓存协调模块（CacheMediator）\n判定是否命中本地缓存，是否需要刷新。\n负责缓存策略（如：缓存有效期、本地优先、弱网兜底、预加载）。\n\n3. 本地缓存模块\n数据结构：\nJSON：保存到数据库（SQLite&#x2F;Realm&#x2F;CoreData）\n图片、音视频：文件系统（Disk）\n\n\n元信息同步：缓存时间、etag、url、数据版本。\n\n4. 数据同步模块\n判断缓存是否过期、是否需更新。\n后台更新机制（App 启动、进入后台、拉取刷新）。\n\n\n三、典型使用场景总结\n\n\n场景\n离线缓存设计方案\n\n\n\n新闻资讯App\n首页数据列表 JSON 缓存，图片预加载；弱网下优先读本地。\n\n\n视频播放器\n播放器支持 m3u8 &#x2F; mp4 文件预缓存，支持断点续传。\n\n\n电商应用\n商品列表缓存、详情页缓存，支持数据版本控制。\n\n\n聊天&#x2F;IM应用\n消息本地数据库持久化（例如 SQLite），断网时仍可查看。\n\n\n地图&#x2F;导航类\n地图瓦片离线下载，路径规划缓存；GPS不依赖网络。\n\n\n表单提交类（问卷&#x2F;CRM）\n数据草稿保存到本地，网络恢复后自动同步。\n\n\n\n四、最佳实践与注意事项\n\n\n实践建议\n说明\n\n\n\n数据版本控制\n使用版本号或时间戳判断缓存是否过期\n\n\n多级缓存策略（Memory + Disk）\n提高访问速度并节省网络资源\n\n\n异常处理兜底（如网络失败）\n本地缓存兜底，保证 App 不崩溃、可用\n\n\n缓存清理策略\nLRU、定期清理、不常访问淘汰\n\n\n加密与隐私\n对本地缓存内容加密，避免隐私泄露\n\n\n","categories":["基础"]},{"title":"Day18-数据持久化方案","url":"/2025/05/18/Day18-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88/","content":"iOS 的数据持久化是指将应用运行过程中产生的数据保存到设备的本地存储中，以便下次启动或在需要时读取。根据数据的结构复杂度、读写频率、安全性要求等不同场景，iOS 提供了多种持久化方案：\n\n常见的数据持久化方式1. NSUserDefaults &#x2F; UserDefaults\n适用场景：轻量级数据，如设置项、登录状态、首选项。\n存储类型：基本类型（String、Bool、Int、Float、Double）、数组、字典、Data。\n存储位置：Library/Preferences 目录下的 plist 文件。\n优点：简单易用，自动持久化。\n缺点：不适合存储大量或结构复杂的数据。\n\nUserDefaults.standard.set(true, forKey: &quot;hasLaunchedBefore&quot;)let launched = UserDefaults.standard.bool(forKey: &quot;hasLaunchedBefore&quot;)\n\n\n2. Keychain\n适用场景：存储敏感信息，如密码、token。\n安全性高：系统级别的加密存储，支持 Touch ID &#x2F; Face ID。\n缺点：API 较复杂，可通过第三方库简化如 KeychainAccess、SAMKeychain。\n\nlet keychain = Keychain(service: &quot;com.example.app&quot;)try? keychain.set(&quot;secret-token&quot;, key: &quot;authToken&quot;)let token = try? keychain.get(&quot;authToken&quot;)\n\n\n3. File System\n适用场景：音视频、图片、文本文件、自定义数据模型的二进制形式。\n常用 API：FileManager\n文件位置：\nDocuments：用户生成内容，iCloud 会备份\nCaches：缓存数据，系统可能清理\ntmp：临时数据，随时会被删除\n\n\n\nlet fileURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0].appendingPathComponent(&quot;myData.txt&quot;)try? &quot;Hello&quot;.write(to: fileURL, atomically: true, encoding: .utf8)\n\n\n4. Core Data\n适用场景：结构化复杂数据的本地数据库存储。\n优点：\nApple 官方支持的对象图管理框架\n支持数据模型、关系型建模、查询优化、懒加载等\n可结合 iCloud 使用\n\n\n缺点：学习曲线较陡，不适合简单数据\n\nlet entity = NSEntityDescription.insertNewObject(forEntityName: &quot;Person&quot;, into: context)entity.setValue(&quot;Tom&quot;, forKey: &quot;name&quot;)try? context.save()\n\n\n5. SQLite\n适用场景：对数据库结构完全控制；数据量大、结构清晰。\n优点：灵活、高性能、广泛应用\n缺点：原生 C 接口复杂，推荐使用封装库，如：\nFMDB（Objective-C 封装）\nGRDB.swift（Swift 封装）\n\n\n\nimport SQLite3// 略：打开数据库、准备语句、执行语句等\n\n\n6. Realm\n适用场景：替代 Core Data 或 SQLite，简单易用、性能优。\n优点：\n不需要 schema migration 写 SQL\n跨平台\n响应式数据监听支持\n\n\n缺点：是第三方库，需集成维护\n\nclass Dog: Object &#123;    @Persisted var name = &quot;&quot;    @Persisted var age = 0&#125;let dog = Dog()dog.name = &quot;Rex&quot;try! realm.write &#123;    realm.add(dog)&#125;\n\n\n7. Codable + File System\n适用场景：中等复杂的数据模型，自定义结构序列化为 JSON&#x2F;Plist&#x2F;Binary。\n优点：轻量、灵活。\n配合方式：\nJSONEncoder/Decoder\nPropertyListEncoder/Decoder\n\n\n\nstruct User: Codable &#123;    let name: String    let age: Int&#125;let user = User(name: &quot;Alice&quot;, age: 25)let data = try JSONEncoder().encode(user)try data.write(to: fileURL)\n\n\n总结对比\n\n\n方案\n优点\n缺点\n适用场景\n\n\n\nUserDefaults\n简单易用\n不适合复杂&#x2F;大量数据\n配置、轻量状态\n\n\nKeychain\n高安全性\nAPI复杂\n密码、token\n\n\nFile System\n灵活、支持任意数据\n手动管理读写&#x2F;序列化\n文件、缓存、二进制资源\n\n\nCore Data\n强大对象关系管理\n学习成本高\n中大型结构化数据\n\n\nSQLite\n精细控制、高性能\nC语言繁琐\n数据库开发、性能敏感场景\n\n\nRealm\n简洁高效\n第三方库依赖\n快速开发结构化数据存储\n\n\nCodable + File\n灵活易于维护\n无查询机制\n自定义模型、轻量数据库替代品\n\n\n","categories":["基础"]},{"title":"Day2-用栈实现队列","url":"/2025/04/24/Day2-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","content":"🔗 LeetCode 232 - Implement Queue using Stacks\n📌 题目描述：使用两个栈 stackIn 和 stackOut 实现一个队列，支持以下操作：\n\npush(x)：将元素 x 推到队列的末尾\npop()：移除队列开头的元素并返回\npeek()：返回队列开头的元素\nempty()：返回队列是否为空\n\n要求：只能使用栈的标准操作（push, pop, peek, empty）\n\n💡 解题思路：\n入队操作（push）直接往 stackIn 中加元素；\n出队操作（pop 或 peek）时，如果 stackOut 为空，则将 stackIn 中的所有元素倒序转移到 stackOut；\n保证先进先出（FIFO）的顺序。\n\n\n✅ JavaScript 实现：var MyQueue = function () &#123;    this.stackIn = [];    this.stackOut = [];&#125;;MyQueue.prototype.push = function (x) &#123;    this.stackIn.push(x);&#125;;MyQueue.prototype.pop = function () &#123;    if (this.stackOut.length === 0) &#123;        while (this.stackIn.length) &#123;            this.stackOut.push(this.stackIn.pop());        &#125;    &#125;    return this.stackOut.pop();&#125;;MyQueue.prototype.peek = function () &#123;    if (this.stackOut.length === 0) &#123;        while (this.stackIn.length) &#123;            this.stackOut.push(this.stackIn.pop());        &#125;    &#125;    return this.stackOut[this.stackOut.length - 1];&#125;;MyQueue.prototype.empty = function () &#123;    return this.stackIn.length === 0 &amp;&amp; this.stackOut.length === 0;&#125;;\n\n\n\n🧠 思考拓展：\n如果反过来是“用队列实现栈”应该怎么做？👉 LeetCode 225\n队列相关拓展题：滑动窗口最大值、最小栈等\n\n","categories":["算法"],"tags":["算法"]},{"title":"Day3-Block 分类、变量捕获与作用域","url":"/2025/04/25/Day3-Block-%E5%88%86%E7%B1%BB%E3%80%81%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"Block 分类、变量捕获与作用域一、Block 的分类Block 在 Objective-C 中，根据其存储位置和生命周期分为以下三类：\n\n\n\nBlock 类型\n存储位置\n特点说明\n\n\n\nGlobal Block\n全局区\n不捕获外部变量\n\n\nStack Block\n栈上\n捕获外部变量，随栈帧销毁\n\n\nHeap Block\n堆上\n捕获外部变量，Block_copy 后存在堆上\n\n\n示例：void (^block1)(void) = ^&#123;    NSLog(@&quot;Hello&quot;);&#125;;// Global Blockint a = 10;void (^block2)(void) = ^&#123;    NSLog(@&quot;a = %d&quot;, a);&#125;;// Stack Blockvoid (^block3)(void) = [block2 copy];// Heap Block\n\n\n二、变量捕获（Captured Variables）1. 默认捕获（值语义）Block 默认以值方式拷贝局部变量，不可修改。\nint a = 5;void (^block)(void) = ^&#123;    NSLog(@&quot;a is %d&quot;, a);&#125;;a = 6;block(); // 输出 a is 5\n\n2. __block 修饰（引用语义）允许在 Block 内部修改外部变量。\n__block int a = 5;void (^block)(void) = ^&#123;    a = 10;&#125;;block();NSLog(@&quot;a is %d&quot;, a); // 输出 a is 10\n\n3. 对象捕获（指针语义）对象变量以指针形式捕获，会被强引用。\nNSString *str = @&quot;Hello&quot;;void (^block)(void) = ^&#123;    NSLog(@&quot;%@&quot;, str);&#125;;// str 被 retain\n\n\n三、作用域与内存管理生命周期：\nStack Block 生命周期短，超出作用域会被销毁。\n需要异步使用时，必须将 Block copy 到堆上，变为 Heap Block。\nARC 下自动进行 copy 操作；MRC 需手动调用 Block_copy。\n\n示例（ARC 异步安全）：dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;    NSLog(@&quot;Block executed&quot;);&#125;);// ARC 自动 copy 到堆\n\n\n四、Swift 中的闭包捕获Swift 中闭包默认强引用捕获对象：\nclass MyClass &#123;    var name = &quot;Test&quot;    func doSomething() &#123;        DispatchQueue.global().async &#123; [weak self] in            print(self?.name ?? &quot;nil&quot;)        &#125;    &#125;&#125;\n\n使用 [weak self] &#x2F; [unowned self] 可避免循环引用。\n\n五、小结对比表\n\n\n分类\n是否捕获变量\n存储位置\n生命周期控制\n\n\n\nGlobal Block\n否\n全局区\n程序生命周期内常驻\n\n\nStack Block\n是\n栈上\n随栈帧销毁\n\n\nHeap Block\n是\n堆上\nBlock_copy 后存在于堆中\n\n\n","categories":["基础"]},{"title":"Day3-有效的括号","url":"/2025/04/25/Day3-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","content":"🔗 LeetCode 20 - Valid Parentheses\n📌 题目描述给定一个只包括 &#39;(&#39;, &#39;)&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;[&#39;, &#39;]&#39; 的字符串 s，判断字符串是否是有效的。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n空字符串也为有效字符串。\n\n\n💡 解题思路\n使用栈结构来处理括号匹配；\n遇到左括号就入栈，遇到右括号时判断是否和栈顶配对；\n若匹配，则弹出栈顶；否则直接返回 false；\n最后栈为空，则为合法字符串。\n\n\n✅ JavaScript 实现var isValid = function (s) &#123;    const stack = [];    const map = &#123;        &#x27;)&#x27;: &#x27;(&#x27;,        &#x27;&#125;&#x27;: &#x27;&#123;&#x27;,        &#x27;]&#x27;: &#x27;[&#x27;    &#125;;    for (let char of s) &#123;        if ([&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;].includes(char)) &#123;            stack.push(char);        &#125; else &#123;            if (stack.pop() !== map[char]) &#123;                return false;            &#125;        &#125;    &#125;    return stack.length === 0;&#125;;\n\n\n🧠 思考拓展\n括号匹配是栈结构经典应用，请理解其底层思想；\nLeetCode 拓展题推荐：\n22. Generate Parentheses（括号生成）\n32. Longest Valid Parentheses（最长有效括号）\n\n\n\n","categories":["算法"]},{"title":"Day4-Block 内存管理 & 循环引用分析","url":"/2025/04/27/Day4-Block-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90/","content":"Block 内存管理 &amp; 循环引用分析1. Block 的结构体本质Block 在底层其实是一个结构体：\nstruct Block_literal &#123;    void *isa;                      // 指向 Block 类对象    int flags;                      // 标志位（是否有 copy/dispose 等）    int reserved;                   // 保留字段    void (*invoke)(void *, ...);     // 函数指针，Block 实际执行逻辑    struct Block_descriptor *descriptor;  // Block 描述信息    // captured variables...&#125;;\n\n2. 捕获外部变量时，发生了什么？\n\n\n变量类型\n捕获方式\n内存管理行为\n\n\n\n基本数据类型（int&#x2F;float）\n值拷贝\n不影响内存管理\n\n\nObjective-C 对象\n强引用（retain）\n需要注意循环引用\n\n\n__block 修饰的对象\n指针拷贝，但本身仍可能强引用\n需配合 __weak __block\n\n\n3. Block 的 copy 和 dispose 函数Block 如果捕获了对象，底层会自动生成 copy 和 dispose 函数：\n\ncopy ： retain 捕获的对象\ndispose ： release 捕获的对象\n\n简化示例：\nvoid _Block_copy(void *dst, void *src) &#123;    objc_retain(capturedObj);&#125;void _Block_dispose(void *src) &#123;    objc_release(capturedObj);&#125;\n\n4. 深层次的循环引用分析常见导致 Block 循环引用的场景：\n\nNSTimer &#x2F; CADisplayLink &#x2F; GCD\n异步任务 (dispatch_async)\n链式调用\n\n标准防循环写法：\n__weak typeof(self) weakSelf = self;self.myBlock = ^&#123;    __strong typeof(weakSelf) strongSelf = weakSelf;    if (!strongSelf) return;    [strongSelf doSomething];&#125;;\n\n\n\nBlock 高频面试问答1. Block 的类型有哪些？分别什么时候出现？答：\n\nGlobal Block：不捕获外部变量，存储在全局区。\nStack Block：捕获了外部变量，存储在栈上。\nMalloc Block：拷贝自 Stack Block，存储在堆上。\n\nARC 下只存在 Global Block 和 Malloc Block。\n\n2. Block 在 ARC 下是如何内存管理的？答：\n\nARC 会自动对 Block 执行 copy 操作，将其从栈拷贝到堆上。\n使用 __strong 指针持有 Block 时，默认是堆 Block。\n\n\n3. 如何判断一个 Block 是否造成了循环引用？答：\n\n检查 Block 内是否使用了 self。\n检查 self 是否强引用了 Block（比如 Block 是 self 的属性）。\n使用 Instruments 的 Leaks 工具分析内存泄漏。\n\n\n4. __block 修饰符在 ARC 和 MRC 下分别是什么行为？答：\n\nMRC：__block 允许修改变量，但不会自动管理引用计数。\nARC：__block 允许修改，但并不会弱化引用关系，需要自己处理弱引用。\n\n\n5. Block 为什么容易引起内存泄漏？具体有哪些场景？答：因为 Block 捕获变量是强引用，特别是对象指针，如下场景常出问题：\n\nUIViewController 的 Block 属性内部引用了 self\nNSTimer、CADisplayLink、GCD 中的 Block\n\n解决办法：\n\n使用 __weak\n定时器使用 weakProxy\nGCD 注意生命周期控制\n\n\n小结理解 Block 的内存特性、引用关系变化（stack → heap）、以及在 ARC 下的默认 copy 机制，是彻底掌握 iOS 内存管理的关键。\n","categories":["基础"]},{"title":"Day4-有效的字母异位词","url":"/2025/04/27/Day4-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","content":"🔗 LeetCode 242 - Valid Anagram\n📌 题目描述：给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。\n字母异位词的定义：如果两个字符串中的字母出现的频率相同且字符完全一致，那么这两个字符串是字母异位词。\n\n💡 解题思路：•\t将两个字符串 s 和 t 的字母出现频次统计出来，若两个字符串的字母频次完全相同，则它们是字母异位词。\n•\t通过使用哈希表或数组存储字母的频率。\n\n\n✅ JavaScript 实现：var isAnagram = function (s, t) &#123;    if (s.length !== t.length) return false;        const count = new Array(26).fill(0);        for (let i = 0; i &lt; s.length; i++) &#123;        count[s.charCodeAt(i) - &#x27;a&#x27;.charCodeAt(0)]++;        count[t.charCodeAt(i) - &#x27;a&#x27;.charCodeAt(0)]--;    &#125;        for (let i = 0; i &lt; 26; i++) &#123;        if (count[i] !== 0) return false;    &#125;        return true;&#125;;\n\n\n\n\n🧠 思考拓展：•\t字母异位词问题的优化：如何减少不必要的比较，提升算法效率？\n•\t对比其他字符串相关的题目，比如 387. First Unique Character in a String。\n\n\n","categories":["算法"]},{"title":"Day5-Objective-C Runtime 基础结构","url":"/2025/04/28/Day5-Objective-C-Runtime-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/","content":"Objective-C Runtime 基础结构Objective-C 运行时系统（Runtime）是 Objective-C 语言的核心部分，它在程序运行期间负责管理类、对象、方法调用等行为。\n主要的结构体和组件包括：\n1. objc_class（类结构体）struct objc_class &#123;    Class isa;                // 指向元类    Class super_class;        // 父类    const char *name;         // 类名    long version;             // 版本信息    long info;                // 类信息标志    long instance_size;       // 类实例的大小    struct objc_ivar_list *ivars;    // 成员变量列表    struct objc_method_list **methodLists; // 方法列表（数组）    struct objc_cache *cache; // 方法缓存    struct objc_protocol_list *protocols; // 协议列表&#125;;\n\n注意：现代 Runtime 中，结构体已经变化了，上述是经典（早期）的描述，新的版本更复杂且高度封装。\n\n\n2. objc_object（对象结构体）struct objc_object &#123;    Class isa;  // 指向对象所属的类&#125;;\n\n每一个对象底层其实就是一个指针，最重要的成员就是 isa。\nisa 既可以指向 Class，也可以指向 Meta-Class（元类）。\n\n\n3. objc_method（方法结构体）struct objc_method &#123;    SEL name;      // 方法选择器（Selector）    char *types;   // 方法的参数和返回值类型编码    IMP imp;       // 方法实现的函数指针&#125;;\n\nSEL 是方法名的唯一标识。\nIMP 是函数指针，本质上就是 C 函数的地址。\n\n\n4. objc_ivar（成员变量结构体）struct objc_ivar &#123;    char *name;        // 变量名    char *typeEncoding; // 类型编码    int offset;         // 变量在对象内存中的偏移量&#125;;\n\n成员变量的信息，包括名字、类型和内存位置。\n\n\n5. objc_property（属性结构体）在现代 Runtime 里面，属性也有自己的结构：\ntypedef struct &#123;    const char *name;            // 属性名    const char *attributes;      // 属性修饰列表（例如：T@&quot;NSString&quot;,C,N,V_name）&#125; objc_property_t;\n\n属性其实是成员变量 + 一些特定特性（getter&#x2F;setter规则）。\n\n\n小总结\n\n\n组件\n作用\n\n\n\nobjc_object\n所有对象的基础\n\n\nobjc_class\n类对象描述结构\n\n\nobjc_method\n方法的定义\n\n\nobjc_ivar\n成员变量定义\n\n\nobjc_property\n属性定义\n\n\n\n进阶补充在 现代 Objective-C Runtime（如 iOS 14+），这些结构体实际上被进一步封装优化，比如：\n\n类使用 objc_class 和 objc_data_bits_t（联合体）分离了缓存、只读数据等。\nmethodList 也使用更紧凑的链表存储。\nisa 指针通过 isa 指针优化（ISA指针打包） 包含了更多信息，比如引用计数、是否有C++析构函数等。\n\n\n现代 Objective-C Runtime 的优化\n\nobjc_class 和 objc_data_bits_t 的分离\n\n早期（传统）的结构：\n在早期的 Objective-C Runtime 中，类对象（objc_class）包含了所有关于类的描述信息，包括：\n\nisa 指针（指向元类）\nsuper_class（父类指针）\n成员变量、方法列表、属性等\n\n这种结构虽然简单，但随着 iOS 设备性能的提高，运行时系统也需要对这些数据结构进行优化。\n现代优化：\n在 iOS 14 及之后的版本中，Objective-C Runtime 通过 分离 类的各个组成部分，提高了性能和内存效率。\nobjc_class 现在主要包含 元类的引用，而其它数据（如方法列表、属性、成员变量等）被移到了 objc_data_bits_t 结构中。这种方式的好处是：\n\n缓存友好：类的元数据可以被存储在内存的紧凑区域，提高了缓存命中率。\n分离存储：类数据和方法数据分开存储，避免了冗余的内存占用。\n增强的灵活性：可以在不同的硬件架构下对这些数据进行不同的布局，以便更好地适配不同的内存和处理器特性。\n\n例子：\nobjc_class 结构变得非常简洁：\nstruct objc_class &#123;    Class isa;                // 指向元类    Class super_class;        // 父类    const char *name;         // 类名    ...    objc_data_bits_t data;    // 类的其它元数据，如方法、属性、缓存等&#125;;\n\n而 objc_data_bits_t 则包含了实际的数据部分：\nunion objc_data_bits_t &#123;    struct &#123;        method_list_t *methodList;   // 方法列表        ivar_list_t *ivarList;       // 成员变量列表        property_list_t *propertyList; // 属性列表        cache_t cache;               // 方法缓存    &#125;;    uintptr_t raw; // 原始内存表示&#125;;\n\n\n\n\nmethodList 存储的优化\n\n早期存储：\n传统的 methodList 是基于链表（Linked List）存储的。这种方式虽然简单，但查找方法时效率较低，尤其是在类层级很深或者方法很多的情况下。\n现代优化：\n在现代的 Runtime 系统中，methodList 不再是单纯的链表。它现在采用了一种 紧凑的链表结构，并且结合了 哈希表（Hash Table） 或者 二叉搜索树（Binary Search Tree），大大提高了方法查找的效率。\n\n哈希表：通过哈希值来存储方法，查找操作时间复杂度为 O(1)。\n二叉搜索树：如果方法列表较大，可能使用树结构来提高查找性能（特别是方法名排序后）。\n\n这种优化使得对于频繁调用的方法，能够以更高的效率进行查找。\n优化的好处：\n\n方法查找速度更快。\n降低了内存占用，尤其在方法很多的类中表现尤为突出。\n\n\nisa 指针优化（ISA指针打包）\n\n早期 isa 指针：\n早期的 isa 指针实际上是一个单纯的指针，它指向当前对象所属的类。当我们需要判断一个对象的类型时，必须通过这个指针进行查找。这个过程虽然有效，但随着内存和处理器架构的变化，其效率并没有得到最优的利用。\n现代优化：\niOS 14 及之后的版本引入了 ISA 指针打包（ISA pointer packing） 的概念，使得 isa 指针变得更加高效。具体来说：\n\n压缩指针：isa 不仅仅是一个指针，它包含了更多的信息，包括：\n引用计数：可以通过 isa 字段直接获取对象的引用计数（而不需要额外的字段）。\nC++ 析构函数支持：对于 C++ 对象，isa 可以包含一个标记，表明该对象是否有 C++ 析构函数需要调用。\n指针压缩：针对 64 位设备，指针已经被压缩，节省了内存空间。\n指针布局：通过优化指针的布局，可以减少内存访问的延迟。例如，将常用的标记和信息放在 isa 中，减少了缓存缺失的概率。\n\n结构变化：\nstruct objc_object &#123;    Class isa;   // 压缩后的 isa 指针，包含更多信息&#125;;\n\n这种优化使得：\t•\t内存使用：减少了内存占用。\t•\t效率提升：访问对象所属类时的效率大幅提高。\n\n总结\n在现代 Objective-C Runtime 中，结构体的优化和指针的打包大大提升了系统的性能，尤其是在内存占用和方法查找速度上。重点优化如下：\t•\tobjc_class 和 objc_data_bits_t 的分离：提高了内存布局的紧凑性和效率。\t•\tmethodList 的优化：结合哈希表和二叉搜索树，提高了方法查找的效率。\t•\tisa 指针优化：通过指针打包，减少了内存占用，并加速了对象的类型查找和引用计数管理。\n这些改进的核心目的是：提升性能、减少内存占用，特别是在 iOS 设备上，确保运行时系统能够在有限的硬件资源上高效运行。\n\n","categories":["基础"]},{"title":"Day5-两数之和 II - 输入有序数组","url":"/2025/04/28/Day5-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"🔗 LeetCode 167 - Two Sum II - Input Array Is Sorted\n📌 题目描述给定一个已按升序排列的整数数组 numbers 和一个目标值 target，请你在数组中找出两个数，使得它们的和为目标值 target，并返回这两个数的下标。\n注意：  \n\n返回的答案是一个 1 索引的数组。\n假设每个输入只对应一个答案，且你不可以重复使用数组中的元素。\n\n\n💡 解题思路\n由于数组已排序，可以使用双指针法：\n\n初始化两个指针，一个指向数组的开头，一个指向数组的末尾。\n如果两指针指向的元素之和等于目标值，返回这两个指针的下标；\n如果和小于目标值，说明需要增大和，左指针右移；\n如果和大于目标值，说明需要减小和，右指针左移。\n\n\n这种方法时间复杂度是 O(n)，效率较高。\n\n\n\n✅ JavaScript 实现var twoSum = function (numbers, target) &#123;    let left = 0;    let right = numbers.length - 1;        while (left &lt; right) &#123;        const sum = numbers[left] + numbers[right];        if (sum === target) &#123;            return [left + 1, right + 1];  // 注意返回的下标是从 1 开始的        &#125; else if (sum &lt; target) &#123;            left++;        &#125; else &#123;            right--;        &#125;    &#125;&#125;;\n\n\n🧠 思考拓展\n如果数组不是有序的，如何解决这个问题？\n本题和 LeetCode 1. Two Sum 的区别是什么？它是如何利用排序优化解法的？\n\n\n","categories":["算法"]},{"title":"Day6-Runtime 实战技巧","url":"/2025/04/29/Day6-Runtime-%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/","content":"一、定义Runtime 是什么？\n\nObjective-C 的 Runtime 实际上是 C 语言的一套函数和类库，用于支持 Objective-C 编程语言的动态性，包括类的创建、方法调用、属性访问等。\n\n\n二、Runtime 实战技巧1.Method Swizzling（方法交换）1. 什么是 Method Swizzling？\n定义：在程序运行时，交换两个方法实现的过程。\n本质：修改方法对应的 IMP（指向函数实现的指针）。\n常用场景：\n给系统方法加功能\n替换系统方法行为\nAOP\n\n\n\n2. 如何实现 Swizzling？常用 API：\nMethod class_getInstanceMethod(Class cls, SEL name);void method_exchangeImplementations(Method m1, Method m2);\n\n代码示例：\n@implementation UIViewController (Swizzling)+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Method originalMethod = class_getInstanceMethod(self, @selector(viewWillAppear:));        Method swizzledMethod = class_getInstanceMethod(self, @selector(my_viewWillAppear:));        method_exchangeImplementations(originalMethod, swizzledMethod);    &#125;);&#125;- (void)my_viewWillAppear:(BOOL)animated &#123;    NSLog(@&quot;页面将要出现：%@&quot;, self);    [self my_viewWillAppear:animated];&#125;@end\n\n3. 注意事项\n+load 和 dispatch_once 保证只执行一次。\n确保方法存在，避免引起程序崩溃。\n注意继承关系和子类覆盖问题。\n\n\n2.消息转发机制1. 什么是消息转发？\n当对象收到无法响应的消息，有三次机会处理：\n动态方法解析（resolveInstanceMethod:）\n备用接收者（forwardingTargetForSelector:）\n完整消息转发（forwardInvocation:）\n\n\n\n2. 详细流程（１）动态方法解析+ (BOOL)resolveInstanceMethod:(SEL)sel\n示例：\n+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;    if (sel == @selector(run)) &#123;        class_addMethod(self, sel, (IMP)runFunction, &quot;v@:&quot;);        return YES;    &#125;    return [super resolveInstanceMethod:sel];&#125;\n\n（２）快速转发- (id)forwardingTargetForSelector:(SEL)aSelector\n示例：\n- (id)forwardingTargetForSelector:(SEL)aSelector &#123;    if (aSelector == @selector(run)) &#123;        return self.delegate;    &#125;    return [super forwardingTargetForSelector:aSelector];&#125;\n\n（３）完整消息转发- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector- (void)forwardInvocation:(NSInvocation *)anInvocation\n示例：\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;    if (aSelector == @selector(run)) &#123;        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];    &#125;    return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;    SEL sel = [anInvocation selector];    if ([self.delegate respondsToSelector:sel]) &#123;        [anInvocation invokeWithTarget:self.delegate];    &#125; else &#123;        [super forwardInvocation:anInvocation];    &#125;&#125;\n\n3. 关联对象 (Associated Objects)定义：在不改动原类的基础上，给分类、扩展类增加实体属性。\n常用 API：\n\nobjc_setAssociatedObject\nobjc_getAssociatedObject\n\n应用场景：\n\nUIButton 增加防重复点击时间间隔\n\n4. 动态生成类和方法常用 API：\n\nobjc_allocateClassPair\nclass_addMethod\n\n应用场景：\n\nKVO 内部原理（创建子类）\nORM框架自动生成对应属性\n\n5. 完全自动 NSCoding 完成思路：通过 Runtime 遍历 ivar，自动 encode&#x2F;decode，无需手写代码。\n应用场景：\n\nModel 持久化\n简化用户数据处理\n\n6. 实现安全防护（防 Crash）思路：更换 NSArray, NSDictionary, NSString 等类的方法，防止路径错误、索引越界等 crash。\n应用场景：\n\n安全性框架 SafeKit\n项目安全级别提升\n\n7. 数据模型实体化（完全自动化等）思路：通过 property 列表，根据 key-value 将 JSON 转为 Model，或反转。\n应用场景：\n\nYYModel\nMJExtension\n\n8. 方法替换 IMP应用：\n\nhook 系统方法，并加自己逻辑\n控制方法执行流程\n\n示例：\n\n在 App 进入前后台时，统一管理封装\n\n9. 高级消息转发 (NSProxy)应用：\n\n弱代理（避免循环引用、Timer 泄漏）\n多代理同步分发\n性能强化\n\n\n三、实战案例案例1：防止 UIButton 重复点击背景\n\nUIButton 连续点击容易造成接口重复请求。\n想给所有 UIButton 加防抖，不改动现有业务代码。\n\n\n思路\n用 Method Swizzling，替换 sendAction:to:forEvent: 方法，在里面加节流逻辑。\n\n代码示例\nUIButton+AntiRepeat.h\n#import &lt;UIKit/UIKit.h&gt;@interface UIButton (AntiRepeat)@property (nonatomic, assign) NSTimeInterval eventInterval; // 点击间隔@property (nonatomic, assign) NSTimeInterval lastEventTime; // 上次点击时间@end\nUIButton+AntiRepeat.m\n#import &quot;UIButton+AntiRepeat.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIButton (AntiRepeat)+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Method original = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));        Method swizzled = class_getInstanceMethod(self, @selector(my_sendAction:to:forEvent:));        method_exchangeImplementations(original, swizzled);    &#125;);&#125;// 关联对象 eventInterval- (NSTimeInterval)eventInterval &#123;    return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setEventInterval:(NSTimeInterval)eventInterval &#123;    objc_setAssociatedObject(self, @selector(eventInterval), @(eventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;// 关联对象 lastEventTime- (NSTimeInterval)lastEventTime &#123;    return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setLastEventTime:(NSTimeInterval)lastEventTime &#123;    objc_setAssociatedObject(self, @selector(lastEventTime), @(lastEventTime), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;// 新的方法- (void)my_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;    if (NSDate.date.timeIntervalSince1970 - self.lastEventTime &lt; self.eventInterval) &#123;        return; // 点击间隔太短，忽略    &#125;    self.lastEventTime = NSDate.date.timeIntervalSince1970;    [self my_sendAction:action to:target forEvent:event];&#125;@end\n\n\n\n使用\nUIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];btn.eventInterval = 1.0; // 设置 1 秒内不能重复点击\n\n讲解要点\n\nsendAction:to:forEvent: 是 UIButton 处理点击事件的入口。\n通过 Swizzling，在不改业务代码的情况下统一加了防抖。\n使用 objc_setAssociatedObject 给分类动态添加属性，记录最后一次点击时间。\n\n案例2：用 NSProxy 实现弱代理（防止 Timer 循环引用）\nNSProxy 作为中介\n弱持 target\n\n背景\n\nNSTimer 默认强引用 target，容易造成内存泄漏（循环引用）。\n\n\n思路\n使用 NSProxy 中转，让 Timer 弱引用真正的 target。\n\n代码示例\nTimerWeakProxy.h\n#import &lt;Foundation/Foundation.h&gt;@interface TimerWeakProxy : NSProxy+ (instancetype)proxyWithTarget:(id)target;@end\nTimerWeakProxy.m\n#import &quot;TimerWeakProxy.h&quot;@interface TimerWeakProxy ()@property (nonatomic, weak) id target;@end@implementation TimerWeakProxy+ (instancetype)proxyWithTarget:(id)target &#123;    TimerWeakProxy *proxy = [TimerWeakProxy alloc];    proxy.target = target;    return proxy;&#125;- (id)forwardingTargetForSelector:(SEL)selector &#123;    return self.target;&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123;    [invocation invokeWithTarget:self.target];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;    return [self.target methodSignatureForSelector:sel];&#125;@end\n\n\n使用\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0                                              target:[TimerWeakProxy proxyWithTarget:self]                                            selector:@selector(timerAction)                                            userInfo:nil                                             repeats:YES];\n\n\n讲解要点\n\nTimerWeakProxy 持有 target 的弱引用，防止循环引用。\nforwardingTargetForSelector: 提供快速消息转发，提高性能。\n\n案例3：自动 JSON -&gt; Model 映射\n利用 property 列表遍历\n高效方便，性能好\n\n案例4：安全防护套件\nNSArray、NSDictionary 进行方法替换，防止错误操作\n\n\n四、完整思维图\n\n\n技术\n作用\n具体场景\n\n\n\nMethod Swizzling\n修改系统方法\nAOP 打点\n\n\n消息转发\n动态处理未知方法\n弱代理\n\n\nAssociated Object\n扩展分类属性\nUIButton 防重点\n\n\n自动 NSCoding\n自动化存储连贯\nModel 持久化\n\n\nNSProxy\n高级转发\nTimer 弱代理\n\n\n\n五、常考问题\n说说你对 Runtime 的理解？\n\n\nRuntime 是 OC 的运行时系统，允许程序在运行时进行对象操作（如消息发送、方法交换、类创建等）。\n动态性是 Objective-C 最重要的特性之一，基于 Runtime 实现。\n\n\n\n什么是 Method Swizzling？使用时注意什么？\n\n\n定义：交换两个方法的实现。\n注意：\n使用 dispatch_once 保证只交换一次。\n确认方法存在再交换，避免崩溃。\n维护好调用链，防止死循环。\n避免过度使用，破坏封装性。\n\n\n\nMethod Swizzling 常用在哪些场景？\n\n\n统一加日志打点（比如 UIViewController 生命周期）\n替换系统方法功能（如统计点击事件）\nAOP 编程实践\n框架内部增强（如 AFNetworking 的某些 hook）\n\n\n\n消息发送流程是怎样的？\n\n\n调用方法 -&gt; 转成 objc_msgSend 发送消息。\n如果找不到方法：\n动态方法解析（resolveInstanceMethod:）\n快速转发（forwardingTargetForSelector:）\n完整消息转发（forwardInvocation:）\n最后抛出 unrecognized selector sent to instance 异常。\n\n\n\n\n\n消息转发和代理模式有什么关系？\n\n\n代理（delegate）本质就是消息转发的一种应用。\n可以通过 forwardingTargetForSelector: 把不支持的方法交给代理对象执行。\n复杂代理模式（如 NSProxy 多代理）就是用完整消息转发实现的。\n\n\n\nSwizzling 和 Hook 的区别？\n\n\nSwizzling：指“方法交换”，主要改变对象的方法实现。\nHook：更广义，指拦截并修改程序执行过程，可以是方法层面、函数层面（Fishhook）、甚至是汇编指令层面。\n\n\n\n为什么 +load 方法适合做 Swizzling？\n\n\n+load 是在类（或分类）被加载到内存时立即调用的，优先于 main()。\n保证在对象使用前就完成方法交换。\n\n补充：如果想更灵活控制，某些框架（如 Aspects）会在 +initialize 做 Swizzling，但要注意 initialize 只会在第一次发送消息前调用。\n\n\n使用 Runtime 有哪些风险？\n\n\n方法交换过多，容易导致难以维护和调试。\n消息转发链过长，可能导致性能下降。\n动态添加方法时参数类型签名不正确，可能导致运行时崩溃。\n无法被编译器静态检查，出错时很难定位。\n\n\n\nNSProxy 是什么？为什么需要它？\n\n\nNSProxy 是一个轻量级的基类，专门用于实现消息转发。\n典型场景：\n远程方法调用（RPC）\n多代理管理（如 YYTextKeyboardManager）\n相比 NSObject，NSProxy 没有实例变量，直接走完整消息转发流程。\n\n\n","categories":["基础"]},{"title":"Day6-删除有序数组中的重复项","url":"/2025/04/29/Day6-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","content":"🔗 LeetCode 26 - Remove Duplicates from Sorted Array\n📌 题目描述给你一个 升序排列 的数组 nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 O(1) 额外空间的条件下原地修改输入数组。\n示例：\n输入: nums = [1,1,2]输出: 2, nums = [1,2,_]\n\n\n💡 解题思路\n使用 双指针：\n\nslow 指针表示当前处理的唯一元素下标；\nfast 指针遍历数组，当遇到一个与 nums[slow] 不同的元素时，将其赋值给 nums[slow + 1]，然后 slow 前进一步。\n\n\n遍历结束后，slow + 1 就是新数组的长度。\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n\n✅ JavaScript 实现var removeDuplicates = function(nums) &#123;    if (nums.length === 0) return 0;        let slow = 0;        for (let fast = 1; fast &lt; nums.length; fast++) &#123;        if (nums[fast] !== nums[slow]) &#123;            slow++;            nums[slow] = nums[fast];        &#125;    &#125;        return slow + 1;&#125;;\n\n\n🧠 思考拓展\n如果要求每个元素最多出现两次怎么办？（参考 LeetCode 80）\n这道题为什么必须是原地修改？有什么实际应用场景？\n\n\n","categories":["算法"]},{"title":"Day7-Runtime&Block","url":"/2025/04/30/Day7-Runtime&Block/","content":"RuntimeiOS Runtime，通常称为Objective-C Runtime，是iOS开发中一个至关重要的组件。它是一套底层的C语言API，为Objective-C的动态特性提供了强大的支持。本文将对iOS Runtime进行深入的解析，从基本概念到主要功能，再到实际应用和注意事项，全方位地展示这一技术的魅力。\n一、Runtime基本概念Runtime，即运行时，指的是程序在运行过程中进行的一系列操作。在Objective-C中，Runtime系统允许我们在程序运行时动态地操作类和对象，执行诸如检查和改变对象、交换方法实现、动态添加方法或属性等操作。这种动态性为开发者带来了极大的灵活性。\nObjective-C作为一门动态语言，与C语言等静态语言在编译和运行时有着显著的区别。静态语言在编译阶段就确定了所有的方法调用和对象类型，而动态语言则在运行时才确定这些操作。Objective-C通过Runtime系统实现了这一动态性，使得我们可以在运行时动态地创建类和对象、进行消息传递和转发。\n二、Runtime数据结构在深入Runtime的功能之前，我们需要先了解其底层的数据结构。iOS Runtime的核心数据结构包括objc_class、objc_object等。\n\nobjc_object：这是所有Objective-C对象的基类结构体，其中包含一个isa指针，指向该对象所属的类。\n\nobjc_class：这是类的结构体，它继承自objc_object。objc_class中包含了类的各种信息，如父类指针、方法列表、方法缓存、属性列表、协议列表等。\n\nisa：指向该类的元类（meta-class），元类中存储了类的类方法。\nsuper_class：指向该类的父类。\nname：类的名称。\nversion：类的版本信息。\ninfo：类的详细信息。\ninstance_size：该类实例对象的大小。\nmethodLists：指向该类的实例方法列表的指针的指针，可以动态修改。\ncache：方法缓存，用于存储被频繁调用的方法，以提高查找效率。\nprotocols：指向该类的协议列表。\n\n\n\n三、Runtime主要功能iOS Runtime提供了许多强大的功能，这些功能使得Objective-C成为一门极具动态性的编程语言。\n\n动态添加类和方法：\nRuntime允许我们在运行时动态地创建新的类，并向已有的类中添加新的方法或实例变量。这种动态性使得我们可以在不修改原有代码的情况下，为类添加新的功能。例如，通过objc_allocateClassPair和objc_registerClassPair函数可以动态创建和注册一个新的类；通过class_addMethod函数可以向已有的类中添加新的方法。\n\n消息传递和消息转发：\nObjective-C中的方法调用实际上是一种消息传递机制。当我们向一个对象发送消息时，Runtime系统会根据消息的名称（即选择器SEL）在对象的类及其父类中查找对应的方法实现。如果找到了匹配的方法，就调用该方法；如果没有找到，则进入消息转发机制。消息转发机制允许我们在运行时动态地处理未实现的方法调用，而不是直接崩溃。例如，通过实现forwardingTargetForSelector:方法，我们可以将未实现的消息转发给其他对象来处理。\n\n关联对象：\nRuntime允许我们给现有的类动态地关联新的属性。这种关联属性不会改变原有类的结构，也不会影响其他类的使用。这在某些情况下可以避免子类化，从而简化代码结构。例如，通过objc_setAssociatedObject和objc_getAssociatedObject函数可以为对象关联和获取新的属性。\n\n获取类信息：\nRuntime提供了一系列函数来获取类的信息，包括类名、父类、实例变量、方法列表、协议列表等。这些信息对于调试和反射等高级操作非常有用。例如，通过class_getName函数可以获取类的名称；通过class_copyMethodList函数可以获取类的方法列表。\n\n方法交换：\nRuntime允许我们在运行时交换两个方法的实现。这种功能在某些情况下可以用来实现方法的替换或调试。例如，通过method_exchangeImplementations函数可以交换两个方法的实现。\n\n\n四、Runtime实际应用iOS Runtime在开发中有着广泛的应用，以下是一些常见的用例和示例：\n\n给系统类添加属性或方法：\n通过Runtime，我们可以为系统类（如NSString、UIButton等）添加新的属性或方法。这种操作通常用于扩展系统类的功能，而无需创建子类。例如，我们可以为NSString类添加一个计算字符串哈希值的方法。\n\n方法交换：\n方法交换是Runtime的一个强大功能，它允许我们在运行时交换两个方法的实现。这种操作通常用于调试或实现某些特定的功能。例如，我们可以通过交换UIViewController的viewDidLoad和viewWillAppear:方法的实现来观察这两个方法在不同时机下的行为。\n\nKVO（Key-Value Observing）和KVC（Key-Value Coding）：\nKVO和KVC是Objective-C中的两种高级特性，它们分别用于观察对象属性的变化和通过键值对来访问对象的属性。这两种特性都依赖于Runtime系统来实现。例如，KVO通过Runtime在对象的属性被修改时触发相应的通知；KVC则通过Runtime在运行时动态地访问和修改对象的属性。\n\n字典转模型：\n在iOS开发中，我们经常需要将JSON字典转换为模型对象。通过Runtime，我们可以实现一个通用的字典转模型的工具类，该工具类可以自动地将JSON字典中的键值对映射到模型对象的属性上。这种操作大大提高了代码的可重用性和可维护性。\n\n消息转发机制：\n当对象接收到一个未实现的消息时，可以通过消息转发机制来动态地处理这个消息。这种机制允许我们在不改变原有代码的情况下，为对象添加新的功能或处理错误情况。例如，当对象接收到一个未实现的方法调用时，我们可以通过实现forwardingTargetForSelector:或forwardInvocation:方法来处理这个消息。\n\n\n五、注意事项虽然iOS Runtime提供了许多强大的功能，但在使用时也需要注意以下几点：\n\n稳定性：\n动态地修改类的结构和行为可能会破坏代码的稳定性。因此，在使用Runtime功能时需要谨慎考虑其对系统稳定性的影响。\n\n可维护性：\n过度使用Runtime功能可能会降低代码的可读性和可维护性。因此，在开发过程中需要权衡利弊，合理地使用Runtime功能。\n\n性能：\n虽然Runtime系统提供了许多高效的数据结构和算法来优化性能，但在某些情况下（如频繁地动态添加或删除方法），仍然可能会对性能产生一定的影响。因此，在使用Runtime功能时需要关注其对性能的影响。\n\n\n六、总结iOS Runtime是Objective-C语言动态特性的基石，它提供了一系列强大的功能来支持动态性和灵活性。通过深入了解Runtime的基本概念、数据结构、主要功能和实际应用，我们可以更好地利用这一技术来开发高效、灵活和可维护的iOS应用程序。同时，也需要注意在使用Runtime功能时保持代码的稳定性和可读性。\nBlockBlock是苹果公司在OSX10.6和iOS4.0中引入的一项功能，它极大地丰富了C语言的特性，并提供了类似其他语言中闭包（closure）的功能。Block本质上是一个带有自动变量（局部变量）的匿名函数，其底层实现包含isa指针，因此也可以被看作是块对象。本文将深入解析iOS中的Block，包括其概念、声明与定义、捕获变量的机制、内存管理以及使用场景等方面。\n一、Block的基础概念Block又称为块或块对象，是苹果在改进C&#x2F;OC&#x2F;C++&#x2F;OC++等语言的编译处理时的重要成果。它的出现旨在替代指针函数，使得代码更加简洁和易用。Block的语法结构包括返回类型、变量名（可省略）、参数列表以及实现体，使用脱字符“^”和花括号“{}”来表示。\n二、Block的声明与定义Block的声明语法相对独特，格式为“返回值类型(^block变量名)(参数列表)”。例如，“int(^personBlock)(NSString ,int)”声明了一个名为personBlock的Block变量，它接收两个参数（一个NSString类型和一个int类型），并返回一个int类型的值。\nBlock的定义则是在声明的基础上，使用“&#x3D;”符号和“^”符号来引入实现体。例如：\nNSString* (^personBlock)(NSString*,int) = ^(NSString* name, int age)&#123;    NSLog(@&quot;年龄==%d&quot;, age);    return name;&#125;;\n\n这段代码定义了一个名为personBlock的Block，它接收一个NSString*类型的name和一个int类型的age作为参数，打印年龄并返回name。\n三、Block捕获变量的机制Block可以捕获其声明范围内的所有变量，但捕获的自动变量默认是不可修改的。如果需要修改，则需要在变量前加上__block修饰符。__block修饰符告诉编译器，该变量可能会在Block中被修改，因此需要在Block的实现体中保留一个指向该变量的指针。\n此外，Block总能修改实例变量、静态变量、全局变量和全局静态变量，无需加__block修饰符。\n四、Block的内存管理在iOS中，Block的内存管理是一个重要的考虑因素。Block有三种存储位置：栈（_NSConcreteStackBlock）、堆（_NSConcreteMallocBlock）和全局（_NSConcreteGlobalBlock）。\n\n栈上的Block：当Block在方法内部声明且没有引用外部变量时，它通常被分配在栈上。栈上的Block在方法返回时会被销毁。\n堆上的Block：当Block引用外部变量或作为属性存储时，它会被复制到堆上。堆上的Block在引用计数为0时才会被销毁。\n全局的Block：不访问任何外部变量的Block可以被视为全局Block，它们通常被分配在全局数据区。\n\n在ARC（自动引用计数）环境下，系统通常会自动将Block从栈复制到堆上，以避免栈上的Block被销毁。然而，在MRC（手动引用计数）环境下，开发者需要手动管理Block的内存。\n五、Block的使用场景Block在iOS开发中有广泛的应用场景，包括但不限于：\n\n作为参数传递：Block可以作为函数的参数传递，这使得函数能够接收一段代码作为参数，并在需要时执行这段代码。这种特性使得Block在回调函数、动画处理等方面非常有用。\n闭包：Block的闭包特性使得它能够捕获并保留其声明范围内的变量，即使这些变量在Block外部已经被销毁。这使得Block能够在异步操作、定时器回调等场景中保持对外部变量的访问。\n适配器模式：Block可以用作适配器模式中的“转换函数”，将一种接口转换为另一种接口。这在处理不同数据源或不同格式的数据时非常有用。\n解决循环引用：在使用Block时，需要注意循环引用的问题。特别是当Block作为对象的属性存储时，如果对象也持有Block的引用，就会形成循环引用。为了避免这种情况，可以使用__weak关键字来声明对对象的弱引用，从而在Block中避免循环引用。\n\n六、Block使用注意点及常见问题\nBlock作为类变量属性时用copy修饰：\n\n原因：Block作为类属性时，用copy修饰符可以将Block从栈拷贝到堆中，防止Block在方法返回后被销毁。\n注意：赋值给一个weak变量时，Block不会被copy到堆上。\n\n\n不能修改外部自动变量问题：\n\n解决方案：使用__block修饰符来修饰需要修改的外部自动变量。\n\n\n循环引用问题：\n\n解决方案：使用__weak关键字来声明对对象的弱引用，从而避免循环引用。在需要访问self属性时，可以在Block内部使用[weak self]和[strong self]的技巧来确保self在Block执行期间不会被释放。\n\n\n\n七、总结Block是iOS开发中一项非常强大的功能，它提供了简洁且易用的接口来封装代码块，并允许捕获和保留外部变量。然而，在使用Block时，也需要注意其内存管理和循环引用等问题。通过深入理解Block的底层实现和使用场景，开发者可以更加高效地利用这一功能来编写出更加优雅和健壮的代码。\n","categories":["基础"]},{"title":"Day7-合并两个有序链表","url":"/2025/04/30/Day7-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","content":"🔗 LeetCode 21 - Merge Two Sorted Lists\n📌 题目描述将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例：\n输入: l1 = [1,2,4], l2 = [1,3,4]输出: [1,1,2,3,4,4]\n\n\n💡 解题思路\n使用 递归 或 迭代 方法逐步将两个链表中较小的节点连接起来；\n\n递归写法简洁优雅，但迭代写法更容易控制空间复杂度。\n\n时间复杂度：O(n + m)，其中 n 和 m 分别是两个链表的长度；\n\n空间复杂度：\n\n递归：O(n + m)，因为递归栈；\n迭代：O(1)\n\n\n\n\n✅ JavaScript 实现（迭代）var mergeTwoLists = function(l1, l2) &#123;    let dummy = new ListNode(-1);    let current = dummy;    while (l1 !== null &amp;&amp; l2 !== null) &#123;        if (l1.val &lt;= l2.val) &#123;            current.next = l1;            l1 = l1.next;        &#125; else &#123;            current.next = l2;            l2 = l2.next;        &#125;        current = current.next;    &#125;    current.next = l1 !== null ? l1 : l2;    return dummy.next;&#125;;\n\n\n✅ JavaScript 实现（递归）var mergeTwoLists = function(l1, l2) &#123;    if (l1 === null) return l2;    if (l2 === null) return l1;    if (l1.val &lt;= l2.val) &#123;        l1.next = mergeTwoLists(l1.next, l2);        return l1;    &#125; else &#123;        l2.next = mergeTwoLists(l1, l2.next);        return l2;    &#125;&#125;;\n\n\n🧠 思考拓展\n如何在不创建新链表节点的情况下合并？\n如果链表不是升序而是无序，如何合并后排序？\n\n\n","categories":["算法"]},{"title":"Day8-RunLoop 构成与线程保活","url":"/2025/05/06/Day8-RunLoop-%E6%9E%84%E6%88%90%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB/","content":"一、RunLoop 的构成RunLoop 是基于 CFRunLoopRef（Core Foundation 层）构建的，NSRunLoop 是其 Foundation 层的封装。核心组成如下：\n1. RunLoop 对象\n每条线程都有唯一的一个 RunLoop 对象（主线程默认创建，子线程需手动创建）。\n\n2. RunLoopMode\nRunLoop 在任一时刻只能运行在一种模式下。\n常见模式：\nNSDefaultRunLoopMode\nUITrackingRunLoopMode\nNSRunLoopCommonModes\n\n\n\n3. Source（事件源）\nSource0：非基于 Port 的，如 performSelector:onThread:\nSource1：基于 Port 的，如 GCD 主线程通信\n\n4. Timer\nNSTimer 和 CADisplayLink 都依赖 RunLoop\n\n5. Observer（观察者）\n监听 RunLoop 状态变化，如将要进入、即将处理事件、即将休眠等\n\n6. Port\n线程通信载体，配合 Source1 使用\n\n\n二、RunLoop 与线程保活1. 子线程默认行为任务执行完即退出，因为没有 RunLoop。\n2. 线程保活方式- (void)startThread &#123;    NSThread *thread = [[NSThread alloc] initWithBlock:^&#123;        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];        [[NSRunLoop currentRunLoop] run];    &#125;];    [thread start];&#125;\n\n3. 注意事项\nrun 会阻塞线程。\nRunLoop 需要至少一个 Input Source 否则会立刻退出。\n\n\n三、RunLoop 的实际应用（含示例）1. 保持线程不退出后台日志收集&#x2F;解码任务中使用 RunLoop 保活线程。\n2. 事件响应机制如 Touch、Button 点击，通过 Source1 分发给主线程 RunLoop。\n3. 定时器NSTimer&#x2F;CADisplayLink 依赖 RunLoop 触发。\n4. GCD 主队列回调延迟主线程卡顿时延迟执行，原因是 GCD 回调依赖 Source1。\n5. UI 滚动与事件隔离滚动 UIScrollView 时切换 Mode，暂停定时器触发。\n6. AutoreleasePool 管理RunLoop 每次循环自动创建&#x2F;释放 pool，防止泄露。\n7. 线程间通信基于 Port 的消息传递，结合 Source1 实现。\n\n四、RunLoop 实现原理RunLoop 本质是一个基于事件循环的结构：\nwhile (!stop) &#123;    __CFRunLoopDoObservers(kCFRunLoopEntry);    __CFRunLoopDoTimers();    __CFRunLoopDoSources0();    mach_msg(); // 等待消息唤醒    __CFRunLoopDoSources1();    __CFRunLoopDoObservers(kCFRunLoopExit);&#125;\n\n核心机制：\n\n\n模块\n说明\n\n\n\nmach_port\n底层通信机制\n\n\nSource0\n自定义事件\n\n\nSource1\n系统事件（如 GCD）\n\n\nTimer\n定时任务\n\n\nObserver\n状态监听\n\n\nMode\n事件隔离与切换模式\n\n\nMode 与 Input Source 关系结构：RunLoop ├── ModeA │    ├── Source0 │    ├── Source1 │    ├── Timer │    └── Observer └── ModeB      ├── Source0      └── ...\n\n\n五、总结\n\n\n分类\n应用\n\n\n\nUI交互\n事件响应、触摸分发、主队列 GCD\n\n\n多线程\n线程保活、线程通信\n\n\n性能优化\n滚动时暂停动画\n\n\n内存管理\n自动释放池管理\n\n\n动画处理\nCADisplayLink 刷新帧率\n\n\n","categories":["基础"]},{"title":"Day9-RunLoop 卡顿优化与监控实现","url":"/2025/05/07/Day9-RunLoop-%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%AE%9E%E7%8E%B0/","content":"iOS RunLoop 卡顿优化指南一、理解 RunLoop 卡顿的本质1. RunLoop 基本机制RunLoop 本质上是一个事件循环机制，主要用于线程的任务调度。在主线程中，RunLoop 负责处理：\n\n触摸事件\n定时器事件（NSTimer、CADisplayLink）\nUI 渲染\nGCD 主队列任务\n系统事件（比如键盘弹出）\n\n2. 卡顿现象原因主线程卡顿的本质是 RunLoop 长时间没有返回到空闲状态，常见原因：\n\n同步耗时任务阻塞主线程（如文件 IO、网络请求、复杂计算）\nUI 渲染过慢（大量绘制、图片解码）\n高频次定时器任务\n死锁或线程抢占资源\n\n二、RunLoop 卡顿监控1. 使用 RunLoop Observer 检测卡顿CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(NULL, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;    // 记录进入和退出时间，判断耗时&#125;);CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n\n2. 常用工具\nFPS 监控工具\nTime Profiler（定位卡顿调用栈）\nInstruments 的 Core Animation（检测 UI 绘制）\n自行实现卡顿监控（可设定阈值，如超过 200ms）\n\n三、RunLoop 卡顿优化策略1. 减少主线程压力\n耗时操作异步处理：如网络、数据库、压缩、解码\n使用 GCD 或 NSOperation 将任务放在子线程\n\nDispatchQueue.global().async &#123;    // 耗时操作    DispatchQueue.main.async &#123;        // 回主线程更新 UI    &#125;&#125;\n\n2. 延迟或分批执行任务\n使用 RunLoop idle 时机处理任务\n利用 CADisplayLink 拆分任务（典型如 tableView cell 异步绘制）\n\nCADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(step)];[link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];\n\n3. 图像加载优化\n图片解码、压缩处理放到子线程\n使用异步图片加载框架（如 SDWebImage、Kingfisher）\n\n4. 优化 UI 绘制\n减少不必要的视图层级\n合理使用 rasterization, shouldRasterize，避免频繁重绘\n尽量使用 CALayer 做动画或绘制\n\n5. 优化定时器\n避免使用过多高频率的 NSTimer\n用 CADisplayLink 或 DispatchSourceTimer 精确控制\n注意释放定时器，防止循环引用或内存泄漏\n\n四、进阶建议使用 RunLoop 模型实现任务调度（如 YYKit 的 AsyncLayer）核心思想：\n\n主线程每帧空闲阶段处理少量任务（每帧分批）\n避免阻塞主线程\n\n利用信号量&#x2F; watchdog 检测严重卡顿可用 dispatch_semaphore 配合子线程检测主线程长时间不响应，进行卡顿上报。\n五、总结\n\n\n优化手段\n是否推荐\n场景说明\n\n\n\n耗时任务异步化\n✅\n网络、图片、计算等\n\n\nUI 绘制优化\n✅\n多图页面、复杂视图\n\n\nRunLoop 空闲任务调度\n✅\n批量任务，降低瞬时压力\n\n\n卡顿监控工具接入\n✅\n提前发现问题\n\n\n自定义 RunLoop 调度\n✅\n高阶优化，如任务优先级\n\n\n\niOS 主线程卡顿监控实现方案🔧 方案核心思路\n利用 CFRunLoopObserver 监听 RunLoop 各阶段；\n在子线程中开启定时器，检查主线程是否长时间停留在某个阶段；\n超过阈值（如 200ms）即判定为卡顿，并记录堆栈。\n\n✅ 示例代码（Objective-C）@interface MainThreadMonitor : NSObject@end@implementation MainThreadMonitor &#123;    CFRunLoopObserverRef observer;    dispatch_semaphore_t semaphore;    CFRunLoopActivity activity;    BOOL isMonitoring;&#125;- (instancetype)init &#123;    if (self = [super init]) &#123;        semaphore = dispatch_semaphore_create(0);    &#125;    return self;&#125;- (void)startMonitoring &#123;    if (isMonitoring) return;    isMonitoring = YES;    // 1. 设置 RunLoop 观察者    CFRunLoopObserverContext context = &#123;0, (__bridge void *)self, NULL, NULL, NULL&#125;;    observer = CFRunLoopObserverCreate(NULL, kCFRunLoopAllActivities, YES, 0, &amp;runLoopCallback, &amp;context);    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);        // 2. 在子线程中检测主线程卡顿    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;        while (self-&gt;isMonitoring) &#123;            long result = dispatch_semaphore_wait(self-&gt;semaphore, dispatch_time(DISPATCH_TIME_NOW, 200 * NSEC_PER_MSEC));            if (result != 0) &#123;                if (self-&gt;activity == kCFRunLoopBeforeSources || self-&gt;activity == kCFRunLoopAfterWaiting) &#123;                    NSLog(@&quot;⚠️ 发现卡顿&quot;);                    [self logMainThreadStack];                &#125;            &#125;        &#125;    &#125;);&#125;// RunLoop 回调static void runLoopCallback(CFRunLoopObserverRef observer, CFRunLoopActivity act, void *info) &#123;    MainThreadMonitor *monitor = (__bridge MainThreadMonitor *)info;    monitor-&gt;activity = act;    dispatch_semaphore_signal(monitor-&gt;semaphore);&#125;// 打印主线程堆栈- (void)logMainThreadStack &#123;    thread_act_t thread = mach_thread_self();    NSString *stack = [self getStackForThread:mach_thread_self()];    NSLog(@&quot;卡顿堆栈：%@&quot;, stack);&#125;// 获取堆栈（可用 PLCrashReporter 或自己解析）- (NSString *)getStackForThread:(thread_t)thread &#123;    void *callstack[128];    int frames = backtrace(callstack, 128);    char **strs = backtrace_symbols(callstack, frames);    NSMutableString *stack = [NSMutableString string];    for (int i = 0; i &lt; frames; i++) &#123;        [stack appendFormat:@&quot;%s&quot;, strs[i]];    &#125;    free(strs);    return stack;&#125;- (void)stopMonitoring &#123;    if (!isMonitoring) return;    isMonitoring = NO;    if (observer) &#123;        CFRunLoopRemoveObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);        CFRelease(observer);        observer = NULL;    &#125;&#125;@end\n\n📌 使用方式MainThreadMonitor *monitor = [[MainThreadMonitor alloc] init];[monitor startMonitoring];\n\n🚀 补充优化建议\n上传卡顿信息 到服务端分析（包括时间戳、堆栈、设备信息等）；\n使用 PLCrashReporter 捕获完整堆栈；\n避免误报（可设定 N 次连续卡顿后才触发上报）；\n添加 FPS 监控作为辅助参考。\n\niOS 完整堆栈捕获实现原理🔍 栈帧捕获的原理概述1. 栈帧结构（以 x86_64 为例）每次函数调用时，系统会在栈中保存：\n\n返回地址（return address）\n上一个函数的栈帧指针（frame pointer）\n函数参数和局部变量\n\n因此，通过 当前帧的 frame pointer（rbp），可以回溯前一个函数的帧，形成调用链。\n当前栈帧：| return address || previous RBP   |  &lt;---- 当前 RBP 指向这里| arguments      || local vars     |\n\n不断遍历 RBP，就可以得到一连串的调用路径。\n\n2. backtrace() 与 backtrace_symbols()苹果系统提供了 glibc 的接口，能获取当前线程的调用栈信息：\nvoid *callstack[128];int frames = backtrace(callstack, 128);  // 获得 return address 数组char **strs = backtrace_symbols(callstack, frames); // 转为符号化字符串\n\n\nbacktrace()：返回指针数组，每个指针是一个返回地址（PC 值）\nbacktrace_symbols()：将地址解析为函数名（带符号信息）\n\n\n✅ 适用于当前线程❌ 无法捕获其他线程的堆栈\n\n\n🧠 捕获其他线程堆栈的高级做法1. 使用 Mach 线程 API 获取上下文macOS 和 iOS 的线程由 Mach 线程驱动，可使用如下方式获取任意线程的状态：\nthread_act_t thread = mach_thread_self(); // 或主线程 mach_port_ARM_THREAD_STATE64 state;mach_msg_type_number_t count = _ARM_THREAD_STATE64_COUNT;thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&amp;state, &amp;count);\n\n\n可拿到寄存器信息（如 pc, lr, fp）\n从 fp（frame pointer）开始，手动解析内存获取调用链\n\n2. 使用第三方库封装（推荐）\nPLCrashReporter\nKSCrash\n\n它们在崩溃或卡顿时：\n\n挂起线程\n读取线程上下文寄存器（如 pc、sp、fp）\n手动回溯调用栈\n进行符号化输出\n\n\n⚠️ 注意事项\n手动读取线程寄存器有风险（需挂起线程，防止栈变化）\n对于优化或内联函数，可能无法获取完整信息\n系统函数符号化依赖 dSYM 或符号表\n\n\n✅ 各方案对比\n\n\n方法\n优势\n局限\n\n\n\nbacktrace\n简单易用，当前线程调用栈\n仅当前线程，信息不完整\n\n\nMach API + 寄存器解析\n可捕获任意线程堆栈\n实现复杂，需挂起线程\n\n\nPLCrashReporter\n稳定封装，支持崩溃&#x2F;卡顿&#x2F;符号化\n增加依赖包，大小略大\n\n\n\n📌 推荐实践\n异常或卡顿发生时暂停主线程 → 获取寄存器状态 → 回溯调用链\n使用第三方库如 PLCrashReporter 进行安全封装\n搭配符号表（.dSYM）进行符号化，以便远程分析\n\n","categories":["基础"]},{"title":"Day8-验证回文串","url":"/2025/05/06/Day8-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"🔗 LeetCode 125 - Valid Palindrome\n📌 题目描述给定一个字符串，判断它是否是回文，只考虑字母和数字字符，可以忽略字母的大小写。\n示例：\n输入: &quot;A man, a plan, a canal: Panama&quot;输出: true输入: &quot;race a car&quot;输出: false\n\n\n💡 解题思路\n使用双指针法；\n\n从头尾两端遍历，只保留字母和数字，统一转成小写后比较；\n\n忽略其他符号。\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n\n✅ JavaScript 实现var isPalindrome = function(s) &#123;    let left = 0, right = s.length - 1;    while (left &lt; right) &#123;        while (left &lt; right &amp;&amp; !isAlphaNum(s[left])) left++;        while (left &lt; right &amp;&amp; !isAlphaNum(s[right])) right--;        if (s[left].toLowerCase() !== s[right].toLowerCase()) return false;        left++;        right--;    &#125;    return true;&#125;;function isAlphaNum(c) &#123;    return /^[a-zA-Z0-9]$/.test(c);&#125;\n\n\n🧠 思考拓展\n如何处理 Unicode 字符（如中文、Emoji）？\n如果需要考虑回文子串，如何优化？\n\n\n","categories":["算法"]},{"title":"Day9-只出现一次的数字","url":"/2025/05/07/Day9-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","content":"🔗 LeetCode 136 - Single Number\n📌 题目描述给定一个非空整数数组 nums，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n你必须在线性时间复杂度内完成算法，并且不能使用额外空间。\n示例：\n输入: [4,1,2,1,2]输出: 4\n\n\n💡 解题思路\n异或运算的关键特性：\na ^ a = 0\na ^ 0 = a\n\n\n所以将所有数字进行异或操作，成对的数字会抵消为 0，剩下的就是那个只出现了一次的数字。\n\n\n✅ JavaScript 实现var singleNumber = function(nums) &#123;    let result = 0;    for (let num of nums) &#123;        result ^= num;    &#125;    return result;&#125;;\n\n\n🟣 Swift 实现func singleNumber(_ nums: [Int]) -&gt; Int &#123;    var result = 0    for num in nums &#123;        result ^= num    &#125;    return result&#125;\n\n\n🧠 思考拓展\n如果一个元素出现一次，其余出现三次，该怎么做？\n如果有两个只出现一次的数字，其余都出现两次呢？\n如何用位运算统计任意次数的重复？\n\n","categories":["算法"]},{"title":"Mach-O","url":"/2025/05/16/MachO/","content":"Mach-O 是 macOS 和 iOS 平台上使用的可执行文件格式。\nMach-O 文件格式用于 macOS 和 iOS 中的可执行文件、动态库和核心转储等。Mach-O 文件包含多个部分，每个部分都具有特定的结构和功能。\nMach-O 文件头Mach-O 文件的开始部分是文件头（MachHeader），它包含了文件的基本信息。文件头分为两种类型：32位（mach_header）和 64位（mach_header_64）。下面是一个 64 位 Mach-O 文件头的结构示例：\nstruct mach_header_64 &#123;    uint32_t    magic;      // 文件的魔数，标识 Mach-O 文件格式    cpu_type_t  cputype;    // 架构类型    cpu_subtype_t cpusubtype; // 架构子类型    uint32_t    filetype;   // 文件类型（例如，可执行文件、动态库）    uint32_t    ncmds;      // 命令数    uint32_t    sizeofcmds; // 命令总大小    uint32_t    flags;      // 标志    uint32_t    reserved;   // 保留字段&#125;;\n\nmagic: 用于识别文件格式的标识符，如 MH_MAGIC_64。\ncputype 和 cpusubtype: 描述 CPU 架构。\nfiletype: 文件类型，如 MH_EXECUTE（可执行文件）。\nncmds 和 sizeofcmds: 描述了文件中的加载命令数量和大小。\n\n以下示例展示了如何使用 C 语言读取 Mach-O 文件的头部信息：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;mach-o/loader.h&gt;void printMachHeader(const char *filename) &#123;    FILE *file = fopen(filename, &quot;rb&quot;);    if (!file) &#123;        perror(&quot;fopen&quot;);        return;    &#125;    struct mach_header_64 header;    fread(&amp;header, sizeof(header), 1, file);    printf(&quot;Magic: 0x%x\\n&quot;, header.magic);    printf(&quot;CPU Type: 0x%x\\n&quot;, header.cputype);    printf(&quot;CPU Subtype: 0x%x\\n&quot;, header.cpusubtype);    printf(&quot;File Type: 0x%x\\n&quot;, header.filetype);    printf(&quot;Number of Commands: %u\\n&quot;, header.ncmds);    printf(&quot;Size of Commands: %u\\n&quot;, header.sizeofcmds);    printf(&quot;Flags: 0x%x\\n&quot;, header.flags);    fclose(file);&#125;int main() &#123;    printMachHeader(&quot;example.macho&quot;);    return 0;&#125;\n加载命令Mach-O 文件的加载命令（load_command）用于描述文件的各个部分，例如段（segment）和节（section）。每个加载命令都有一个类型字段（cmd），表示命令的具体类型。下面是一个 segment_command_64 的结构示例：\nstruct segment_command_64 &#123;    uint32_t    cmd;        // 命令类型，指示这是一个段命令    uint32_t    cmdsize;    // 命令大小    char        segname[16];// 段名称    uint64_t    vmaddr;     // 段在内存中的地址    uint64_t    vmsize;     // 段在内存中的大小    uint64_t    fileoff;    // 段在文件中的偏移    uint64_t    filesize;   // 段在文件中的大小    uint32_t    maxprot;    // 最大保护属性    uint32_t    initprot;   // 初始化保护属性    uint32_t    nsects;     // 段中节的数量    uint32_t    flags;      // 段标志&#125;;\n\ncmd: 加载命令的类型，例如 LC_SEGMENT_64。\nsegname: 段的名称，如 __TEXT 或 __DATA。\nvmaddr 和 vmsize: 描述段在内存中的位置和大小。\nfileoff 和 filesize: 描述段在文件中的位置和大小。\n\n节（Section）每个段可以包含多个节（section）。节是 Mach-O 文件中的基本数据单位，包含实际的数据或代码。下面是一个 section_64 的结构示例：\nstruct section_64 &#123;    char        sectname[16]; // 节名称    char        segname[16];  // 段名称    uint32_t    addr;         // 节的地址    uint32_t    size;         // 节的大小    uint32_t    offset;       // 节在文件中的偏移    uint32_t    align;        // 对齐    uint32_t    reloff;       // 重定位信息的偏移    uint32_t    nreloc;       // 重定位条目数量    uint32_t    flags;        // 节标志    uint32_t    reserved1;    // 保留字段    uint32_t    reserved2;    // 保留字段    uint32_t    reserved3;    // 保留字段&#125;;\n\nsectname 和 segname: 描述节和段的名称。\naddr 和 size: 节在内存中的地址和大小。\noffset: 节在文件中的偏移。\nflags: 描述节的属性，如是否可写、可执行等。\n\nMach-O 文件可能包含重定位信息，用于在加载时调整代码或数据的地址。重定位信息存储在 segment_command 的 reloff 和 nreloc 字段中。\nMachOView 3.0版本MachOView 是一个开源项目，用于解析和可视化 Mach-O 文件，这是 macOS 和 iOS 系统上的二进制文件格式。这个工具可以帮助开发者查看和分析 Mach-O 文件的结构和内容。\nMachOKitMachOKit 是一个用 Swift 编写的开源项目，用于解析和操作 Mach-O 文件格式。它能够利用 Swift 的类型安全和内存管理特性。例如，Swift 的类型系统可以用于定义 Mach-O 文件的各种结构。\nMachOKit 解析 Mach-O 文件头部。\nimport Foundationstruct MachOHeader &#123;    let magic: UInt32    let cputype: UInt32    let cpusubtype: UInt32    let filetype: UInt32    let ncmds: UInt32    let sizeofcmds: UInt32    let flags: UInt32&#125;func parseMachOHeader(data: Data) -&gt; MachOHeader? &#123;    guard data.count &gt;= 28 else &#123; return nil &#125;    let magic = data.withUnsafeBytes &#123; $0.load(as: UInt32.self) &#125;    let cputype = data.withUnsafeBytes &#123; $0.load(fromByteOffset: 4, as: UInt32.self) &#125;    let cpusubtype = data.withUnsafeBytes &#123; $0.load(fromByteOffset: 8, as: UInt32.self) &#125;    let filetype = data.withUnsafeBytes &#123; $0.load(fromByteOffset: 12, as: UInt32.self) &#125;    let ncmds = data.withUnsafeBytes &#123; $0.load(fromByteOffset: 16, as: UInt32.self) &#125;    let sizeofcmds = data.withUnsafeBytes &#123; $0.load(fromByteOffset: 20, as: UInt32.self) &#125;    let flags = data.withUnsafeBytes &#123; $0.load(fromByteOffset: 24, as: UInt32.self) &#125;        return MachOHeader(magic: magic, cputype: cputype, cpusubtype: cpusubtype, filetype: filetype, ncmds: ncmds, sizeofcmds: sizeofcmds, flags: flags)&#125;\nMachOKit 使用 Swift 的文件系统 API 来读取 Mach-O 文件的二进制数据。这包括从文件中读取数据并将其解析成 Mach-O 格式的结构体。\nfunc readMachOFile(atPath path: String) -&gt; Data? &#123;    return FileManager.default.contents(atPath: path)&#125;\n使用 Swift 的结构体和类来映射 Mach-O 文件的各种数据结构。这些数据结构包括 Mach-O 头部、加载命令、段和节等。\nstruct MachOLoadCommand &#123;    let cmd: UInt32    let cmdsize: UInt32&#125;func parseLoadCommand(data: Data, offset: Int) -&gt; MachOLoadCommand? &#123;    guard data.count &gt;= offset + 8 else &#123; return nil &#125;    let cmd = data.withUnsafeBytes &#123; $0.load(fromByteOffset: offset, as: UInt32.self) &#125;    let cmdsize = data.withUnsafeBytes &#123; $0.load(fromByteOffset: offset + 4, as: UInt32.self) &#125;        return MachOLoadCommand(cmd: cmd, cmdsize: cmdsize)&#125;\nMachOKit 利用 Swift 的类型安全和内存管理特性，结合对 Mach-O 文件格式的深入理解，来实现对 Mach-O 文件的解析。通过读取二进制数据、映射数据结构、内存映射和错误处理，它能够有效地解析 Mach-O 文件并提供相关信息。\n","categories":["性能优化"]},{"title":"RunLoop","url":"/2025/05/09/RunLoop/","content":"基本概念在iOS和macOS中，RunLoop是一个循环机制，用于管理线程中的事件处理。当一个线程启动后，系统会为其创建一个RunLoop，它会不断地运行、检查和处理事件。如果没有事件需要处理，RunLoop会让线程进入休眠状态，从而节省系统资源。\n获取当前线程的RunLoop\nNSRunLoop *runLoop = [NSRunLoop currentRunLoop]; \n这段代码获取了当前线程的RunLoop实例。对于主线程，这是系统自动创建的；对于后台线程，通常需要手动启动RunLoop。\nRunLoop 的主要任务是：\n\n处理事件和消息： 处理来自各种输入源的事件，例如触摸事件、网络事件等。\n调度定时任务： 处理定时器触发的任务。\n保持线程活跃： 确保线程在有任务时不会空闲而关闭。\n\n运行模式RunLoop可以在多种模式下运行，最常用的是kCFRunLoopDefaultMode（默认模式）和UITrackingRunLoopMode（UI跟踪模式）。RunLoop在不同模式下处理不同类型的事件。\n在不同模式下添加Timer\nNSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerFired:) userInfo:nil repeats:YES];// 将Timer添加到RunLoop的默认模式中[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];// 将Timer添加到RunLoop的UI跟踪模式中[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];\n上面代码展示了如何在RunLoop的不同模式下添加Timer。这意味着Timer在这两种模式下都会被执行。\n事件源RunLoop通过事件源（Source）来获取并处理事件。事件源主要分为输入源（Input Source）和定时源（Timer Source）。输入源主要用于处理异步事件，如用户输入、网络请求等；定时源则用于处理定时事件，如NSTimer。\n自定义RunLoop输入源\nCFRunLoopSourceContext context = &#123;0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &amp;myRunLoopSourcePerformRoutine&#125;;CFRunLoopSourceRef runLoopSource = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context);CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, kCFRunLoopDefaultMode);\n在这个例子中，我们创建了一个自定义的RunLoop输入源，并将其添加到默认模式的RunLoop中。自定义的事件源允许我们处理自定义的事件。\n事件处理在RunLoop的每一次循环中，都会处理事件队列中的事件。RunLoop通过检查事件源来决定是否有需要处理的事件。如果有，它会调用对应的处理函数来处理该事件；如果没有，则进入休眠状态。\n处理RunLoop事件的示例代码\nvoid myRunLoopSourcePerformRoutine(void *info) &#123;    // 处理自定义事件的逻辑    NSLog(@&quot;RunLoop事件已处理&quot;);&#125;// 自定义事件源上下文CFRunLoopSourceContext context = &#123;0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &amp;myRunLoopSourcePerformRoutine&#125;;CFRunLoopSourceRef runLoopSource = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context);// 将事件源添加到RunLoopCFRunLoopAddSource(CFRunLoopGetCurrent(), runLoopSource, kCFRunLoopDefaultMode);\n在这段代码中，myRunLoopSourcePerformRoutine函数用于处理RunLoop事件源中的事件。当有事件需要处理时，RunLoop会调用这个函数。\n线程管理中的应用在后台线程中，RunLoop通常不会自动启动。如果我们希望一个后台线程持续运行，并且能够响应事件，就需要手动启动RunLoop。\n在后台线程中启动RunLoop\n- (void)startBackgroundTask &#123;    NSThread *backgroundThread = [[NSThread alloc] initWithTarget:self selector:@selector(runBackgroundRunLoop) object:nil];    [backgroundThread start];&#125;- (void)runBackgroundRunLoop &#123;    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];    [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];    [runLoop run];&#125;``上面代码创建了一个后台线程，并在其中启动了RunLoop。通过添加一个NSMachPort对象，RunLoop能够保持活跃，并处理来自其他线程的事件。## 常见使用场景RunLoop在iOS开发中有广泛的应用场景，如处理长时间运行的任务、管理定时器和网络请求、实现复杂的UI响应逻辑等。例如，在后台下载任务中，RunLoop可以帮助保持线程的活跃，以确保下载过程不会中断。创建一个 RunLoop 并添加一个定时器来保持线程的活动状态：```objc#import &lt;Foundation/Foundation.h&gt;void timerCallback(CFRunLoopTimerRef timer, void *info) &#123;    NSLog(@&quot;Timer fired!&quot;);&#125;int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        // 创建一个新的 RunLoop        CFRunLoopRef runLoop = CFRunLoopGetCurrent(); // 通过 `CFRunLoopGetCurrent()` 获取当前线程的 `RunLoop` 实例。                // 创建一个定时器        CFRunLoopTimerContext context = &#123;0&#125;;        // 使用 `CFRunLoopTimerCreate` 创建一个定时器，设置它在 1 秒后触发，并每秒重复触发一次。        CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault,                                                         CFAbsoluteTimeGetCurrent() + 1.0,                                                         1.0,                                                         0,                                                         0,                                                         timerCallback,                                                         &amp;context);                // 通过 `CFRunLoopAddTimer` 将定时器添加到 `RunLoop` 中，使其能够在 RunLoop 中运行。        CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);                // 使用 `CFRunLoopRun` 启动 `RunLoop`。这将使线程进入等待状态，直到事件触发（如定时器触发）。        NSLog(@&quot;RunLoop started...&quot;);        CFRunLoopRun();                // 在 RunLoop 停止后移除定时器并释放资源。        CFRunLoopRemoveTimer(runLoop, timer, kCFRunLoopCommonModes);        CFRelease(timer);    &#125;    return 0;&#125;\nRunLoop 源码结构RunLoop 的主要组件有输入源（Input Sources）、运行模式（RunLoop Modes）和任务队列（Tasks Queue）。\n输入源包括用于处理来自 Mach 消息的事件的端口。用于处理定时器事件的定时器。RunLoop 支持不同的运行模式，每个模式可以处理不同的事件类型。例如，NSDefaultRunLoopMode 和 UITrackingRunLoopMode。任务队列存储待处理的任务，如定时器、事件等。\nRunLoop 源码可以在 iOS 的底层系统库中找到。RunLoop 的实现涉及多个组件和文件。以下是一些关键部分的解析：\n在 Core Foundation 框架中，CFRunLoop 是 RunLoop 的核心实现。以下是 CFRunLoop 的定义和主要功能：\n// CFRunLoop.htypedef struct __CFRunLoop * CFRunLoopRef;// CFRunLoop.cstruct __CFRunLoop &#123;    CFRuntimeBase _base;    CFMutableSetRef _modes;    CFRunLoopModeRef _currentMode;    CFMutableSetRef _sources0;    CFMutableSetRef _sources1;    CFMutableSetRef _observers;    CFMutableSetRef _timers;    // 其他成员变量&#125;;\n\n_modes： 存储 RunLoop 的运行模式。\n_currentMode： 当前的运行模式。\n_sources0 和 _sources1： 存储不同类型的输入源。\n_observers： 存储观察者，处理特定的事件。\n_timers： 存储定时器，处理定时任务。\n\n主要函数：\n\nCFRunLoopRun： 启动 RunLoop，并进入主循环。\n\nvoid CFRunLoopRun(void) &#123;    // 省略其他代码    while (!loopShouldExit) &#123;        // 处理事件和任务        CFRunLoopMode mode = CFRunLoopCopyCurrentMode();        CFRunLoopPerformTasksForMode(mode);        // 检查是否需要退出    &#125;&#125;\n\nCFRunLoopPerformTasksForMode： 执行当前模式下的任务。\n\nvoid CFRunLoopPerformTasksForMode(CFRunLoopMode mode) &#123;    // 处理输入源    CFRunLoopSourcePerformTasks(mode-&gt;_sources);    // 处理定时器    CFRunLoopTimerPerformTasks(mode-&gt;_timers);    // 处理观察者    CFRunLoopObserverPerformTasks(mode-&gt;_observers);&#125;\n","categories":["性能优化"],"tags":["性能优化","卡顿监控"]},{"title":"Hello World","url":"/2025/04/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Swift 语法","url":"/2025/05/07/Swift-%E8%AF%AD%E6%B3%95/","content":"语法基础变量变量是可变的，使用 var 修饰，常量是不可变的，使用 let 修饰。类、结构体和枚举里的变量是属性。\nvar v1:String = &quot;hi&quot; // 标注类型var v2 = &quot;类型推导&quot;let l1 = &quot;标题&quot; // 常量class a &#123;    let p1 = 3    var p2: Int &#123;        p1 * 3    &#125;&#125;\n属性没有 set 可以省略 get，如果有 set 需加 get。变量设置前通过 willSet 访问到，变量设置后通过 didSet 访问。\n打印控制台打印值\nprint(&quot;hi&quot;)let i = 14print(i)print(&quot;9月\\(i)是小柠檬的生日&quot;)for i in 1...3&#123;    print(i)&#125;// output:// 1// 2// 3// 使用terminator使循环打印更整洁for i in 1...3 &#123;    print(&quot;\\(i) &quot;, terminator: &quot;&quot;)&#125;// output:// 1 2 3\n注释// 单行注释/*多行注释第一行。多行注释第二行。*/ // MARK: 会在 minimap 上展示// TODO: 待做// FIXME: 待修复\n!?可选可能会是 nil 的变量就是可选变量。当变量为 nil 通过??操作符可以提供一个默认值。\nvar o: Int? = nillet i = o ?? 0\nSE-0345 if let shorthand for shadowing an existing optional variable 引入的新语法，用于 unwrapping optinal。\nlet s1: String? = &quot;hey&quot;let s2: String? = &quot;u&quot;if let s1 &#123;    print(s1)&#125;guard let s1, let s2 else &#123; return &#125;print(s1 + &quot; &quot; + s2)\n闭包闭包也可以叫做 lambda，是匿名函数，对应 OC 的 block。\nlet a1 = [1,3,2].sorted(by: &#123; (l: Int, r: Int) -&gt; Bool in    return l &lt; r&#125;)// 如果闭包是唯一的参数并在表达式最后可以使用结尾闭包语法，写法简化为let a2 = [1,3,2].sorted &#123; (l: Int, r: Int) -&gt; Bool in    return l &lt; r&#125;// 已知类型可以省略let a3 = [1,3,2].sorted &#123; l, r in    return l &lt; r&#125;// 通过位置来使用闭包的参数，最后简化如下：let a4 = [1,3,2].sorted &#123; $0 &lt; $1 &#125;\n函数也是闭包的一种，函数的参数也可以是闭包。@escaping 表示逃逸闭包，逃逸闭包是可以在函数返回之后继续调用的。@autoclosure 表示自动闭包，可以用来省略花括号。\nSE-0326 提高了 Swift 对闭包使用参数和类型推断的能力。如下代码：\nlet a = [1,2,3]let r = a.map &#123; i in    if i &gt;= 2 &#123;        return &quot;\\(i) 大于等于2&quot;    &#125; else &#123;        return &quot;\\(i) 小于2&quot;    &#125;&#125;print(r)\n函数函数可以作为另一个函数的参数，也可以作为另一个函数的返回。函数是特殊的闭包，在类、结构体和枚举中是方法。\n// 为参数设置默认值func f1(p: String = &quot;p&quot;) -&gt; String &#123;    &quot;p is \\(p)&quot;&#125;// 函数作为参数func f2(fn: (String) -&gt; String, p: String) -&gt; String &#123;    return fn(p)&#125;print(f2(fn:f1, p: &quot;d&quot;)) // p is d// 函数作为返回值func f3(p: String) -&gt; (String) -&gt; String &#123;    return f1&#125;print(f3(p: &quot;yes&quot;)(&quot;no&quot;)) // p is no\n函数可以返回多个值，函数是可以嵌套的，也就是函数里内可以定义函数，函数内定义的函数可以访问自己作用域外函数内的变量。inout 表示的是输入输出参数，函数可以在函数内改变输入输出参数。defer 标识的代码块会在函数返回之前执行。\n函数在 Swift 5.4 时开始有了使用多个变量参数的能力，使用方法如下：\nfunc f4(s: String..., i: Int...) &#123;    print(s)    print(i)&#125;f4(s: &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, i: 1, 2, 3)/// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]/// [1, 2, 3]\n嵌套函数可以重载，嵌套函数可以在声明函数之前调用他。\nfunc f5() &#123;    nf5()    func nf5() &#123;        print(&quot;this is nested function&quot;)    &#125;&#125;f5() // this is nested function\n访问控制在 Xcode 里的 target 就是模块，使用 import 可导入模块。模块内包含源文件，每个源文件里可以有多个类、结构体、枚举和函数等多种类型。访问级别可以通过一些关键字描述，分为如下几种：\n\nopen：在模块外可以调用和继承。\npublic：在模块外可调用不可继承，open 只适用类和类成员。\ninternal：默认级别，模块内可跨源文件调用，模块外不可调用。\nfileprivate：只能在源文件内访问。\nprivate：只能在所在的作用域内访问。\n\n重写继承类的成员，可以设置成员比父类的这个成员更高的访问级别。Setter 的级别可以低于对应的 Getter 的级别，比如设置 Setter 访问级别为 private，可以在属性使用 private(set) 来修饰。\nRegex标准库多了个 Regex 类型，Regex 语法与 Perl、Python、Ruby、Java、NSRegularExpression 和许多其他语言兼容。可以用 let regex &#x3D; try! Regex(“a[bc]+”) 或 let regex &#x3D; &#x2F;a[bc]+&#x2F; 写法来使用。SE-0350 Regex Type and Overview 引入 Regex 类型。SE-0351 Regex builder DSL 使用 result builder 来构建正则表达式的 DSL。SE-0354 Regex Literals 简化的正则表达式。SE-0357 Regex-powered string processing algorithms 提案里有基于正则表达式的新字符串处理算法。\nRegexBuilder 文档\nsession Meet Swift Regex 、Swift Regex: Beyond the basics\nRegex 示例代码如下：\nlet s1 = &quot;I am not a good painter&quot;print(s1.ranges(of: /good/))do &#123;    let regGood = try Regex(&quot;[a-z]ood&quot;)    print(s1.replacing(regGood, with: &quot;bad&quot;))&#125; catch &#123;    print(error)&#125;print(s1.trimmingPrefix(/i am /.ignoresCase()))let reg1 = /(.+?) read (\\d+) books./let reg2 = /(?&lt;name&gt;.+?) read (?&lt;books&gt;\\d+) books./let s2 = &quot;Jack read 3 books.&quot;do &#123;    if let r1 = try reg1.wholeMatch(in: s2) &#123;        print(r1.1)        print(r1.2)    &#125;    if let r2 = try reg2.wholeMatch(in: s2) &#123;        print(&quot;name:&quot; + r2.name)        print(&quot;books:&quot; + r2.books)    &#125;&#125; catch &#123;    print(error)&#125;\n使用 regex builders 的官方示例：\n// Text to parse:// CREDIT  03/02/2022  Payroll from employer     $200.23// CREDIT  03/03/2022  Suspect A           $2,000,000.00// DEBIT   03/03/2022  Ted&#x27;s Pet Rock Sanctuary    $2,000,000.00// DEBIT   03/05/2022  Doug&#x27;s Dugout Dogs      $33.27import RegexBuilderlet fieldSeparator = /\\s&#123;2,&#125;|\\t/let transactionMatcher = Regex &#123;  /CREDIT|DEBIT/  fieldSeparator  One(.date(.numeric, locale: Locale(identifier: &quot;en_US&quot;), timeZone: .gmt)) // 👈🏻 we define which data locale/timezone we want to use  fieldSeparator  OneOrMore &#123;    NegativeLookahead &#123; fieldSeparator &#125; // 👈🏻 we stop as soon as we see one field separator    CharacterClass.any  &#125;  fieldSeparator  One(.localizedCurrency(code: &quot;USD&quot;).locale(Locale(identifier: &quot;en_US&quot;)))&#125;\n在正则表达式中捕获数据，使用 Capture：\nlet fieldSeparator = /\\s&#123;2,&#125;|\\t/let transactionMatcher = Regex &#123;  Capture &#123; /CREDIT|DEBIT/ &#125; // 👈🏻  fieldSeparator  Capture &#123; One(.date(.numeric, locale: Locale(identifier: &quot;en_US&quot;), timeZone: .gmt)) &#125; // 👈🏻  fieldSeparator  Capture &#123; // 👈🏻    OneOrMore &#123;      NegativeLookahead &#123; fieldSeparator &#125;      CharacterClass.any    &#125;  &#125;  fieldSeparator  Capture &#123; One(.localizedCurrency(code: &quot;USD&quot;).locale(Locale(identifier: &quot;en_US&quot;))) &#125; // 👈🏻&#125;// transactionMatcher: Regex&lt;(Substring, Substring, Date, Substring, Decimal)&gt;\n基础类型数字数字的类型有 Int、Float 和 Double\n// Intlet i1 = 100let i2 = 22print(i1 / i2) // 向下取整得 4// Floatlet f1: Float = 100.0let f2: Float = 22.0print(f1 / f2) // 4.5454545let f3: Float16 = 5.0 // macOS 还不能用let f4: Float32 = 5.0let f5: Float64 = 5.0let f6: Float80 = 5.0print(f4, f5, f6) // 5.0 5.0 5.0// Doublelet d1: Double = 100.0let d2: Double = 22.0print(d1 / d2) // 4.545454545454546// 字面量print(Int(0b10101)) // 0b 开头是二进制 print(Int(0x00afff)) // 0x 开头是十六进制print(2.5e4) // 2.5x10^4 十进制用 eprint(0xAp2) // 10*2^2  十六进制用 pprint(2_000_000) // 2000000// isMultiple(of:) 方法检查一个数字是否是另一个数字的倍数let i3 = 36print(i3.isMultiple(of: 9)) // true\n处理数字有 floor、ceil、round。floor 是向下取整，只取整数部分；cell 是向上取整，只要有不为零的小数，整数就加1;round 是四舍五入。\n布尔数布尔数有 true 和 false 两种值，还有一个能够切换这两个值的 toggle 方法。\nvar b = falseb.toggle() // trueb.toggle() // false\n字符串let s1 = &quot;Hi! This is a string. Cool?&quot;/// 转义符 \\n 表示换行。/// 其它转义字符有 \\0 空字符)、\\t 水平制表符 、\\n 换行符、\\r 回车符let s2 = &quot;Hi!\\nThis is a string. Cool?&quot;// 多行let s3 = &quot;&quot;&quot;Hi!This is a string.Cool?&quot;&quot;&quot;// 长度print(s3.count)print(s3.isEmpty)// 拼接print(s3 + &quot;\\nSure!&quot;)// 字符串中插入变量let i = 1print(&quot;Today is good day, double \\(i)\\(i)!&quot;)/// 遍历字符串/// 输出：/// o/// n/// efor c in &quot;one&quot; &#123;    print(c)&#125;// 查找print(s3.lowercased().contains(&quot;cool&quot;)) // true// 替换let s4 = &quot;one is two&quot;let newS4 = s4.replacingOccurrences(of: &quot;two&quot;, with: &quot;one&quot;)print(newS4)// 删除空格和换行let s5 = &quot; Simple line. \\n\\n  &quot;print(s5.trimmingCharacters(in: .whitespacesAndNewlines))// 切割成数组let s6 = &quot;one/two/three&quot;let a1 = s6.components(separatedBy: &quot;/&quot;) // 继承自 NSString 的接口print(a1) // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]let a2 = s6.split(separator: &quot;/&quot;)print(a2) // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] 属于切片，性能较 components 更好// 判断是否是某种类型let c1: Character = &quot;🤔&quot;print(c1.isASCII) // falseprint(c1.isSymbol) // trueprint(c1.isLetter) // falseprint(c1.isNumber) // falseprint(c1.isUppercase) // false// 字符串和 Data 互转let data = Data(&quot;hi&quot;.utf8)let s7 = String(decoding: data, as: UTF8.self)print(s7) // hi// 字符串可以当作集合来用。let revered = s7.reversed()print(String(revered))\nUnicode、Character 和 SubString 等内容参见官方字符串文档：Strings and Characters — The Swift Programming Language (Swift 5.1)\n字符串字面符号可以参看《String literals in Swift》。\n原始字符串\n// 原始字符串在字符串前加上一个或多个#符号。里面的双引号和转义符号将不再起作用了，如果想让转义符起作用，需要在转义符后面加上#符号。let s8 = #&quot;\\(s7)\\#(s7) &quot;one&quot; and &quot;two&quot;\\n. \\#nThe second line.&quot;#print(s8)/// \\(s7)hi &quot;one&quot; and &quot;two&quot;\\n./// The second line.// 原始字符串在正则使用效果更佳，反斜杠更少了。let s9 = &quot;\\\\\\\\[A-Z]+[A-Za-z]+\\\\.[a-z]+&quot;let s10 = #&quot;\\\\[A-Z]+[A-Za-z]+\\.[a-z]+&quot;#print(s9) // \\\\[A-Z]+[A-Za-z]+\\.[a-z]+print(s10) // \\\\[A-Z]+[A-Za-z]+\\.[a-z]+\nSwift5.7 String Index 大升级 String Index Overhaul\n枚举Swift的枚举有类的一些特性，比如计算属性、实例方法、扩展、遵循协议等等。\nenum E1:String, CaseIterable &#123;    case e1, e2 = &quot;12&quot;&#125;// 关联值enum E2 &#123;    case e1([String])    case e2(Int)&#125;let e1 = E2.e1([&quot;one&quot;,&quot;two&quot;])let e2 = E2.e2(3)switch e1 &#123;case .e1(let array):    print(array)case .e2(let int):    print(int)&#125;print(e2)// 原始值print(E1.e1.rawValue)// 遵循 CaseIterable 协议可迭代for ie in E1.allCases &#123;    print(&quot;show \\(ie)&quot;)&#125;// 递归枚举enum RE &#123;    case v(String)    indirect case node(l:RE, r:RE)&#125;let lNode = RE.v(&quot;left&quot;)let rNode = RE.v(&quot;right&quot;)let pNode = RE.node(l: lNode, r: rNode)switch pNode &#123;case .v(let string):    print(string)case .node(let l, let r):    print(l,r)    switch l &#123;    case .v(let string):        print(string)    case .node(let l, let r):        print(l, r)    &#125;    switch r &#123;    case .v(let string):        print(string)    case .node(let l, let r):        print(l, r)    &#125;&#125;\n@unknown 用来区分固定的枚举和可能改变的枚举的能力。@unknown 用于防止未来新增枚举属性会进行提醒提示完善每个 case 的处理。\n// @unknownenum E3 &#123;    case e1, e2, e3&#125;func fe1(e: E3) &#123;    switch e &#123;    case .e1:        print(&quot;e1 ok&quot;)    case .e2:        print(&quot;e2 ok&quot;)    case .e3:        print(&quot;e3 ok&quot;)    @unknown default:        print(&quot;not ok&quot;)    &#125;&#125;\n符合 Comparable 协议的枚举可以进行比较。\n// Comparable 枚举比较enum E4: Comparable &#123;    case e1, e2    case e3(i: Int)    case e4&#125;let e3 = E4.e4let e4 = E4.e3(i: 3)let e5 = E4.e3(i: 2)let e6 = E4.e1print(e3 &gt; e4) // truelet a1 = [e3, e4, e5, e6]let a2 = a1.sorted()for i in a2 &#123;    print(i.self)&#125;/// e1/// e3(i: 2)/// e3(i: 3)/// e4\n元组元组里的值类型可以是不同的。元组可以看成是匿名的结构体。\nlet t1 = (p1: 1, p2: &quot;two&quot;, p3: [1,2,3])print(t1.p1)print(t1.p3)// 类型推导let t2 = (1, &quot;two&quot;, [1,2,3])// 通过下标访问print(t2.1) // two// 分解元组let (dp1, dp2, _) = t2print(dp1)print(dp2)\n泛型和协议泛型可以减少重复代码，是一种抽象的表达方式。where 关键字可以对泛型做约束。\nfunc fn&lt;T&gt;(p: T) -&gt; [T] &#123;    var r = [T]()    r.append(p)    return r&#125;print(fn(p: &quot;one&quot;))// 结构体struct S1&lt;T&gt; &#123;    var arr = [T]()    mutating func add(_ p: T) &#123;        arr.append(p)    &#125;&#125;var s1 = S1(arr: [&quot;zero&quot;])s1.add(&quot;one&quot;)s1.add(&quot;two&quot;)print(s1.arr) // [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]\n关联类型\nprotocol pc &#123;    associatedtype T    mutating func add(_ p: T)&#125;struct S2: pc &#123;    typealias T = String // 类型推导，可省略    var strs = [String]()    mutating func add(_ p: String) &#123;        strs.append(p)    &#125;&#125;\n泛型适用于嵌套类型\nstruct S3&lt;T&gt; &#123;    struct S4 &#123;        var p: T    &#125;        var p1: T    var p2: S4&#125;let s2 = S3(p1: 1, p2: S3.S4(p: 3))let s3 = S3(p1: &quot;one&quot;, p2: S3.S4(p: &quot;three&quot;))print(s2,s3)\nsession Embrace Swift generics 、Design protocol interfaces in Swift\nswift 5.6 和之前编写泛型接口如下：\nfunc feed&lt;A&gt;(_ animal: A) where A: Animal// 👆🏻👇🏻 Equivalentsfunc feed&lt;A: Animal&gt;(_ animal: A)\nswift 5.7 可以这样写：\nfunc feed(_ animal: some Animal)\nsome 关键字可以用于参数和结构类型。some 会保证类型关系，而 any 会持有任意具体类型，删除类型关系。\nSE-0347 Type inference from default expressions 扩展 Swift 泛型参数类型的默认值能力。如下代码示例：\nfunc suffledArray&lt;T: Sequence&gt;(from options: T = 1...100) -&gt; [T.Element] &#123;    Array(options.shuffled())&#125;print(suffledArray())print(suffledArray(from: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]))\nSE-0341 Opaque Parameter Declarations 使用 some 参数简化泛型参数声明。SE-0328 Structural opaque result types 扩大不透明结果返回类型可以使用的范围。SE-0360 Opaque result types with limited availability 可用性有限的不透明结果类型，比如 if #available(macOS 13.0, *) {} 就可以根据系统不同版本返回不同类型，新版本出现新类型的 View 就可以和以前的 View 类型区别开。\nSE-0309 Unlock existentials for all protocols 改进了 existentials 和 泛型的交互。这样就可以更方便的检查 Any 类型的两个值是否相等\nany 关键字充当的是类型擦除的助手，是通过告知编译器你使用 existential 作为类型，此语法可兼容以前系统。\nSE-0346 Lightweight same-type requirements for primary associated types 引入一种新语法，用于符合泛型参数并通过相同类型要求约束关联类型。SE-0358 Primary Associated Types in the Standard Library 引入主要关联类型概念，并将其带入了标准库。这些关联类型很像泛型，允许开发者将给定关联类型的类型指定为通用约束。\nSE-0353 Constrained Existential Types 基于 SE-0309 和 SE-0346 提案，在 existential 类型的上下文中重用轻量关联类型的约束。\nSE-0352 Implicitly Opened Existentials 允许 Swift 在很多情况下使用协议调用泛型函数。\nSwift 论坛上一个对 any 和 some 关键字语法使用场景的讨论，Do any and some help with “Protocol Oriented Testing” at all? 。\n不透明类型不透明类型会隐藏类型，让使用者更关注功能。不透明类型和协议很类似，不同的是不透明比协议限定的要多，协议能够对应更多类型。\nprotocol P &#123;    func f() -&gt; String&#125;struct S1: P &#123;    func f() -&gt; String &#123;        return &quot;one\\n&quot;    &#125;&#125;struct S2&lt;T: P&gt;: P &#123;    var p: T    func f() -&gt; String &#123;        return p.f() + &quot;two\\n&quot;    &#125;&#125;struct S3&lt;T1: P, T2: P&gt;: P &#123;    var p1: T1    var p2: T2    func f() -&gt; String &#123;        return p1.f() + p2.f() + &quot;three\\n&quot;    &#125;&#125;func someP() -&gt; some P &#123;    return S3(p1: S1(), p2: S2(p: S1()))&#125;let r = someP()print(r.f())\n函数调用者决定返回什么类型是泛型，函数自身决定返回什么类型使用不透明返回类型。\nResultResult 类型用来处理错误，特别适用异步接口的错误处理。\nextension URLSession &#123;    func dataTaskWithResult(        with url: URL,        handler: @escaping (Result&lt;Data, Error&gt;) -&gt; Void    ) -&gt; URLSessionDataTask &#123;        dataTask(with: url) &#123; data, _, err in            if let err = err &#123;                handler(.failure(err))            &#125; else &#123;                handler(.success(data ?? Data()))            &#125;        &#125;    &#125;&#125;let url = URL(string: &quot;https://ming1016.github.io/&quot;)!// 以前网络请求let t1 = URLSession.shared.dataTask(with: url) &#123;    data, _, error in    if let err = error &#123;        print(err)    &#125; else if let data = data &#123;        print(String(decoding: data, as: UTF8.self))    &#125;&#125;t1.resume()// 使用 Result 网络请求let t2 = URLSession.shared.dataTaskWithResult(with: url) &#123; result in    switch result &#123;    case .success(let data):        print(String(decoding: data, as: UTF8.self))    case .failure(let err):        print(err)    &#125;&#125;t2.resume()\n类型转换使用 is 关键字进行类型判断， 使用as 关键字来转换成子类。\nclass S0 &#123;&#125;class S1: S0 &#123;&#125;class S2: S0 &#123;&#125;var a = [S0]()a.append(S1())a.append(S2())for e in a &#123;    // 类型判断    if e is S1 &#123;        print(&quot;Type is S1&quot;)    &#125; else if e is S2 &#123;        print(&quot;Type is S2&quot;)    &#125;    // 使用 as 关键字转换成子类    if let s1 = e as? S1 &#123;        print(&quot;As S1 \\(s1)&quot;)    &#125; else if let s2 = e as? S2 &#123;        print(&quot;As S2 \\(s2)&quot;)    &#125;&#125;\n类和结构体类类可以定义属性、方法、构造器、下标操作。类使用扩展来扩展功能，遵循协议。类还以继承，运行时检查实例类型。\nclass C &#123;    var p: String    init(_ p: String) &#123;        self.p = p    &#125;        // 下标操作    subscript(s: String) -&gt; String &#123;        get &#123;            return p + s        &#125;        set &#123;            p = s + newValue        &#125;    &#125;&#125;let c = C(&quot;hi&quot;)print(c.p)print(c[&quot; ming&quot;])c[&quot;k&quot;] = &quot;v&quot;print(c.p)\n结构体 结构体是值类型，可以定义属性、方法、构造器、下标操作。结构体使用扩展来扩展功能，遵循协议。\nstruct S &#123;    var p1: String = &quot;&quot;    var p2: Int&#125;extension S &#123;    func f() -&gt; String &#123;        return p1 + String(p2)    &#125;&#125;var s = S(p2: 1)s.p1 = &quot;1&quot;print(s.f()) // 11\n属性类、结构体或枚举里的变量常量就是他们的属性。\nstruct S &#123;    static let sp = &quot;类型属性&quot; // 类型属性通过类型本身访问，非实例访问    var p1: String = &quot;&quot;    var p2: Int = 1    // cp 是计算属性    var cp: Int &#123;        get &#123;            return p2 * 2        &#125;        set &#123;            p2 = newValue + 2        &#125;    &#125;    // 只有 getter 的是只读计算属性    var rcp: Int &#123;        p2 * 4    &#125;&#125;print(S.sp)print(S().cp) // 2var s = S()s.cp = 3print(s.p2) // 5print(S().rcp) // 4\nwillSet 和 didSet 是属性观察器，可以在属性值设置前后插入自己的逻辑处理。\n键路径表达式作为函数\nstruct S2 &#123;    let p1: String    let p2: Int&#125;let s2 = S2(p1: &quot;one&quot;, p2: 1)let s3 = S2(p1: &quot;two&quot;, p2: 2)let a1 = [s2, s3]let a2 = a1.map(\\.p1)print(a2) // [&quot;one&quot;, &quot;two&quot;]\n方法enum E: String &#123;    case one, two, three    func showRawValue() &#123;        print(rawValue)    &#125;&#125;let e = E.threee.showRawValue() // three// 可变的实例方法，使用 mutating 标记struct S &#123;    var p: String    mutating func addFullStopForP() &#123;        p += &quot;.&quot;    &#125;&#125;var s = S(p: &quot;hi&quot;)s.addFullStopForP()print(s.p)// 类方法class C &#123;    class func cf() &#123;        print(&quot;类方法&quot;)    &#125;&#125;\nstatic和class关键字修饰的方法类似 OC 的类方法。static 可以修饰存储属性，而 class 不能；class 修饰的方法可以继承，而 static 不能。在协议中需用 static 来修饰。\n静态下标方法\n// 静态下标struct S2 &#123;    static var sp = [String: Int]()        static subscript(_ s: String, d: Int = 10) -&gt; Int &#123;        get &#123;            return sp[s] ?? d        &#125;        set &#123;            sp[s] = newValue        &#125;    &#125;&#125;S2[&quot;key1&quot;] = 1S2[&quot;key2&quot;] = 2print(S2[&quot;key2&quot;]) // 2print(S2[&quot;key3&quot;]) // 10\n自定义类型中实现了 callAsFunction() 的话，该类型的值就可以直接调用。\n// callAsFunction()struct S3 &#123;    var p1: String        func callAsFunction() -&gt; String &#123;        return &quot;show \\(p1)&quot;    &#125;&#125;let s2 = S3(p1: &quot;hi&quot;)print(s2()) // show hi\n继承类能继承另一个类，继承它的方法、属性等。\n// 类继承class C1 &#123;    var p1: String    var cp1: String &#123;        get &#123;            return p1 + &quot; like ATM&quot;        &#125;        set &#123;            p1 = p1 + newValue        &#125;    &#125;    init(p1: String) &#123;        self.p1 = p1    &#125;    func sayHi() &#123;        print(&quot;Hi! \\(p1)&quot;)    &#125;&#125;class C2: C1 &#123;    var p2: String    init(p2: String) &#123;        self.p2 = p2        super.init(p1: p2 + &quot;&#x27;s father&quot;)    &#125;&#125;C2(p2: &quot;Lemon&quot;).sayHi() // Hi! Lemon&#x27;s father// 重写父类方法class C3: C2 &#123;    override func sayHi() &#123;        print(&quot;Hi! \\(p2)&quot;)    &#125;&#125;C3(p2: &quot;Lemon&quot;).sayHi() // Hi! Lemon// 重写计算属性class C4: C1 &#123;    override var cp1: String &#123;        get &#123;            return p1 + &quot; like Out of the blade&quot;        &#125;        set &#123;            p1 = p1 + newValue        &#125;    &#125;&#125;print(C1(p1: &quot;Lemon&quot;).cp1) // Lemon like ATMprint(C4(p1: &quot;Lemon&quot;).cp1) // Lemon like Out of the blade\n通过 final 关键字可以防止类被继承，final 还可以用于属性和方法。使用 super 关键字指代父类。\n函数式mapmap 可以依次处理数组中元素，并返回一个处理后的新数组。\nlet a1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]let a2 = a1.map &#123;    &quot;\\($0)2&quot;&#125;print(a2) // [&quot;a2&quot;, &quot;b2&quot;, &quot;c2&quot;]\n使用 compactMap 可以过滤 nil 的元素。flatMap 会将多个数组合成一个数组返回。\nfilter根据指定条件返回\nlet a1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;call my name&quot;]let a2 = a1.filter &#123;    $0.prefix(1) == &quot;c&quot;&#125;print(a2) // [&quot;c&quot;, &quot;call my name&quot;]\nreducereduce 可以将迭代中返回的结果用于下个迭代中，并，还能让你设个初始值。\nlet a1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;call my name.&quot;, &quot;get it?&quot;]let a2 = a1.reduce(&quot;Hey u,&quot;, &#123; partialResult, s in    // partialResult 是前面返回的值，s 是遍历到当前的值    partialResult + &quot; \\(s)&quot;&#125;)print(a2) // Hey u, a b c call my name. get it?\nsorted排序\n// 类型遵循 Comparablelet a1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;call my name.&quot;, &quot;get it?&quot;]let a2 = a1.sorted()let a3 = a1.sorted(by: &gt;)let a4 = a1.sorted(by: &lt;)print(a2) // Hey u, a b c call my name. get it?print(a3) // [&quot;get it?&quot;, &quot;call my name.&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]print(a4) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;call my name.&quot;, &quot;get it?&quot;]// 类型不遵循 Comparablestruct S &#123;    var s: String    var i: Int&#125;let a5 = [S(s: &quot;a&quot;, i: 0), S(s: &quot;b&quot;, i: 1), S(s: &quot;c&quot;, i: 2)]let a6 = a5    .sorted &#123; l, r in        l.i &gt; r.i    &#125;    .map &#123;        $0.i    &#125;print(a6) // [2, 1, 0]\n控制流If// iflet s = &quot;hi&quot;if s.isEmpty &#123;    print(&quot;String is Empty&quot;)&#125; else &#123;    print(&quot;String is \\(s)&quot;)&#125;// 三元条件s.isEmpty ? print(&quot;String is Empty again&quot;) : print(&quot;String is \\(s) again&quot;)// if let-elsefunc f(s: String?) &#123;    if let s1 = s &#123;        print(&quot;s1 is \\(s1)&quot;)    &#125; else &#123;        print(&quot;s1 is nothing&quot;)    &#125;    // nil-coalescing    let s2 = s ?? &quot;nothing&quot;    print(&quot;s2 is \\(s2)&quot;)&#125;f(s: &quot;something&quot;)f(s: nil)// if case letenum E &#123;    case c1(String)    case c2([String])        func des() &#123;        switch self &#123;        case .c1(let string):            print(string)        case .c2(let array):            print(array)        &#125;    &#125;&#125;E.c1(&quot;enum c1&quot;).des()E.c2([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]).des()\nGuard更好地处理异常情况\n// guardfunc f1(p: String) -&gt; String &#123;    guard p.isEmpty != true else &#123;        return &quot;Empty string.&quot;    &#125;    return &quot;String \\(p) is not empty.&quot;&#125;print(f1(p: &quot;&quot;)) // Empty string.print(f1(p: &quot;lemon&quot;)) // String lemon is not empty.// guard letfunc f2(p1: String?) -&gt; String &#123;    guard let p2 = p1 else &#123;        return &quot;Nil.&quot;    &#125;    return &quot;String \\(p2) is not nil.&quot;&#125;print(f2(p1: nil)) // Nil.print(f2(p1: &quot;lemon&quot;)) // String lemon is not nil.\n遍历let a = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]for str in a &#123;    print(str)&#125;a.forEach &#123; str in    print(str)&#125;// 使用下标范围for i in 0..&lt;10 &#123;    print(i)&#125;for i in 0...9 &#123;     print(i) &#125;// 使用 enumerated，i 是下标，str 是元素for (i, str) in a.enumerated() &#123;    print(&quot;第\\(i + 1)个是:\\(str)&quot;)&#125;// for in wherefor str in a where str.prefix(1) == &quot;t&quot; &#123;    print(str)&#125;// 字典 for in，遍历是无序的let dic = [    &quot;one&quot;: 1,    &quot;two&quot;: 2,    &quot;three&quot;: 3]for (k, v) in dic &#123;    print(&quot;key is \\(k), value is \\(v)&quot;)&#125;dic.forEach &#123; (k, v) in    print(&quot;key is \\(k), value is \\(v)&quot;)&#125;// stridefor i in stride(from: 10, through: 0, by: -2) &#123;    print(i)&#125;/* 10 8 6 4 2 0 */ // 在循环中使用 continue 和 breakfor i in 0..&lt;10 &#123;    if i % 2 == 0 &#123;        continue    &#125;    print(i)&#125;// 在循环中使用 wherefor i in 0..&lt;10 where i % 2 == 0 &#123;    print(i)&#125;\nWhile// whilevar i1 = 10while i1 &gt; 0 &#123;    print(&quot;positive even number \\(i1)&quot;)    i1 -= 2&#125;// repeat whilevar i2 = 10repeat &#123;    print(&quot;positive even number \\(i2)&quot;)    i2 -= 2&#125; while i2 &gt; 0\n使用 break 结束遍历，使用 continue 跳过当前作用域，继续下个循环\nSwitchfunc f1(pa: String, t:(String, Int)) &#123;    var p1 = 0    var p2 = 10    switch pa &#123;    case &quot;one&quot;:        p1 = 1    case &quot;two&quot;:        p1 = 2        fallthrough // 继续到下个 case 中    default:        p2 = 0    &#125;    print(&quot;p1 is \\(p1)&quot;)    print(&quot;p2 is \\(p2)&quot;)        // 元组    switch t &#123;    case (&quot;0&quot;, 0):        print(&quot;zero&quot;)    case (&quot;1&quot;, 1):        print(&quot;one&quot;)    default:        print(&quot;no&quot;)    &#125;&#125;f1(pa: &quot;two&quot;, t:(&quot;1&quot;, 1))/* p1 is 2 p2 is 0 one */// 枚举enum E &#123;    case one, two, three, unknown(String)&#125;func f2(pa: E) &#123;    var p: String    switch pa &#123;    case .one:        p = &quot;1&quot;    case .two:        p = &quot;2&quot;    case .three:        p = &quot;3&quot;    case let .unknown(u) where Int(u) ?? 0 &gt; 0 : // 枚举关联值，使用 where 增加条件        p = u    case .unknown(_):        p = &quot;negative number&quot;    &#125;    print(p)&#125;f2(pa: E.one) // 1f2(pa: E.unknown(&quot;10&quot;)) // 10f2(pa: E.unknown(&quot;-10&quot;)) // negative number\n集合数组数组是有序集合\nvar a0: [Int] = [1, 10]a0.append(2)a0.remove(at: 0)print(a0) // [10, 2]let a1 = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]let a2 = [&quot;three&quot;, &quot;four&quot;]// 找两个集合的不同let dif = a1.difference(from: a2) // swift的 diffing 算法在这 http://www.xmailserver.org/diff2.pdf swift实现在  swift/stdlib/public/core/Diffing.swiftfor c in dif &#123;    switch c &#123;    case .remove(let o, let e, let a):        print(&quot;offset:\\(o), element:\\(e), associatedWith:\\(String(describing: a))&quot;)    case .insert(let o, let e, let a):        print(&quot;offset:\\(o), element:\\(e), associatedWith:\\(String(describing: a))&quot;)    &#125;&#125;/* remove offset:1, element:four, associatedWith:nil insert offset:0, element:one, associatedWith:nil insert offset:1, element:two, associatedWith:nil */let a3 = a2.applying(dif) ?? [] // 可以用于添加删除动画print(a3) // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]\ndif 有第三个 case 值 .insert(let offset, let element, let associatedWith) 可以跟踪成对的变化，用于高级动画。\n从数组中随机取一个元素\nprint(a0.randomElement() ?? 0)\n数组排序\n// 排序struct S1 &#123;    let n: Int    var b = true&#125;let a4 = [    S1(n: 1),    S1(n: 10),    S1(n: 3),    S1(n: 2)]let a5 = a4.sorted &#123; i1, i2 in    i1.n &lt; i2.n&#125;for n in a5 &#123;    print(n)&#125;/// S1(n: 1)/// S1(n: 2)/// S1(n: 3)/// S1(n: 10)let a6 = [1,10,4,7,2]print(a6.sorted(by: &gt;)) // [10, 7, 4, 2, 1]\n可以加到数组扩展中，通过扩展约束能够指定特定元素类型的排序，代码如下：\nextension Array where Element == Int &#123;    // 升序    func intSortedASC() -&gt; [Int] &#123;        return self.sorted(by: &lt;)    &#125;    // 降序    func intSortedDESC() -&gt; [Int] &#123;        return self.sorted(by: &lt;)    &#125;&#125;print(a6.intSortedASC()) // 使用扩展增加自定义排序能力\n在数组中检索满足条件的元素，代码如下：\n// 第一个满足条件了就返回let a7 = a4.first &#123;    $0.n == 10&#125;print(a7?.n ?? 0)// 是否都满足了条件print(a4.allSatisfy &#123; $0.n == 1 &#125;) // falseprint(a4.allSatisfy(\\.b)) // true// 找出最大的那个print(a4.max(by: &#123; e1, e2 in    e1.n &lt; e2.n&#125;) ?? S1(n: 0))// S1(n: 10, b: true)// 看看是否包含某个元素print(a4.contains(where: &#123;    $0.n == 7&#125;))// false\n一些切割数组的方法。\n// 切片// 取前3个，并不是直接复制，对于大的数组有性能优势。print(a6[..&lt;3]) // [1, 10, 4] 需要做越界检查print(a6.prefix(30)) // [1, 10, 4, 7, 2] 不需要做越界检查，也是切片，性能一样// 去掉前3个print(a6.dropFirst(3)) // [7, 2]\nprefix(while:) 和 drop(while:) 方法，顺序遍历执行闭包里的逻辑判断，满足条件就返回，遇到不匹配就会停止遍历。prefix 返回满足条件的元素集合，drop 返回停止遍历之后那些元素集合。\nlet a8 = [8, 9, 20, 1, 35, 3]let a9 = a8.prefix &#123;    $0 &lt; 30&#125;print(a9) // [8, 9, 20, 1]let a10 = a8.drop &#123;    $0 &lt; 30&#125;print(a10) // [35, 3]\n比 filter 更高效的删除元素的方法 removeAll\n// 删除所有不满足条件的元素var a11 = [1, 3, 5, 12, 25]a11.removeAll &#123; $0 &lt; 10 &#125;print(a11) // [12, 25]// 创建未初始化的数组let a12 = (0...4).map &#123; _ in    Int.random(in: 0...5)&#125;print(a12) // [0, 3, 3, 2, 5] 随机\n#if 用于后缀表达式\n// #if 用于后缀表达式let a13 = a11#if os(iOS)    .count#else    .reduce(0, +)#endifprint(a13) //37\nSetsSet 是无序集合，元素唯一\nlet s0: Set&lt;Int&gt; = [2, 4]let s1: Set = [2, 10, 6, 4, 8]let s2: Set = [7, 3, 5, 1, 9, 10]let s3 = s1.union(s2) // 合集let s4 = s1.intersection(s2) // 交集let s5 = s1.subtracting(s2) // 非交集部分let s6 = s1.symmetricDifference(s2) // 非交集的合集print(s3) // [4, 2, 1, 7, 3, 10, 8, 9, 6, 5]print(s4) // [10]print(s5) // [8, 4, 2, 6]print(s6) // [9, 1, 3, 4, 5, 2, 6, 8, 7]// s0 是否被 s1 包含print(s0.isSubset(of: s1)) // true// s1 是否包含了 s0print(s1.isSuperset(of: s0)) // truelet s7: Set = [3, 5]// s0 和 s7 是否有交集print(s0.isDisjoint(with: s7)) // true// 可变 Setvar s8: Set = [&quot;one&quot;, &quot;two&quot;]s8.insert(&quot;three&quot;)s8.remove(&quot;one&quot;)print(s8) // [&quot;two&quot;, &quot;three&quot;]\n字典字典是无序集合，键值对应。\nvar d1 = [    &quot;k1&quot;: &quot;v1&quot;,    &quot;k2&quot;: &quot;v2&quot;]d1[&quot;k3&quot;] = &quot;v3&quot;d1[&quot;k4&quot;] = nilprint(d1) // [&quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: &quot;v3&quot;, &quot;k1&quot;: &quot;v1&quot;]for (k, v) in d1 &#123;    print(&quot;key is \\(k), value is \\(v)&quot;)&#125;/* key is k1, value is v1 key is k2, value is v2 key is k3, value is v3 */ if d1.isEmpty == false &#123;    print(d1.count) // 3&#125;// mapValueslet d2 = d1.mapValues &#123;    $0 + &quot;_new&quot;&#125;print(d2) // [&quot;k2&quot;: &quot;v2_new&quot;, &quot;k3&quot;: &quot;v3_new&quot;, &quot;k1&quot;: &quot;v1_new&quot;]// 对字典的值或键进行分组let d3 = Dictionary(grouping: d1.values) &#123;    $0.count&#125;print(d3) // [2: [&quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;]]// 从字典中取值，如果键对应无值，则使用通过 default 指定的默认值d1[&quot;k5&quot;, default: &quot;whatever&quot;] += &quot;.&quot;print(d1[&quot;k5&quot;] ?? &quot;&quot;) // whatever.let v1 = d1[&quot;k3&quot;, default: &quot;whatever&quot;]print(v1) // v3// compactMapValues() 对字典值进行转换和解包。可以解可选类型，并去掉 nil 值let d4 = [    &quot;k1&quot;: 1,    &quot;k2&quot;: 2,    &quot;k3&quot;: nil]let d5 = d4.mapValues &#123; $0 &#125;let d6 = d4.compactMapValues&#123; $0 &#125;print(d5)// [&quot;k3&quot;: nil, &quot;k1&quot;: Optional(1), &quot;k2&quot;: Optional(2)]print(d6)// [&quot;k1&quot;: 1, &quot;k2&quot;: 2]\n操作符赋值let i1 = 1var i2 = i1i2 = 2print(i2) // 2i2 += 1print(i2) // 3i2 -= 2print(i2) // 1i2 *= 10print(i2) // 10i2 /= 2print(i2) // 5\n计算符let i1 = 1let i2 = i1print((i1 + i2 - 1) * 10 / 2 % 3) // 2print(&quot;i&quot; + &quot;1&quot;) // i1// 一元运算符print(-i1) // -1\n比较运算符遵循 Equatable 协议可以使用 &#x3D;&#x3D; 和 !&#x3D; 来判断是否相等\nprint(1 &gt; 2) // falsestruct S: Equatable &#123;    var p1: String    var p2: Int&#125;let s1 = S(p1: &quot;one&quot;, p2: 1)let s2 = S(p1: &quot;two&quot;, p2: 2)let s3 = S(p1: &quot;one&quot;, p2: 2)let s4 = S(p1: &quot;one&quot;, p2: 1)print(s1 == s2) // falseprint(s1 == s3) // falseprint(s1 == s4) // true\n类需要实现 &#x3D;&#x3D; 函数\nclass C: Equatable &#123;    var p1: String    var p2: Int    init(p1: String, p2: Int) &#123;        self.p1 = p1        self.p2 = p2    &#125;        static func == (l: C, r: C) -&gt; Bool &#123;        return l.p1 == r.p1 &amp;&amp; l.p2 == r.p2    &#125;&#125;let c1 = C(p1: &quot;one&quot;, p2: 1)let c2 = C(p1: &quot;one&quot;, p2: 1)print(c1 == c2)// 元组比较// 会先比较第一个数，第一个无法比较才会比较第二个数// 字符串比较和字母大小还有长度有关。先比较字母大小，在比较长度(&quot;apple&quot;, 1) &lt; (&quot;apple&quot;, 2) // true(&quot;applf&quot;, 1) &lt; (&quot;apple&quot;, 2) // false(&quot;appl&quot;, 2) &lt; (&quot;apple&quot;, 1) // true(&quot;appm&quot;, 2) &lt; (&quot;apple&quot;, 1) // false\n三元简化 if else 写法\n// if elsefunc f1(p: Int) &#123;    if p &gt; 0 &#123;        print(&quot;positive number&quot;)    &#125; else &#123;        print(&quot;negative number&quot;)    &#125;&#125;// 三元func f2(p: Int) &#123;    p &gt; 0 ? print(&quot;positive number&quot;) : print(&quot;negative number&quot;)&#125;f1(p: 1)f2(p: 1)\ncoalescing简化 if let else 写法\n// if elsefunc f1(p: Int?) &#123;    if let i = p &#123;        print(&quot;p have value is \\(i)&quot;)    &#125; else &#123;        print(&quot;p is nil, use defalut value&quot;)    &#125;&#125;// 使用 ??func f2(p: Int?) &#123;    let i = p ?? 0    print(&quot;p is \\(i)&quot;)&#125;\n范围简化的值范围表达方式。\n// 封闭范围for i in 0...10 &#123;    print(i)&#125;// 半开范围for i in 0..&lt;10 &#123;    print(i)&#125;\n// 单侧区间let nums = [5,6,7,8]print(nums[2...]) // 7 8\n逻辑let i1 = -1let i2 = 2if i1 != i2 &amp;&amp; (i1 &lt; 0 || i2 &lt; 0) &#123;    print(&quot;i1 and i2 not equal, and one of them is negative number.&quot;)&#125;\n恒等恒等返回是否引用了相同实例。\nclass C &#123;    var p: String    init(p: String) &#123;        self.p = p    &#125;&#125;let c1 = C(p: &quot;one&quot;)let c2 = C(p: &quot;one&quot;)let c3 = c1print(c1 === c2) // falseprint(c1 === c3) // trueprint(c1 !== c2) // true\n运算符位运算符\nlet i1: UInt8 = 0b00001111let i2 = ~i1 // Bitwise NOT Operator（按位取反运算符），取反let i3: UInt8 = 0b00111111let i4 = i1 &amp; i3 // Bitwise AND Operator（按位与运算符），都为1才是1let i5 = i1 | i3 // Bitwise OR Operator（按位或运算符），有一个1就是1let i6 = i1 ^ i3 // Bitwise XOR Operator（按位异或运算符），不同为1，相同为0print(i1,i2,i3,i4,i5,i6)// &lt;&lt; 按位左移，&gt;&gt; 按位右移let i7 = i1 &lt;&lt; 1let i8 = i1 &gt;&gt; 2print(i7,i8)\n溢出运算符，有 &amp;+、&amp;- 和 &amp;*\nvar i1 = Int.maxprint(i1) // 9223372036854775807i1 = i1 &amp;+ 1print(i1) // -9223372036854775808i1 = i1 &amp;+ 10print(i1) // -9223372036854775798var i2 = UInt.maxi2 = i2 &amp;+ 1print(i2) // 0\n运算符函数包括前缀运算符、后缀运算符、复合赋值运算符以及等价运算符。另，还可以自定义运算符，新的运算符要用 operator 关键字进行定义，同时要指定 prefix、infix 或者 postfix 修饰符。\nSwift规范参考：\n\nSwift Style Guide\n\n多用静态特性。swift 在编译期间所做的优化比 OC 要多，这是由于他的静态派发、泛型特化、写时复制这些静态特性决定的。另外通过 final 和 private 这样的表示可将动态特性转化为静态方式，编译开启 WMO 可以自动推导出哪些动态派发可转化为静态派发。\n如何避免崩溃？\n\n字典：用结构体替代\nAny：可用泛型或关联关联类型替代\nas? ：少用 AnyObject，多用泛型或不透明类型\n!：要少用\n\n好的实践？\n\n少用继承，多用 protocol\n多用 extension 对自己代码进行管理\n\nSwift书单\n《Thinking in SwiftUI》\n《Swift 进阶》\n《函数式Swift》\n《深入解析Mac OS X &amp; iOS操作系统》\n《LLVM Techniques, Tips, and Best Practices Clang and Middle-End Libraries》\n《Learn LLVM 12》\n《Crafting Interpreters》\n《TCP&#x2F;IP Illustrated》\n《松本行弘的程序世界》\n《现代操作系统》\n《深入理解计算机系统》\n《程序员的自我修养》\n《Head First 设计模式》\n\n"},{"title":"包体积","url":"/2025/05/15/%E5%8C%85%E4%BD%93%E7%A7%AF/","content":"包体积的影响包体积优化的必要性\n下载转化率下降：每增加6M，应用下载转化率下降1%。\nApp Store限制：超过200MB的包，iOS 13以下用户无法通过蜂窝数据下载，iOS 13及以上用户需手动设置。\n磁盘占用：大包体积占用更多存储空间，影响低存储用户。\n用户下载意愿：大包体积减少用户下载意愿，尤其在蜂窝数据低数据模式下。\n性能影响：包体积大增加启动时间和SIGKILL风险，降低基础体验。\n\n技术方案\n资源优化：优化大块资源、无用配置文件和重复资源。\n工程架构优化：建立体积检测流水线，控制体积增长。\n图片优化：无用图片优化、Asset Catalog优化、HEIC和WebP压缩优化、TinyPng压缩。\n编译器优化：使用LLVM编译选项，进行OC、C++、Swift等语言的编译优化。\n代码优化：无用类、方法、模块瘦身，精简重复代码，AB实验固化。\n\n包体积-系统优化\nApp Thinning：利用Apple提供的App Thinning功能，根据用户的设备自动下载适合该设备的资源包，有助于减少初装包的大小。\n按需下载资源：使用On-Demand Resources来按需下载资源，只下载用户实际需要的部分，从而减小初始安装包的大小。\n\n包的分析安装包生成过程与指标\n生成过程：ipa包上传AppStore后，App Thinning针对不同设备生成不同编译产物。\n安装包与下载包大小：安装包大小是用户安装后占用的磁盘空间，下载包大小是用户下载时的压缩包大小。\n衡量标准：iOS端通常将安装包体积作为衡量标准。\n\niOS端安装包组成部分\nMach-O文件：iOS系统上的可执行文件。\nWatch APP：带有小组件功能的WatchApp。\n自定义动态库：动态库推迟到运行时加载，节省代码段空间。\nSwift系统库：高版本iOS系统自带，低版本需iPA包中自带。\nAssets资源：Assets.car文件，包含图片资源。\n根目录下图片资源：直接添加进工程的图片文件。\nbundle资源：管理图片和其他配置文件。\n其他配置文件：如plist、js、css、json等。\n\nMach-O文件Mach-O是Mach Object文件格式的缩写，用于记录Mac及iOS系统上的可执行文件、目标代码、动态库和内存转储。使用MachOView和otool命令查看Mach-O文件信息，以及通过file和lipo命令查看文件格式和架构。Mach-O文件有Header、LoadCommands和Data部分，特别是LoadCommands中的关键cmd类型如LCSEGMENT64，及其段(__PAGEZERO、__TEXT、__DATA、__LINKEDIT)。\n开源工具5GUIs5GUIs 是一款基于 SwiftUI 开发的 macOS 应用程序，它具备检测其他 macOS 应用程序中所使用的 GUI（图形用户界面）技术的能力。通过分析应用捆绑包并利用 LLVM 的 objdump 工具，5GUIs 能够识别出各种界面技术，如 AppKit、Apple 的 Catalyst（原 Marzipan 项目）、iOS 式的 SwiftUI，以及基于 Electron 和 UIKit 的应用。5GUIs 不仅能够识别技术栈，还能展示不同 GUI 风格的应用窗口，为用户提供一个直观的界面设计展示平台。\nAPPAnalyzeAPPAnalyze 是一款用于分析iOS ipa包的脚本工具，能够自动扫描并发现可修复的包体积问题，同时生成包体积数据用于查看。\n数据指标量化：\n\n包体积问题：提供数据化平台查看每个组件的包体积待修复问题。\n包体积大小：展示总大小、单个文件二进制大小和每个资源大小，支持组件化粒度的包体积数据对比。\n\n扫描规则与修复方式：\n\n未使用的类：定义但未使用的ObjC和Swift类，建议移除。\n未使用的ObjC协议：定义但未使用的协议，建议移除。\nBundle内多Scale图片：移除Scale更低的图片。\n大资源：文件大小超过20KB即为大资源，建议移除或动态下发。\n重复的资源文件：移除多余的文件。\n未使用的属性、方法、资源文件等均有详细的扫描规则和修复建议。\n\n安全与性能：\n\n安全：动态反射调用、属性内存申明错误、冲突的分类方法等问题及其修复方式。\n性能：使用动态库会增加启动耗时，建议使用静态库；减少+load方法的使用以降低启动耗时。\n\n包体积-资源优化方案\n图片资源压缩：使用无损或有损压缩工具（如ImageOptim、tinypng、pngquant等）对图片资源进行压缩，尤其是PNG和JPEG格式的图片。考虑将图片转换为WebP格式，因为WebP格式具有较高的压缩率且肉眼难以察觉质量损失。\n资源清理：使用工具如LSUnusedResources来查找并删除项目中未被引用的图片、音频、视频等资源文件。手动检查项目中是否存在已经不再使用但未被删除的资源，如旧版本的启动图、图标等。\n动态加载资源：对于大型资源文件（如视频、音频文件），可以考虑在运行时从服务器下载，而不是直接包含在APP安装包中。\n使用Assets.xcassets：使用Assets.xcassets来管理图片资源，因为Xcode会对Assets.xcassets中的图片进行自动压缩，生成更小的Assets.car文件。\n\n无用图片优化通过工具获取所有图片资源及代码中可能引用图片的静态字符串，对比找出未引用的图片并删除。具体步骤：\n\n获取所有图片：使用脚本递归遍历工程目录，收集所有图片资源及其所属关系。\n获取可能引用图片的静态字符串：针对不同文件格式（如Objective-C、Swift、HTML等），使用正则表达式匹配可能引用图片的字符串。\n获取未引用图片：对比图片资源和引用字符串集合，找出未引用的图片。\n二次过滤：针对字符串拼接的常见case（如暗黑模式图片、图片序列等）进行二次过滤，提高准确度。\n\nAsset Catalog图片优化Asset Catalog是Xcode提供的资源管理工具，用于集中管理项目中的图片等资源。通过Xcode自带工具actool生成Assets.car文件，可使用assetutil工具分析文件内容。开发者在图片放入Asset Catalog前不要做无损压缩，因为actool会重新进行压缩处理。\nAsset Catalog 的优点有：\n\n包体积瘦身：根据不同设备下载匹配的图片资源，减少下载包大小。\n统一的图片无损压缩：采用Apple Deep Pixel Image Compression技术，提高压缩比。\n便利的资源管理：将图片资源统一压缩成Assets.car文件，便于管理。\n高效的I&#x2F;O操作：图片加载耗时减少两个数量级，提升应用性能。\n\n图片压缩工具TinyPng和pngquant，pngquant支持批量压缩和自定义压缩品质。\nHEIC图片编码优化HEIC图片编码具有高压缩率、节省内存和解码效率高的特点。自iOS 11起，苹果将HEIC设置为图片存储的默认格式，适用于对图片质量和体积要求较高的场景。\n大资源优化\n获取大资源：通过递归遍历ipa包获取体积大于40K的资源文件。\n优化方法：包括异步下载和资源压缩，以降低首次启动加载压力。\n\n无用配置文件\n获取配置文件：使用排除法从ipa包中获取除特定文件（如dylib、asset.car、图片、JS&amp;CSS）外的配置文件。\n获取静态字符串常量：通过otool命令从mach-o文件的TEXT字段静态字符串常量中获取引用的配置文件。\n无用文件排查：对比获取的配置文件和引用的配置文件，确认并删除无用文件。\nJS&amp;CSS文件排查：针对JS&amp;CSS文件的特殊性，采用类似无用图片检测的方法进行优化。\n\n重复资源优化\n获取资源文件：从ipa包中获取所有资源文件。\n判断重复资源：通过MD5判断资源是否重复，并删除重复资源以减小包体积。\n\n包体积-代码优化方案\n移除未使用的代码：查找并删除未使用的类、方法、变量等。审查业务逻辑，删除不再使用或已被废弃的代码模块。\n重构代码：对重复的代码进行重构，使用函数、类等方法来减少代码冗余。优化数据结构，减少内存占用和CPU消耗。\n编译策略调整：修改编译策略，如启用LTO（链接时优化）来优化跨模块调用代码。剥离符号表（Strip Linked Product），删除未引用的C&#x2F;C++&#x2F;Swift代码。精简编译产物，只保留必要的符号和导出信息。\n代码组件化：将常用代码文件打包成静态库，切断不同业务代码之间的依赖，减少每次编译的代码量。\n减少文件引用：能使用@class就使用@class，尽量减少文件之间的直接引用关系。\n减少Storyboard和XIB文件的使用：尽量使用代码布局，减少Storyboard和XIB文件的使用，这些文件在编译时会增加包体积。\n清理未使用的资源：清理项目中未使用的图片、音频等资源文件，以及未使用的类和合并重复功能的类。\n模块化设计：将App拆分成多个模块，每个模块独立编译和打包，可以根据需要动态加载或更新模块，减少主包的体积。\n依赖管理：合理使用CocoaPods、Carthage等依赖管理工具，管理项目的第三方库依赖，避免不必要的库被包含进最终的包中。\n\nLink Map文件解析\n定义与功能：Link Map是Mach-O二进制文件的辅助文件，描述了可执行文件的全貌，包括编译后的目标文件信息及其代码段、数据段存储详情。\n生成方法：通过Xcode的Build Settings设置Write Link Map File为yes，并指定存储位置。\n文件结构：包括基础信息（如可执行文件路径、CPU架构）、Object文件列表、Section段表、Symbols模块等。\n\n无用类静态检测，通过分析Mach-O文件中的__DATA __objc_classlist和__DATA __objc_classrefs段，获取未使用的类信息。但存在无法检测反射调用类及方法的缺点。\n动态检测的方法。在Objective-C（OC）中，每个类结构体内部都含有一个名为isa的指针，这个指针非常关键，因为它指向了该类对应的元类（meta-class）。元类本身也是一个类，用于存储类方法的实现等信息。\n通过对元类（meta-class）的结构体进行深入分析，我们可以找到classrwt这样一个结构体，它是元类内部结构的一部分。在classrwt中，存在一个flag标志位，这个标志位用于记录类的各种状态信息。\n通过检查这个flag标志位，我们可以进行一系列的计算或判断，从而得知当前类在运行时（runtime）环境中是否已经被初始化过。这种机制是Objective-C运行时系统的一个重要特性，它允许开发者在运行时动态地获取类的信息，包括类的初始化状态等。\n也就是通过isa指针找到元类，再分析元类中的classrwt结构体中的flag标志位，我们可以得知OC中某个类是否已被初始化。\n// class is initialized#define RW_INITIALIZED        (1&lt;&lt;29)struct objc_class : objc_object &#123;    bool isInitialized() &#123;    return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;    &#125;&#125;;\n在Objective-C的运行时（runtime）机制中，类的内部结构和状态通常是由Objective-C运行时库管理的，而不是直接暴露给开发者在应用程序代码中调用的。不过，你可以通过Objective-C的runtime API来间接地获取这些信息。\n关于类是否已被初始化的问题，通常不是直接通过objc_class结构体中的某个函数来判断的，因为objc_class结构体（及其元类）的细节和具体实现是私有的，并且不推荐开发者直接操作。然而，Objective-C运行时确实提供了一些工具和API来检查类的状态和行为。\n为了检查一个类是否在当前应用程序的生命周期中被使用过（即“被初始化过”），开发者可能会采用一些间接的方法，而不是直接操作类结构体的内部函数。以下是一个简化的说明：\n由于不能直接访问类的内部结构，开发者可能会通过其他方式来跟踪类的使用情况。例如，可以在类的初始化方法中设置一个静态标志位或计数器，以记录类是否已被初始化或实例化的次数。虽然不能直接调用objc_class结构体中的函数，但开发者可以使用Objective-C的runtime API（如objc_getClass、class_getInstanceSize等）来获取类的元信息和执行其他操作。然而，对于直接检查类是否“被初始化过”的需求，这些API可能并不直接提供所需的功能。在实际应用中，可能并不需要直接检查类是否“被初始化过”，而是可以通过检查该类的实例是否存在、类的某个特定方法是否被调用过等间接方式来判断。自定义与系统类相同的结构体并实现isInitialized()函数可能是一种模拟或抽象的方式。然而，在实际Objective-C开发中，这样的做法是不必要的，因为直接操作类的内部结构是违反封装原则且容易出错的。相反，开发者应该利用Objective-C提供的runtime API和其他设计模式来达成目标。提到通过赋值转换获取meta-class中的数据，这通常指的是利用Objective-C的runtime机制来查询类的元类信息。然而，直接“判断指定类是否在当前生命周期中是否被初始化过”并不是通过简单地查询元类数据就能实现的，因为这需要跟踪类的实例化过程，而不是仅仅查看元类的结构。\n获取类结构体里面的数据\nstruct mock_objc_class : lazyFake_objc_object &#123;    mock_objc_class* metaClass() &#123;        #if __LP64__            return (mock_objc_class *)((long long)isa &amp; ISA_MASK);        #else            return (mock_objc_class *)((long long)isa);        #endif    &#125;    bool isInitialized() &#123;        return metaClass()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;    &#125;&#125;;\n所有 OC 自定义类\nDl_info info;dladdr(&amp;_mh_execute_header, &amp;info);classes = objc_copyClassNamesForImage(info.dli_fname, &amp;classCount);\n是否初始化\nstruct mock_objc_class *objectClass = (__bridge struct mock_objc_class *)cls;BOOL isInitial = objectClass-&gt;isInitialized();\n最后通过无用类占比指标（无用类数量&#x2F;总类数量*100%）快速识别不再被使用的模块。对于无用类占比高的模块，进行下线或迁移处理，减少组件数量。\n无用方法\n业内常用方法：结合Mach-O和LinkMap文件分析获取无用方法，但准确率低。\n代码分析：用 Swift 编写的工程代码静态分析命令行工具 smck、使用Swift3开发了个macOS的程序可以检测出objc项目中无用方法，然后一键全部清理\n代码覆盖率：LLVM插桩获得所有方法及其调用关系。通过分析调用关系，找出未被调用的方法。详见使用 LLVM\n\n精简重复代码\n工具使用：采用开源工具扫描重复代码。\n检测与重构：通过静态分析检测重复代码，并结合实际情况进行逻辑重构。\n\n包体积-编译优化XcodeXcode 14的编译器可能通过更智能的分析，识别并消除不必要的Retain和Release调用。这些调用在内存管理中是必要的，但在某些情况下，它们可能是多余的，因为对象的生命周期管理可以通过其他方式更有效地实现。在Objective-C的运行时层面，Xcode 14可能引入了更高效的内存管理策略。这些策略可能包括更快的对象引用计数更新、更智能的对象生命周期预测等，从而减少了Retain和Release操作的执行次数和开销。剥离了未使用的代码和库，包括那些与Retain和Release操作相关的部分。这种优化可以减少最终生成的二进制文件的大小。\n编译优化\nGenerate Debug Symbols：在Levels选项内，将Generate Debug Symbols设置为NO，这可以减小安装包体积，但需要注意，这样设置后无法在断点处停下。\n舍弃老旧架构：舍弃不再支持的架构，如armv7，以减小安装包体积。\n编译优化选项：在Build Settings中，将Optimization Level设置为Fastest, Smallest [-Os]，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。同时，将Strip Debug Symbols During Copy和Symbols Hidden by Default在release版本设为yes，可以去除不必要的调试符号。\n预编译头文件：将Precompile Prefix Header设置为YES，预编译头文件可以加快编译速度，但需要注意，一旦PCH文件和引用的头文件内容发生变化，所有引用到PCH的源文件都需要重新编译。\n仅编译当前架构：在Debug模式下，将Build Active Architecture Only设置为YES，这样只编译当前架构的版本，可以加快编译速度。但在Release模式下，需要设置为NO以确保兼容性。\nDebug Information Format：设置为DWARF，减少dSYM文件的生成，从而减少包体积。\nEnable Index-While-Building Functionality：设置为NO，关闭Xcode在编译时建立代码索引的功能，以加快编译速度。\n\n编译器和运行时优化\nSwift 和 Objective-C 的优化：Apple在Swift和Objective-C的编译器和运行时上进行了许多优化，比如Swift协议一致性检查的优化，这些优化可以在不升级工程最低部署版本的情况下，通过App运行在iOS 16、tvOS 16或watchOS 9上享受到性能提升。\n并发读取缓存：Swift的协议一致性检查引入了ConcurrentReadableHashMap结构，该结构并行读取而无需加锁，相比之前的缓存方案更快。\n\n包体积-链接器优化使用 -whyload 链接器标志来减少 iOS 应用程序的二进制文件大小， -whyload 标志的作用：它可以帮助开发者识别最终二进制文件中包含的不必要符号。\n在 iOS 开发中，链接器负责将代码、库和资源结合成一个最终的可执行文件。在此过程中，可能会有一些不必要的代码被包含进去，例如未使用的库、重复的符号或模块。这些多余的代码会导致应用程序的二进制文件增大，进而影响应用的下载速度、安装时间以及设备的存储空间。\n-ObjC 标志，它通常用于强制链接所有 Objective-C 代码到最终的二进制文件中。这在某些情况下是必要的，例如使用了某些需要反射的 Objective-C 代码时，但是它也会导致未使用的代码被包含进去。通过 -why_load，开发者可以识别出哪些代码是多余的，并通过删除 -ObjC 标志来减少文件大小。\n包体积-三方库优化\n组件二进制化：将第三方pod库或自己项目中的业务库由代码格式打包成framework格式，提高编译速度并减小安装包体积。可以使用cocoapods-packager、cocoapods-binary等工具来实现。\n定期更新第三方库：定期检查项目中使用的第三方库是否有更新版本，新版本可能包含性能改进和体积优化。\n\n","categories":["性能优化"],"tags":["性能优化","包体积"]},{"title":"内存管理","url":"/2025/05/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"内存管理引用计数iOS的Objective-C和Swift运行时使用引用计数来管理对象的生命周期。新建对象时引用计数+1，指针指向对象时+1，指针不再指向对象时-1，当引用计数为0时对象被销毁。\nTaggedPointer为小型数据（如NSNumber、NSDate、NSString等）提供的一种内存节省技术。TaggedPointer是一个特别的指针，它分为两部分：一部分直接保存数据，另一部分作为特殊标记。TaggedPointer是一种特别的指针，用于存储小型数据，以减少内存占用。它分为数据部分和标记部分，不指向任何实际的内存地址。\nARC与MRC的区别ARC（自动引用计数）是iOS 5及之后版本引入的一种编译器特性，自动管理对象的生命周期，减少了内存泄漏和野指针的风险。ARC下，开发者不再需要手动调用retain、release、autorelease等内存管理方法。\nMRC（手动引用计数）在ARC之前，开发者需要手动管理对象的内存，通过retain、release、autorelease等方法来控制对象的生命周期。\nSideTables和SideTableSideTables是一个包含8个SideTable的哈希数组，用于存储对象的引用计数和弱引用信息。每个SideTable对应多个对象。\nSideTable包含三个主要成员：自旋锁（spinlockt）、引用计数表（RefcountMap）、弱引用表（weaktable_t）。自旋锁用于防止多线程访问冲突，引用计数表存储对象的引用计数，弱引用表存储对象的弱引用信息。\nweak_table_t和weak_entry_t\nweak_table_t是一个存储弱引用信息的哈希表，其元素是weak_entry_t类型。\nweak_entry_t存储了弱引用该对象的指针的指针，即objc_object new_referrer。当对象被销毁时，weak引用的指针会被自动置为nil，防止野指针的出现。\n相关提案和技术演进\n相关提案包括 SE-0349 Unaligned Loads and Stores from Raw Memory 、SE-0334 Pointer API Usability Improvements 、SE-0333 Expand usability of withMemoryRebound\nSet 使用新的 Temporary Buffers 功能，让 intersect 速度提升了 4 到 6 倍。\n自动引用计数(ARC)机制ARC 是 Swift 用来管理应用程序内存的技术，它会自动跟踪和管理你的应用程序使用的内存，不需要开发者手动分配或释放内存。\nARC 的基本原理ARC 在对象的生命周期内自动管理内存的分配与释放。每当你创建一个类的实例时，ARC 会为这个实例分配内存，并在不再需要它时自动释放内存。ARC 通过维护一个“引用计数”来决定对象的生命周期：每次引用增加时计数加一，每次引用减少时计数减一。当引用计数为零时，ARC 会自动释放对象所占的内存。\n强引用、弱引用和无主引用ARC 的核心在于管理引用类型变量之间的强引用（strong reference）。强引用意味着只要对象被某个变量持有，引用计数就不会为零，对象也就不会被释放。然而，如果两个对象之间形成了强引用循环（即两个对象互相引用），ARC 将无法自动释放它们，导致内存泄漏。\n为了解决强引用循环的问题，Swift 引入了弱引用（weak reference）和无主引用（unowned reference）。弱引用不增加对象的引用计数，当对象被释放时，弱引用会自动变为 nil。无主引用则是一种非可选类型引用，当对象被释放时，无主引用不会变为 nil，但如果访问已经被释放的对象则会导致运行时错误。因此，无主引用通常用于对象生命周期一致的情况下，而弱引用则适用于对象可能会独立释放的情况。\n循环引用的示例与解决方案当两个类互相持有对方的强引用时，会导致循环引用问题，导致内存无法正确释放。这类问题通常发生在闭包与类实例之间。为了打破这种循环引用，可以在闭包中使用捕获列表（capture list）将闭包中的引用声明为弱引用或无主引用。\nimport SwiftUIclass Element &#123;    let title: String    let description: String?        lazy var convertToWeb: () -&gt; String = &#123; [unowned self] in        if let description = self.description &#123;            return &quot;&lt;div class=&#x27;line&#x27;&gt;&lt;h2&gt;\\(self.title)&lt;/h2&gt;&lt;p&gt;\\(description)&lt;/p&gt;&lt;/div&gt;&quot;        &#125; else &#123;            return &quot;&lt;div class=&#x27;line&#x27;&gt;&lt;h2&gt;\\(self.title)&lt;/h2&gt;&lt;/div&gt;&quot;        &#125;    &#125;        init(title: String, description: String? = nil) &#123;        self.title = title        self.description = description    &#125;        deinit &#123;        print(&quot;\\(title) is being deinitialized&quot;)    &#125;&#125;struct ContentView: View &#123;    @State private var elm: Element? = Element(title: &quot;Inception&quot;, description: &quot;A mind-bending thriller by Christopher Nolan.&quot;)        var body: some View &#123;        VStack &#123;            if let html = elm?.convertToWeb() &#123;                Text(html)                    .padding()                    .background(Color.yellow)                    .cornerRadius(10)            &#125;            Button(&quot;Clear&quot;) &#123;                elm = nil            &#125;            .padding()            .background(Color.red)            .foregroundColor(.white)            .cornerRadius(10)        &#125;        .padding()    &#125;&#125;\n在这个示例中，convertToWeb 是一个闭包，使用了 [unowned self] 捕获列表，以避免闭包与 Element 实例之间的强引用循环。\n闭包中的循环引用闭包是一种在 Swift 中广泛使用的功能，但由于闭包会捕获它们使用的任何外部变量，可能会引入循环引用。为了防止这种情况发生，Swift 提供了捕获列表，使你可以显式指定在闭包中如何捕获外部变量（如使用 weak 或 unowned 关键字）。\niOS虚拟内存可以通过ADRP（Address Relative to Page）汇编指令找到特定符号在虚拟内存中的地址。ADRP（Address Relative to Page）是ARM架构中用于计算地址的汇编指令，其作用是计算一个标签（label）或符号相对于当前页面基地址的偏移量，并将这个偏移量乘以页面大小（通常为4KB，即0x1000）后的结果存储到指定的寄存器中。这一指令在处理大范围的内存地址时非常有用，尤其是在虚拟内存环境中，可以有效减少地址计算所需的指令数量。\niOS中的地址空间布局随机化（ASLR, Address Space Layout Randomization）技术。虚拟内存是现代操作系统为了提供更大内存空间、实现内存保护和管理而采用的一种技术。它将物理内存与逻辑内存（即用户视角的内存）分离，通过分页机制（Paging）实现。ASLR则是一种安全特性，它通过在程序加载时随机化代码和数据在内存中的位置，来增加攻击者预测和利用内存地址的难度。\n在iOS中，ASLR会导致每次启动App时，App的虚拟内存地址都会发生变化。这就使得在调试过程中，需要通过一些技巧来获取符号的真实地址。其中，一种常用的方法是通过ADRP指令来计算符号的虚拟内存地址。\n在ARM64汇编中，ADRP指令的格式如下：\nADRP Xd, label\n其中，Xd是目标寄存器，label是一个符号的地址。\nADRP指令的作用是将一个符号的地址的高20位加载到寄存器中，然后通过ADD指令将低12位加上去。这样就可以得到一个符号的虚拟内存地址。\n在LLDB中，可以通过image list命令查看当前App的ASLR偏移量，然后通过image lookup -n命令查看目标符号的地址。在GDB中，可以通过info sharedlibrary命令查看当前App的ASLR偏移量，然后通过info address命令查看目标符号的地址。\n在iOS的Mach-O文件中，符号（如类名、函数名等）的地址在编译链接阶段就已经确定，但在程序运行时可能会受到ASLR的影响而发生变化。然而，在Mach-O文件中直接查看时，这些地址是不包含ASLR偏移量的。因此，为了获取符号在运行时的真实地址，需要通过ADRP指令计算出符号的虚拟内存地址，然后再加上ASLR偏移量。\nSwift内存安全性及其实现机制Swift 通过确保内存的“独占访问”（Exclusive Access）来避免常见的内存安全问题，例如数据竞争（Data Race）和未定义行为（Undefined Behavior）。在 Swift 中，内存的访问方式被严格控制，尤其是在对变量进行读写时，系统会确保在一个时间点上，只有一个代码段可以对该内存进行修改。这一设计通过限制变量的访问方式和时间，极大程度上避免了内存冲突。\n内存安全的重要性内存安全是指在编程中确保内存的正确访问和管理，以避免常见的错误，如越界访问、使用已释放的内存或并发访问导致的数据损坏等。Swift 作为一种现代编程语言，通过其设计和编译时检查，实现了内存安全的目标。\n独占访问的概念Swift 如何通过独占访问机制来实现内存安全。当变量正在被一个代码段修改时，Swift 不允许其他代码段同时访问该变量的内存地址。Swift 强制执行这一规则，即使在单线程环境中也不例外。通过这种方式，Swift 有效避免了数据竞争和未定义行为。\n在 Swift 中，内存的访问被分为读访问和写访问。读访问是指读取变量的值，而写访问是指修改变量的值。Swift 允许多个读访问同时发生，但在写访问期间，任何其他访问（无论是读还是写）都会导致冲突，从而触发编译错误。\n访问冲突的具体示例Swift 中可能导致内存访问冲突的情况。一个常见的例子是，当一个函数在执行时同时访问同一变量，且该变量的某些属性正在被修改，这种情况下就会产生冲突。例如：\nfunc adjustRatings(_ rating1: inout Int, _ rating2: inout Int) &#123;    let total = rating1 + rating2    rating1 = total / 2    rating2 = total - rating1&#125;var movieRating = 85adjustRatings(&amp;movieRating, &amp;movieRating)\n在这个示例中，adjustRatings(&amp;movieRating, &amp;movieRating) 试图同时修改 movieRating 的两个属性，这在 Swift 中会触发编译错误，因为这种情况下无法保证内存的独占访问。\n结构体的内存访问Swift 中结构体的内存管理。与类不同，结构体是值类型，这意味着它们的每一个实例都有自己独立的内存空间。因此，对结构体的访问也需要遵守独占访问规则。特别是在结构体内部有多个属性时，Swift 会确保在修改一个属性时，其他属性不会被同时访问。\n内存访问的例外情况\n尽管 Swift 对内存访问进行了严格的控制，但也有一些例外情况。在某些情况下，Swift 会允许非独占访问，例如全局变量和静态变量。这些变量的生命周期与程序一致，通常不会发生数据竞争，因此 Swift 对它们的访问控制相对宽松。\nSwift 的内存安全与性能尽管 Swift 的内存安全机制确保了程序的稳定性，但它也带来了一定的性能开销。如何在不牺牲安全性的前提下优化程序性能。例如，通过在合适的场景下使用 inout 参数，开发者可以在保留独占访问的同时，减少不必要的内存复制。\nSwift内存操作Swift 编程语言中进行不安全内存操作的技术和注意事项。Swift 通常通过引用计数和内存自动管理来保证内存安全，然而在某些高性能或特定底层操作中，开发者可能需要直接操作内存。这时就需要使用到 Swift 的 Unsafe 系列指针类型，例如 UnsafeMutablePointer 和 UnsafePointer。\nUnsafePointer 是一个指向某种类型的指针，它允许只读访问内存地址上的数据。这意味着你可以读取该地址的数据但不能修改它。相反，UnsafeMutablePointer 允许你修改指针指向的内存区域内的数据。使用 UnsafeMutablePointer 修改内存时，必须确保内存已经正确地分配且不会被其他代码同时访问。否则，可能会导致程序崩溃或出现难以调试的问题。Swift 提供的一些辅助工具 withUnsafePointer(to::) 和 withUnsafeMutablePointer(to::)，它们可以在有限的范围内确保内存操作的安全性。这些函数的使用可以帮助开发者避免一些常见的错误，确保指针的生命周期和作用域受到控制。\n内存分配器libMalloclibMallociOS底层堆内存分配器libMallociOS底层堆内存分配器libMalloc，libMalloc是iOS系统中广泛使用的内存分配器，提供高效的内存管理策略。学习libMalloc源码有助于深入理解iOS内存管理机制，优化内存使用效率。\nZone是libMalloc管理内存的基础单元，负责处理内存分配、释放等操作。常见的内存操作API（如malloc、free、realloc）均通过Zone实现。Zone的核心数据结构，包含多个函数指针，分别对应不同的内存操作函数。如size、malloc、calloc、valloc、free、realloc等，分别处理内存块的大小查询、分配、释放等操作。reserved1和reserved2，用于保留给CFAllocator使用，用户不应直接访问。通过malloc_zone_register_while_locked函数将Zone注册到全局Zone列表中。在内存分配时，根据配置和当前状态选择合适的Zone进行处理。\ndefault_zone是libMalloc默认使用的Zone，通过runtime_default_zone()函数获取。default_zone的实际逻辑可能由scalable_zone或nano_zone等具体Zone实现。\nscalable_zone是处理大多数内存分配请求的默认Zone。根据内存大小，采用tiny、small、medium、large四种不同策略进行管理。szone_t，扩展自malloc_zone_t，包含tiny、small、medium策略的相关数据结构和large策略的管理字段。对于大块内存的分配，系统可能选择scalable zone，该zone具有更好的扩展性和灵活性。\nnano_zone专门用于管理小内存（如256字节以下）的Zone，以提高小内存分配的效率。提供了V1和V2两个版本的实现，V2版本在性能和管理逻辑上进行了优化。通过nanov2_create_zone函数创建并初始化nano_zone。nano_zone_t是nano zone的具体实现，包含malloc_zone_t基础结构和额外的内存管理信息。该函数负责创建nano zone，并对malloc_zone_t中的函数指针进行重新赋值，以使用nano zone特有的内存分配策略。nano_calloc函数根据请求的内存大小选择直接在nano zone中分配或回退到helper zone进行分配。当nano zone无法满足内存分配请求时，会回退到helper zone进行分配。nano zone中的内存分配会进行16字节对齐，以提高内存访问效率。nano zone通过维护一个高效的缓存机制来减少内存分配和释放的开销。系统提供了调试和日志记录功能，帮助开发者跟踪内存分配和释放的过程，以便发现和解决内存泄漏等问题。\nmalloc_zone_t是一个包含多个函数指针的结构体，用于存储内存分配、释放等操作的实现地址。包括malloc、calloc、free、realloc等函数指针，这些函数指针指向具体的内存管理函数实现。包含两个reserved字段，供CFAllocator使用，开发者不应直接访问。\ncalloc函数通过调用malloc_zone_calloc函数来分配内存，并将分配的内存清零。default_zone是一个特殊的zone，用于引导程序进入创建真正zone的流程。根据系统配置和内存需求，选择nano zone或scalable zone进行内存分配。\nmalloc_zone_register_while_locked该函数用于为zone设置名称，便于调试和日志记录中识别不同的zone。通过zone名称，开发者可以更容易地跟踪和定位内存分配和释放的问题。\n系统内容分配方式CPU 通常有内核态和用户态两种运行模式，内核态拥有更高的权限，可以访问系统资源，而用户态只能访问受限资源。系统内存分配方式通常包括内核态和用户态两种，内核态分配由内核管理，用户态分配由用户程序管理。\n程序通过系统调用（System Call）从用户态向内核态传递信息，请求操作系统服务，如打开文件、网络通信等。内核态内存分配通常由内核管理，内核通过内存管理单元（MMU）管理内存映射、分页等操作，确保内存分配的安全性和有效性。\nC语言标准库提供了对系统调用的封装，使程序员编写的程序能跨平台运行，无需修改底层代码。C标准库中的malloc、free等函数封装了内核态的内存分配和释放操作，提供了用户态内存管理的接口。堆区用于动态内存分配，栈区用于函数调用的局部变量等。两者之间的空白区域允许栈区增长。\nmalloc是标准库中的内存分配函数，负责在堆区搜索并分配空闲内存块。当malloc内部管理的空闲内存不足时，会通过系统调用（如brk或mmap）向操作系统请求扩大堆区。系统调用完成后，malloc返回的是虚拟内存地址，物理内存的分配在实际使用时才发生。\n进程看到的内存是操作系统提供的虚拟内存，与物理内存不完全对应。当程序首次访问新申请的内存时，缺页中断发生，操作系统分配物理内存并完成映射。\n频繁调用malloc会影响系统性能，特别是在高性能程序中。理解内存申请的复杂性有助于选择合适的内存分配器，优化内存使用策略，减少不必要的内存分配。\n","categories":["性能优化"],"tags":["性能优化","内存管理"]},{"title":"卡死崩溃监控","url":"/2025/05/09/%E5%8D%A1%E6%AD%BB%E5%B4%A9%E6%BA%83%E7%9B%91%E6%8E%A7/","content":"问题概述iOS系统中App卡死崩溃问题无成熟解决方案，因iOS封闭生态，App层面无权限获取卡死崩溃日志。用户通常不会等待卡死超过20s，且手动关闭应用不生成日志，导致监控困难。基于卡顿监控，但难以区分轻微卡顿与严重卡死，且性能损耗大，存在误导性。\n崩溃日志格式，如Exception Type: EXC_CRASH (SIGKILL)等，指出App因watchdog超时而被终止。watchdog崩溃定义是App启动、退出或响应系统事件时耗时过长，被系统强制结束。\n监控原理注册runloop观察者，检测耗时，记录调用栈，上报后台分析。长时间卡顿后，若未进入下一个活跃状态，则标记为卡死崩溃上报。\n以下是一个 iOS 卡死监控的代码示例：\n#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;execinfo.h&gt;#import &lt;sys/time.h&gt;// 定义 Runloop 模式的枚举typedef enum &#123;    eRunloopDefaultMode,  // 默认模式    eRunloopTrackingMode  // 追踪模式&#125; RunloopMode;// 全局变量，用于记录 Runloop 的活动状态和模式static CFRunLoopActivity g_runLoopActivity;static RunloopMode g_runLoopMode;static BOOL g_bRun = NO;  // 标记 Runloop 是否在运行static struct timeval g_tvRun;  // 记录 Runloop 开始运行的时间// HangMonitor 类，用于监控卡死情况@interface HangMonitor : NSObject@property (nonatomic, assign) CFRunLoopObserverRef runLoopBeginObserver;  // Runloop 开始观察者@property (nonatomic, assign) CFRunLoopObserverRef runLoopEndObserver;    // Runloop 结束观察者@property (nonatomic, strong) dispatch_semaphore_t semaphore;  // 信号量，用于同步@property (nonatomic, assign) NSTimeInterval timeoutInterval;  // 超时时间- (void)addRunLoopObserver;  // 添加 Runloop 观察者的方法- (void)startMonitor;  // 启动监控的方法- (void)logStackTrace;  // 记录调用栈的方法- (void)reportHang;  // 上报卡死的方法@end@implementation HangMonitor// 单例模式，确保 HangMonitor 只有一个实例+ (instancetype)sharedInstance &#123;    static HangMonitor *instance;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        instance = [[HangMonitor alloc] init];    &#125;);    return instance;&#125;// 初始化方法- (instancetype)init &#123;    self = [super init];    if (self) &#123;        _timeoutInterval = 8.0;  // 设置超时时间为8秒        _semaphore = dispatch_semaphore_create(0);  // 创建信号量        [self addRunLoopObserver];  // 添加 Runloop 观察者        [self startMonitor];  // 启动监控    &#125;    return self;&#125;// 添加 Runloop 观察者的方法- (void)addRunLoopObserver &#123;    NSRunLoop *curRunLoop = [NSRunLoop currentRunLoop];  // 获取当前 Runloop    // 创建第一个观察者，监控 Runloop 是否处于运行状态    CFRunLoopObserverContext context = &#123;0, (__bridge void *) self, NULL, NULL, NULL&#125;;    CFRunLoopObserverRef beginObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, LONG_MIN, &amp;myRunLoopBeginCallback, &amp;context);    CFRetain(beginObserver);  // 保留观察者，防止被释放    self.runLoopBeginObserver = beginObserver;    // 创建第二个观察者，监控 Runloop 是否处于睡眠状态    CFRunLoopObserverRef endObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, LONG_MAX, &amp;myRunLoopEndCallback, &amp;context);    CFRetain(endObserver);  // 保留观察者，防止被释放    self.runLoopEndObserver = endObserver;    // 将观察者添加到当前 Runloop 中    CFRunLoopRef runloop = [curRunLoop getCFRunLoop];    CFRunLoopAddObserver(runloop, beginObserver, kCFRunLoopCommonModes);    CFRunLoopAddObserver(runloop, endObserver, kCFRunLoopCommonModes);&#125;// 第一个观察者的回调函数，监控 Runloop 是否处于运行状态void myRunLoopBeginCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;    HangMonitor *monitor = (__bridge HangMonitor *)info;    g_runLoopActivity = activity;  // 更新全局变量，记录当前的 Runloop 活动状态    g_runLoopMode = eRunloopDefaultMode;  // 更新全局变量，记录当前的 Runloop 模式    switch (activity) &#123;        case kCFRunLoopEntry:            g_bRun = YES;  // 标记 Runloop 进入运行状态            break;        case kCFRunLoopBeforeTimers:        case kCFRunLoopBeforeSources:        case kCFRunLoopAfterWaiting:            if (g_bRun == NO) &#123;                gettimeofday(&amp;g_tvRun, NULL);  // 记录 Runloop 开始运行的时间            &#125;            g_bRun = YES;  // 标记 Runloop 处于运行状态            break;        case kCFRunLoopAllActivities:            break;        default:            break;    &#125;    dispatch_semaphore_signal(monitor.semaphore);  // 发送信号量&#125;// 第二个观察者的回调函数，监控 Runloop 是否处于睡眠状态void myRunLoopEndCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;    HangMonitor *monitor = (__bridge HangMonitor *)info;    g_runLoopActivity = activity;  // 更新全局变量，记录当前的 Runloop 活动状态    g_runLoopMode = eRunloopDefaultMode;  // 更新全局变量，记录当前的 Runloop 模式    switch (activity) &#123;        case kCFRunLoopBeforeWaiting:            gettimeofday(&amp;g_tvRun, NULL);  // 记录 Runloop 进入睡眠状态的时间            g_bRun = NO;  // 标记 Runloop 进入睡眠状态            break;        case kCFRunLoopExit:            g_bRun = NO;  // 标记 Runloop 退出运行状态            break;        case kCFRunLoopAllActivities:            break;        default:            break;    &#125;    dispatch_semaphore_signal(monitor.semaphore);  // 发送信号量&#125;// 启动监控的方法- (void)startMonitor &#123;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;        while (YES) &#123;            long result = dispatch_semaphore_wait(self.semaphore, dispatch_time(DISPATCH_TIME_NOW, self.timeoutInterval * NSEC_PER_SEC));            if (result != 0) &#123;                if (g_runLoopActivity == kCFRunLoopBeforeSources || g_runLoopActivity == kCFRunLoopAfterWaiting) &#123;                    [self logStackTrace];  // 记录调用栈                    [self reportHang];  // 上报卡死                &#125;            &#125;        &#125;    &#125;);&#125;// 记录调用栈的方法- (void)logStackTrace &#123;    void *callstack[128];    int frames = backtrace(callstack, 128);    char **strs = backtrace_symbols(callstack, frames);    NSMutableString *stackTrace = [NSMutableString stringWithString:@&quot;\\n&quot;];    for (int i = 0; i &lt; frames; i++) &#123;        [stackTrace appendFormat:@&quot;%s\\n&quot;, strs[i]];    &#125;    free(strs);    NSLog(@&quot;%@&quot;, stackTrace);&#125;// 上报卡死的方法- (void)reportHang &#123;    // 在这里实现上报后台分析的逻辑    NSLog(@&quot;检测到卡死崩溃，进行上报&quot;);&#125;@end// 主函数，程序入口int main(int argc, char * argv[]) &#123;    @autoreleasepool &#123;        HangMonitor *monitor = [HangMonitor sharedInstance];  // 获取 HangMonitor 单例        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));  // 启动应用程序    &#125;&#125;\n这段代码中 HangMonitor 类会在主线程的 RunLoop 活动中检测是否有长时间的卡顿，并在检测到卡顿时记录调用栈并上报后台进行分析。超时时间设定为 8 秒，以覆盖大部分用户感知场景并减少性能损耗。\n","categories":["性能优化"],"tags":["性能优化","卡顿监控"]},{"title":"卡顿原因","url":"/2025/05/09/%E5%8D%A1%E9%A1%BF%E5%8E%9F%E5%9B%A0/","content":"概述iOS开发中，由于UIKit的非线程安全性，所有UI操作必须在主线程执行。系统每16ms（1&#x2F;60帧）重绘UI至屏幕。若主线程进行耗时操作或发生死锁，会阻碍UI刷新，导致卡顿甚至卡死。主线程基于Runloop机制处理任务，Runloop支持多种事件回调，包括事件进入、处理前后等时机。若主线程在任一环节被阻塞，会导致UI和交互都无法进行，这是卡死、卡顿的根本原因。\n线程和锁线程和锁的使用是导致卡死的主要原因，常见问题包括：\n\n死锁问题：如dispatch_once中同步访问主线程导致的死锁。\n锁竞争：子线程占用锁资源导致主线程卡死。\n磁盘IO密集：主线程磁盘IO耗时过长。\n跨进程通信：如UIPasteBoard、NSUserDefaults等导致的卡死。\nOC方法调用死锁：如dyld lock、selector lock和OC runtime lock互相等待。\n\n同步原语同步原语（synchronization primitive）会阻塞读写任务执行。以下是iOS中常用的会阻塞读写任务执行的同步原语：\n锁（Locks）\nNSLock\n基本的互斥锁，用于保护临界区，确保同一时间只有一个线程访问资源。\n示例：\n\n  NSLock *lock = [[NSLock alloc] init];[lock lock];// 访问共享资源[lock unlock];\nNSRecursiveLock\n递归锁，允许同一个线程多次获取锁，适用于需要递归调用的场景。\n示例：\n\n  NSRecursiveLock *recursiveLock = [[NSRecursiveLock alloc] init];[recursiveLock lock];// 递归访问共享资源[recursiveLock unlock];\nNSCondition\n条件锁，结合互斥锁和条件变量，可用于线程之间的等待和通知机制。\n示例：\n\n  NSCondition *condition = [[NSCondition alloc] init];[condition lock];// 等待某个条件[condition wait];// 条件满足后继续执行[condition unlock];\nNSConditionLock\n带有条件的锁，可以基于条件值来锁定和解锁。\n示例：\n\n  NSConditionLock *conditionLock = [[NSConditionLock alloc] initWithCondition:0];[conditionLock lockWhenCondition:1];// 访问共享资源[conditionLock unlockWithCondition:0];\n\nGCD（Grand Central Dispatch）\n信号量（Dispatch Semaphore）\n用于控制同时访问特定资源的线程数量，可以用于实现简单的锁机制。\n示例：\n\n  let semaphore = DispatchSemaphore(value: 1)semaphore.wait()// 访问共享资源semaphore.signal()\n屏障（Dispatch Barrier）\n用于在并发队列中创建同步点，确保在屏障之前的任务完成后，再执行屏障任务，屏障任务完成后，才继续执行后续任务。\n示例：\n\n  let concurrentQueue = DispatchQueue(label: &quot;com.example.queue&quot;, attributes: .concurrent)concurrentQueue.async(flags: .barrier) &#123;    // 写操作，确保独占访问&#125;\n\nPOSIX 线程（pthread）\n读写锁（pthread_rwlock_t）\n\n允许多个线程同时读，或者一个线程写，适用于读多写少的场景。\n示例：\n\n  pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;// 读锁pthread_rwlock_rdlock(&amp;rwlock);// 读取共享资源pthread_rwlock_unlock(&amp;rwlock);// 写锁pthread_rwlock_wrlock(&amp;rwlock);// 写入共享资源pthread_rwlock_unlock(&amp;rwlock);\n\n互斥锁（pthread_mutex_t）\n\n基本的互斥锁，类似于NSLock。\n示例：\n\n  pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_lock(&amp;mutex);// 访问共享资源pthread_mutex_unlock(&amp;mutex);\n\nObjective-C 的 @synchronized 指令\n@synchronized\n语法糖，用于在Objective-C中创建互斥锁，保护代码块。\n示例：\n\n  @synchronized(self) &#123;    // 访问共享资源&#125;\n\n低级锁\nos_unfair_lock\n低级别的锁，替代了过时的OSSpinLock，适用于需要高性能的锁场景。\n示例：\n\n  var unfairLock = os_unfair_lock()os_unfair_lock_lock(&amp;unfairLock)// 访问共享资源os_unfair_lock_unlock(&amp;unfairLock)\n\n原子属性\n原子性属性（Atomic Properties）\n在Objective-C中，通过设置属性为atomic，编译器会自动生成线程安全的访问器，内部使用锁机制确保原子性。\n示例：\n\n  @property (atomic, strong) NSString *name;\n\n高层次抽象\nNSOperationQueue 和 操作依赖（Dependencies）\n虽然不是直接的锁机制，但通过设置操作的依赖关系，可以控制任务的执行顺序，间接实现同步。\n示例：\n\n  NSOperationQueue *queue = [[NSOperationQueue alloc] init];NSOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;    // 任务1&#125;];NSOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;    // 任务2，依赖任务1&#125;];[op2 addDependency:op1];[queue addOperations:@[op1, op2] waitUntilFinished:NO];\n\nSwift 并发（Swift Concurrency）\nActors\n在Swift 5.5及以上版本中引入的Actor模型，用于保护数据，确保同一时间只有一个任务可以访问其内部状态。\n示例：\n\n  actor MyActor &#123;    var value: Int = 0        func increment() &#123;        value += 1    &#125;&#125;let myActor = MyActor()Task &#123;    await myActor.increment()&#125;\n\n这些同步原语各有优缺点，选择合适的同步机制取决于具体的应用场景。例如，pthread_rwlock_t适用于读多写少的情况，而NSLock或@synchronized则适用于简单的互斥需求。GCD的信号量和屏障则提供了更高层次的并发控制手段。\nCPU 负载CPU 负载过重也会导致耗时长，CPU主要负责用户交互的处理，如果能够将运算转移到 GPU 上，CPU 就可以更轻松的处理来自用户的交互。比如可以通过使用 CoreAnimation 中 layer.cornerRadius 属性和 masksToBounds 属性替代圆角图片、使用 CoreGraphics 绘制图形替代图片、使用 CoreAnimation 绘制动画替代 UIView 动画等方式优化性能。\n以下是一些常见的方法和技术，可以在iOS中将计算任务从CPU转移到GPU：\nMetal 框架\nMetal 是苹果为iOS和macOS提供的底层图形和计算API，它允许开发者直接访问GPU来执行图形渲染和并行计算任务。\n使用场景包括：\n渲染3D图形：Metal提供高效的图形渲染功能，比OpenGL ES更高效。\n图像处理：可以使用Metal编写自定义着色器（Shaders）进行实时图像处理，如滤镜应用、视频处理等。\n并行计算：通过Metal的计算管线（Compute Pipeline），可以编写计算着色器（Compute Shaders）在GPU上执行大量并行计算任务，如物理模拟、数据分析等。\n示例代码：\n\n  // 使用Metal进行简单的计算操作let device = MTLCreateSystemDefaultDevice()let commandQueue = device?.makeCommandQueue()let shaderLibrary = device?.makeDefaultLibrary()let computeFunction = shaderLibrary?.makeFunction(name: &quot;computeShader&quot;)let computePipelineState = try? device?.makeComputePipelineState(function: computeFunction!)\n\nCore Image\nCore Image 是一个强大的图像处理框架，内置了许多优化的滤镜（Filters），并能够自动将图像处理任务分配到GPU上执行。\n通过Core Image，你可以非常容易地进行图像增强、滤镜应用、面部识别等，而这些操作都会尽量在GPU上执行，以减轻CPU的负担。\n示例代码：\n\nlet ciImage = CIImage(image: inputImage)let filter = CIFilter(name: &quot;CISepiaTone&quot;)filter?.setValue(ciImage, forKey: kCIInputImageKey)filter?.setValue(0.8, forKey: kCIInputIntensityKey)let outputImage = filter?.outputImage\n\nCore Animation\nCore Animation 是iOS的高效动画框架，它会将大部分动画的执行过程自动转移到GPU上。这包括视图的平移、缩放、旋转、淡入淡出等基本动画效果。\n通过使用CALayer和各种动画属性（如position、transform等），你可以创建平滑的动画，这些动画将在GPU上硬件加速执行。\n示例代码：\n\nlet layer = CALayer()layer.position = CGPoint(x: 100, y: 100)let animation = CABasicAnimation(keyPath: &quot;position&quot;)animation.toValue = CGPoint(x: 200, y: 200)animation.duration = 1.0layer.add(animation, forKey: &quot;positionAnimation&quot;)\n\nSpriteKit 和 SceneKit\nSpriteKit 和 SceneKit 是两个高层次的框架，分别用于2D和3D游戏开发。它们内部利用GPU进行图形渲染和物理模拟，极大地减少了CPU的负担。\nSpriteKit 用于2D游戏，可以通过简单的代码创建和渲染复杂的场景。\nSceneKit 用于3D游戏，支持光照、阴影、物理引擎等高级特性，这些都在GPU上进行计算。\n示例代码：\n\nlet scene = SKScene(size: CGSize(width: 1024, height: 768))let spriteNode = SKSpriteNode(imageNamed: &quot;Spaceship&quot;)spriteNode.position = CGPoint(x: scene.size.width/2, y: scene.size.height/2)scene.addChild(spriteNode)\n\nOpenGL ES\n虽然OpenGL ES已经被Metal取代为主要的图形API，但它仍然可以用于将图形渲染任务转移到GPU上。使用OpenGL ES，开发者可以编写自定义着色器，并在GPU上执行图形渲染。\n示例代码：\n\n// 创建OpenGL ES上下文EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];[EAGLContext setCurrentContext:context];\nCore Graphics (Quartz 2D)\nCore Graphics 虽然主要在CPU上执行，但是在一些情况下，特别是当使用硬件加速的绘图操作时（如在UIView上进行绘图操作），系统会自动将部分绘图操作转移到GPU上。\nCore Graphics主要用于绘制矢量图形、处理图像、渲染文本等。\n\nVideoToolbox\nVideoToolbox 是一个用于硬件加速的视频编码、解码的框架。通过使用VideoToolbox，可以将视频编解码任务转移到GPU上，从而大大减轻CPU的压力，尤其在处理高清视频时效果显著。\n示例代码：\n\nvar videoSession: VTDecompressionSession?VTDecompressionSessionCreate(nil, formatDescription, nil, nil, nil, &amp;videoSession)\n\nAccelerate 框架\nAccelerate 框架包含了一组高度优化的数学计算函数库，包括向量运算、矩阵运算、FFT（快速傅里叶变换）等。虽然主要在CPU上运行，但在某些情况下（如使用vImage），可以通过Metal Performance Shaders (MPS)将部分计算任务转移到GPU上。\n\n磁盘 IO 过于密集磁盘 IO 过于密集可能会导致应用程序卡顿，这是因为磁盘操作通常是阻塞性的，尤其是在读取或写入大量数据时。为了缓解这一问题，可以将磁盘 IO 操作放到后台线程中执行，避免阻塞主线程。这时，Swift Concurrency 技术（如 async&#x2F;await 和 Task）可以派上用场。\n下面是一个使用 SwiftUI 和 Swift Concurrency 处理磁盘 IO 的示例代码。这个例子展示了如何在后台线程中执行磁盘读取操作，并将结果更新到 UI 上。\nimport SwiftUIstruct ContentView: View &#123;    @State private var data: String = &quot;Loading...&quot; // `data` 用于存储从磁盘读取的数据，并在 UI 中显示。        var body: some View &#123;        VStack &#123;            Text(data)                .padding()            Button(&quot;Load Data&quot;) &#123;                loadData()            &#125;        &#125;    &#125;        func loadData() &#123;        // 通过 `Task` 创建一个并发上下文来运行异步代码块。在这个代码块中执行耗时的磁盘 IO 操作。        Task &#123;            // 在后台执行磁盘 IO 操作            let loadedData = await performDiskIO()            // 在主线程更新 UI            await MainActor.run &#123;                data = loadedData            &#125;        &#125;    &#125;        // 模拟一个磁盘 IO 操作，可能是从文件中读取大数据    func performDiskIO() async -&gt; String &#123;        // 模拟磁盘操作耗时        try? await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds delay                // 这里可以进行实际的磁盘读取操作        // 例如读取文件内容：        // let fileURL = ...        // let data = try? String(contentsOf: fileURL)                return &quot;Data Loaded Successfully!&quot;    &#125;&#125;@mainstruct DiskIOApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()        &#125;    &#125;&#125;\n\n跨进程通信导致卡顿进程间通信（IPC）是一种重要的机制，它允许不同的进程或应用程序之间交换信息。然而，某些系统API的调用可能会导致卡顿或性能问题，特别是在以下几种情况下：\nCNCopyCurrentNetworkInfo 获取 WiFi 信息CNCopyCurrentNetworkInfo 用于获取当前的 WiFi 网络信息。由于它涉及到与系统的网络服务交互，可能会导致性能问题，特别是在频繁调用时。\n#import &lt;SystemConfiguration/CaptiveNetwork.h&gt;NSDictionary *networkInfo = (__bridge NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)@&quot;en0&quot;);NSLog(@&quot;Network Info: %@&quot;, networkInfo);\n在获取 WiFi 信息时，如果调用频繁，可能会对性能产生负面影响。\n设置系统钥匙串 (Keychain) 中的值钥匙串用于存储敏感数据，如密码。操作钥匙串通常涉及加密操作，这可能会导致一定的性能开销，特别是在操作较多或数据较大时。\n#import &lt;Security/Security.h&gt;NSString *service = @&quot;com.example.myapp&quot;;NSString *account = @&quot;user@example.com&quot;;NSString *password = @&quot;password123&quot;;NSDictionary *query = @&#123;    (id)kSecClass: (id)kSecClassGenericPassword,    (id)kSecAttrService: service,    (id)kSecAttrAccount: account,    (id)kSecValueData: [password dataUsingEncoding:NSUTF8StringEncoding]&#125;;SecItemAdd((__bridge CFDictionaryRef)query, NULL); // 添加或更新钥匙串项\n\nNSUserDefaults 调用写操作使用 NSUserDefaults 造成的跨进程通信导致的卡顿，可以使用 Swift Concurrency 来实现一个轻量级的键值存储方案，利用 Swift 的 async&#x2F;await 来处理并发操作。以下是一个使用 Swift 和 SwiftUI 的可运行示例，展示了如何实现和使用一个基于 Swift Concurrency 的轻量级键值存储类。\n轻量级 UserDefaults 替代实现\nimport Foundation// `LightweightUserDefaults` 类是一个 `actor`，用于确保其内部状态在并发环境中是安全的。`actor` 会自动处理并发的访问，因此不需要手动使用锁或队列。actor LightweightUserDefaults &#123;    private var storage: [String: Any] = [:]    func set(_ value: Any?, forKey key: String) async &#123;        if let value = value &#123;            storage[key] = value        &#125; else &#123;            storage.removeValue(forKey: key)        &#125;    &#125;    func value(forKey key: String) async -&gt; Any? &#123;        return storage[key]    &#125;    func removeValue(forKey key: String) async &#123;        storage.removeValue(forKey: key)    &#125;&#125;\nSwiftUI 示例\nimport SwiftUI// 通过按钮调用异步方法将用户输入存储、读取和清除到自定义的键值存储类中。struct ContentView: View &#123;    @StateObject private var userDefaults = LightweightUserDefaultsWrapper()    @State private var inputText: String = &quot;&quot;    var body: some View &#123;        VStack(spacing: 20) &#123;            TextField(&quot;Enter some text&quot;, text: $inputText)                .textFieldStyle(RoundedBorderTextFieldStyle())                .padding()            Button(&quot;Save to Custom UserDefaults&quot;) &#123;                Task &#123;                    await userDefaults.save(inputText, forKey: &quot;userInput&quot;)                &#125;            &#125;            Button(&quot;Load from Custom UserDefaults&quot;) &#123;                Task &#123;                    if let loadedText = await userDefaults.load(forKey: &quot;userInput&quot;) as? String &#123;                        inputText = loadedText                    &#125;                &#125;            &#125;            Button(&quot;Clear Custom UserDefaults&quot;) &#123;                Task &#123;                    await userDefaults.clear(forKey: &quot;userInput&quot;)                &#125;            &#125;        &#125;        .padding()    &#125;&#125;// 用于与 SwiftUI 的视图绑定，并在需要时调用异步的存储和读取操作。@MainActorclass LightweightUserDefaultsWrapper: ObservableObject &#123;    private let lightweightUserDefaults = LightweightUserDefaults()    func save(_ value: Any?, forKey key: String) async &#123;        await lightweightUserDefaults.set(value, forKey: key)    &#125;    func load(forKey key: String) async -&gt; Any? &#123;        return await lightweightUserDefaults.value(forKey: key)    &#125;    func clear(forKey key: String) async &#123;        await lightweightUserDefaults.removeValue(forKey: key)    &#125;&#125;@mainstruct MyApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()        &#125;    &#125;&#125;\n\nCLLocationManager 获取当前位置权限状态CLLocationManager 用于定位服务，如果频繁调用定位权限状态的获取，可能会导致性能问题。特别是在获取权限状态时，系统会进行一些额外的操作，这可能会造成卡顿。\nCLLocationManager *locationManager = [[CLLocationManager alloc] init];CLAuthorizationStatus status = [CLLocationManager authorizationStatus];// 获取当前的定位权限状态\n频繁调用 authorizationStatus 可能导致性能问题，特别是当应用在进行定位相关的操作时。\nUIPasteboard 设置和获取值UIPasteboard 用于实现剪贴板功能，读取和写入剪贴板数据可能会涉及到 IPC 操作。如果操作过于频繁或数据过大，可能会导致卡顿。\nUIPasteboard *pasteboard = [UIPasteboard generalPasteboard];pasteboard.string = @&quot;SomeString&quot;; // 设置剪贴板内容NSString *clipboardContent = pasteboard.string; // 获取剪贴板内容\n\nUIApplication 通过 openURL 打开其他应用使用 UIApplication 的 openURL: 方法可以打开其他应用程序。如果调用频繁或目标应用处理慢，可能会导致卡顿。\nNSURL *url = [NSURL URLWithString:@&quot;myapp://&quot;];[[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:^(BOOL success) &#123;    if (success) &#123;        NSLog(@&quot;Opened URL successfully&quot;);    &#125; else &#123;        NSLog(@&quot;Failed to open URL&quot;);    &#125;&#125;];\n如果目标应用的响应时间较长，可能会影响当前应用的流畅度。\n","categories":["性能优化"],"tags":["性能优化","卡顿监控"]},{"title":"性能分析","url":"/2025/05/14/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","content":"性能分析-工具开源工具\nFLEX (Flipboard Explorer) 是一个非常受欢迎的开源 iOS 内部工具，提供了强大的 UI，允许开发者在运行时检查应用的视图层次结构、网络请求、数据库、用户偏好设置等。适合开发者在应用内实时调试和检查性能问题。\nXCTest XCTest 是 Apple 官方的单元测试框架，支持性能测试。开发者可以通过 measure 方法来衡量代码块的执行时间，从而发现性能瓶颈。适合需要在单元测试中添加性能测试的场景。\nKSCrash KSCrash 是一个强大的崩溃报告框架，它不仅能够捕获崩溃信息，还能提供应用程序的性能数据，例如内存使用和 CPU 使用情况。适合需要深入了解崩溃原因并监控相关性能数据的场景。\nGT (GDT, GodEye) GodEye 是一个开源的 iOS 性能监控工具包，提供了多种监控功能，包括 FPS、内存使用、CPU 使用率、网络请求、崩溃日志等。它有一个方便的 UI，可以实时显示性能数据。适合在开发过程中嵌入应用进行实时性能监控。\nlibimobiledevice libimobiledevice 是一个开源的库，提供了与 iOS 设备交互的 API，可以用来监控设备状态和性能，特别是对非越狱设备进行操作。\n\nInstrumentsInstruments 是 Xcode 自带的一款强大的性能分析和调试工具，广泛用于 iOS 应用的性能监测和问题排查。\n打开 Xcode 项目，选择 Product &gt; Profile，或者使用快捷键 Command + I。这会编译并启动应用，然后打开 Instruments 界面。你也可以直接从 Xcode 中选择 Xcode &gt; Open Developer Tool &gt; Instruments 启动 Instruments。\nInstruments 提供了多种模板，每个模板用于不同类型的性能分析。常用的模板有：\n\nTime Profiler：用于分析 CPU 使用情况，找出性能瓶颈。\nAllocations：监控内存分配，帮助识别内存泄漏和过度使用。\nLeaks：检测内存泄漏。\nCore Animation：分析应用的动画性能，找出导致掉帧的原因。\nEnergy Log：评估应用的能耗表现。\n\n当应用运行时，正常使用它或执行你需要分析的特定操作。Instruments 将记录这些操作期间的性能数据。点击 Record 按钮（通常是红色圆点），开始记录数据。完成后，点击 Stop 按钮停止记录。Instruments 会生成一个时间轴，展示应用在运行期间的各种性能数据。你可以通过拖动时间轴，放大或缩小某段时间范围内的数据。\n细节分析：\n\nCPU 使用情况：使用 Time Profiler 查看函数调用栈，识别性能瓶颈。\n内存使用情况：使用 Allocations 或 Leaks 查看对象分配情况，分析内存泄漏和不当的内存使用。\n帧率分析：使用 Core Animation 检查应用的帧率，查找导致掉帧的操作。\n\n你可以在关键点添加标记（Mark），帮助更容易地定位和分析问题。\nSystem TraceSystem Trace 是一个强大的工具，可以帮助你深入分析和解决性能问题。System Trace 是 Xcode Instruments 中的一个模板，它提供了关于系统性能的详细信息，包括 CPU 使用情况、线程活动、系统调用、分页错误、I&#x2F;O 接口信息等，甚至包括进程内以及进程间的情况。以下是 System Trace 的使用方法：\n步骤一：准备工作\n\n确保 Xcode 和设备准备好：确保你已经安装了最新版本的 Xcode，并将 iOS 设备连接到你的 Mac。\n打开 Xcode Instruments：在 Xcode 中选择 Product &gt; Profile，或者直接在 Finder 中打开 Instruments 应用。\n\n步骤二：选择 System Trace 模板\n\n选择模板：在 Instruments 中，打开“选择模板”窗口，选择 System Trace 模板。\n连接设备：选择你要分析的 iOS 设备，确保设备处于调试模式并已连接。\n\n步骤三：开始记录\n\n启动记录：点击红色的记录按钮，开始采集数据。运行你的应用程序，并重现卡顿或性能问题。\n结束记录：当你捕获到问题或完成测试后，点击停止按钮停止记录。\n\n步骤四：分析数据\n\n查看时间线：System Trace 会生成一个时间线视图，其中包括 CPU 使用情况、线程活动、硬件中断等。你可以通过缩放和滚动来查看不同时间点的详细信息。\n分析线程活动：查看哪些线程在特定时间段内占用了大量 CPU 资源，找出是否存在长时间运行的任务或死锁。\n查看内核事件：System Trace 还会显示内核相关的事件，如中断处理和内存管理，这对于深入分析系统级问题非常有帮助。\n标记和过滤：使用标记和过滤功能，专注于特定时间段或线程，以更容易地识别问题。\n\n步骤五：优化和调试\n\n识别问题代码：根据分析结果，找到可能导致卡顿的代码段，查看是否有可以优化的部分。\n修改代码并重新测试：修改代码后，重新运行 System Trace 来验证优化是否解决了性能问题。\n\n步骤六：生成报告\n\n保存和分享：你可以将 System Trace 生成的分析数据导出为 .trace 文件，方便共享或进一步分析。\n对比分析：可以多次运行 System Trace，比较优化前后的数据，确保性能得到改善。\n\nMetricKit基本使用MetricKit 允许开发者收集和分析与应用程序性能、崩溃、功耗等相关的关键指标。以下是使用 MetricKit 的方法：\n首先，在你的项目中导入 MetricKit 框架：\nimport MetricKit\n创建一个 MXMetricManager 的实例，它是收集指标数据的主要接口。\nlet metricManager = MXMetricManager.shared\n注册 Metrics 管理器\n你需要让你的类（通常是 AppDelegate 或其他适合的单例类）遵循 MXMetricManagerSubscriber 协议，并注册为 MXMetricManager 的订阅者。\nclass AppDelegate: UIResponder, UIApplicationDelegate, MXMetricManagerSubscriber &#123;    func application(_ application: UIApplication,                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123;        MXMetricManager.shared.add(self)        return true    &#125;    // 处理 Metrics 数据    func didReceive(_ payloads: [MXMetricPayload]) &#123;        for payload in payloads &#123;            // 处理接收到的 Metrics 数据            print(&quot;Received metrics payload: \\(payload)&quot;)        &#125;    &#125;        // 处理崩溃诊断数据    func didReceive(_ payloads: [MXCrashDiagnosticPayload]) &#123;        for payload in payloads &#123;            // 处理接收到的崩溃诊断数据            print(&quot;Received crash diagnostics payload: \\(payload)&quot;)        &#125;    &#125;&#125;\n分析和存储指标数据\nMXMetricPayload 包含了多种指标数据，如 CPU 使用率、内存使用情况、网络流量等。你可以遍历这些数据，存储或发送到你的后端进行进一步分析。\nfunc didReceive(_ payloads: [MXMetricPayload]) &#123;    for payload in payloads &#123;        if let cpuMetrics = payload.cpuMetrics &#123;            print(&quot;CPU Usage: \\(cpuMetrics)&quot;)        &#125;                if let memoryMetrics = payload.memoryMetrics &#123;            print(&quot;Memory Usage: \\(memoryMetrics)&quot;)        &#125;                if let networkMetrics = payload.networkTransferMetrics &#123;            print(&quot;Network Usage: \\(networkMetrics)&quot;)        &#125;                // 你可以将这些数据保存到文件或发送到服务器    &#125;&#125;\n处理崩溃诊断数据\nMetricKit 也可以收集应用的崩溃诊断信息，方便你追踪和解决崩溃问题。\nfunc didReceive(_ payloads: [MXCrashDiagnosticPayload]) &#123;    for payload in payloads &#123;        // 处理崩溃诊断数据        if let diagnostics = payload.crashDiagnostics &#123;            for diagnostic in diagnostics &#123;                print(&quot;Crash Diagnostic: \\(diagnostic)&quot;)            &#125;        &#125;    &#125;&#125;\n从 Metric Manager 移除订阅者\n如果你不再需要收集指标数据，可以从 MXMetricManager 中移除你的订阅者。\nMXMetricManager.shared.remove(self)\nMXMetricManager 只在实际设备上运行时才会收集数据，模拟器中不会生成有效的数据。MetricKit 数据的收集是异步的，且系统会自动决定何时发送数据给你的应用，所以你不会立即收到数据。数据的保留期较短，Apple 建议尽快处理和存储接收到的指标数据。\n自定义和收集特定的应用指标虽然 MetricKit 本身主要提供了一组预定义的指标，如启动时间、CPU 使用率、内存使用情况等，但你也可以通过结合其他技术手段来自定义和收集特定的应用指标。\n思路\n\n利用现有的 MetricKit 指标： 如果你的自定义指标能够与 MetricKit 提供的现有指标关联，最好优先利用这些指标。例如，你可以利用 MXAppLaunchMetric 来测量特定场景下的启动时间。\n结合日志系统（如 os_log）： 你可以通过 os_log 系统记录特定的自定义事件和数据，然后在 MXLogHandle 提供的日志中分析这些自定义指标。虽然这不是直接通过 MetricKit 记录，但你可以通过这些日志生成自定义报告。\n使用第三方工具或库： 如果 MetricKit 无法满足需求，可以使用其他分析工具或库来收集和发送自定义指标，例如 Firebase Analytics 或 Amplitude。\n自定义代码实现： 你可以在应用中自行编写代码，定期收集并记录自定义指标数据，然后通过网络请求或其他方式将其发送到后端服务器进行分析。假设你想自定义一个指标，用于监测用户在某个特定功能页面的停留时间。你可以通过以下方式实现：\n\n在 ViewController 中记录开始时间和结束时间\nimport UIKitimport osclass FeatureViewController: UIViewController &#123;    private var startTime: Date?    private var osLog = OSLog(subsystem: &quot;com.yourapp.feature&quot;, category: &quot;Performance&quot;)    override func viewDidAppear(_ animated: Bool) &#123;        super.viewDidAppear(animated)        startTime = Date()        os_log(&quot;Feature page appeared&quot;, log: osLog, type: .info)    &#125;    override func viewDidDisappear(_ animated: Bool) &#123;        super.viewDidDisappear(animated)        if let startTime = startTime &#123;            let elapsedTime = Date().timeIntervalSince(startTime)            os_log(&quot;Feature page disappeared, duration: %&#123;public&#125;.2f seconds&quot;, log: osLog, type: .info, elapsedTime)            // 你可以在这里将 elapsedTime 发送到服务器或其他存储系统        &#125;    &#125;&#125;\n定期发送收集到的数据。你可以通过定时任务或应用进入后台时，将收集到的自定义指标发送到服务器或分析系统。\nfunc applicationDidEnterBackground(_ application: UIApplication) &#123;    // 发送数据到服务器&#125;\n将自定义指标与 MetricKit 集成。虽然 MetricKit 没有直接支持自定义指标的功能，但你可以通过 MXMetricManager 的代理方法捕获系统提供的指标数据，并结合自定义指标进行分析。\nimport MetricKitclass MetricManager: NSObject, MXMetricManagerSubscriber &#123;    override init() &#123;        super.init()        MXMetricManager.shared.add(self)    &#125;    func didReceive(_ payloads: [MXMetricPayload]) &#123;        for payload in payloads &#123;            // 处理 MetricKit 提供的系统指标            let cpuMetrics = payload.cpuMetrics            // 结合你的自定义指标进行综合分析        &#125;    &#125;&#125;\nInApp分析工具iOS 平台上常用的 In-app Debug 工具有以下几种：\n\nFlex 是一个功能强大的 In-app Debug 工具，允许开发者在应用内实时查看和修改视图层次结构、网络请求、用户默认设置等。它还支持动态调整 UI 以及调试其他 app 内部逻辑。无需重新编译代码即可直接调试；可以修改内存中的值来观察变化。\nChisel 是 Facebook 开发的一组 LLDB 命令集，专门用于在调试时提供更方便的操作。它能帮助开发者快速检查视图层次结构、查看控件信息等。与 Xcode LLDB 无缝集成，通过命令行调试视图、打印出布局相关信息等。\nReveal 是一个图形化的 In-app Debug 工具，它允许开发者在运行中的应用中实时查看和编辑视图层次结构，支持 2D 和 3D 的视图展示。提供直观的 UI 调试界面，可以轻松地查看和修改视图属性；支持 iOS 和 tvOS。\nLookin 是一个开源的 iOS 视觉调试工具，专门用于分析和检查 iOS 应用的界面结构。它提供类似于 Xcode 的 View Debugging 功能，但更加灵活和强大，尤其是在复杂 UI 布局的分析上。通过 Lookin，你可以轻松地获取 iOS 应用中的界面层级、布局信息，并进行实时的 UI 调试和调整。可以称之为开源版的 Reveal。\n\nfishhookfishhook 是一个用于在 iOS 和 macOS 环境中进行函数替换的开源库，主要用于动态链接库（dylib）中的符号重写。\nfishhook 通过操作 Mach-O 文件的符号表来找到需要替换的函数。Mach-O 文件的符号表包含了所有函数和变量的符号（名称和地址）信息。fishhook 使用 dyld（动态链接器）的相关函数来进行符号重定向。它首先使用 dyld 提供的接口找到符号的地址，然后将这些符号的地址替换为新的地址。通过修改 Mach-O 文件中的符号表来完成函数替换。这包括修改动态链接库中的 __dyld 的符号信息，使得在运行时调用这些符号时会跳转到新的实现。\nfishhook 允许在程序运行时动态替换函数实现，这对于调试和修改第三方库的行为非常有用。\n以下是一个简单的示例，展示了如何使用 fishhook 来替换函数实现：\n#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &quot;fishhook.h&quot;// 需要被替换的原始函数static int (*orig_printf)(const char *, ...) = NULL;// 新的函数实现int new_printf(const char *format, ...) &#123;    printf(&quot;Intercepted: &quot;);    va_list args;    va_start(args, format);    int result = orig_printf(format, args);    va_end(args);    return result;&#125;// 替换函数实现void replace_printf() &#123;    // 确保在替换之前已经加载了动态库    rebind_symbols((struct rebinding[1])&#123;&#123;&quot;printf&quot;, new_printf, (void *)&amp;orig_printf&#125;&#125;, 1);&#125;int main() &#123;    replace_printf();    printf(&quot;Hello, World!\\n&quot;);    return 0;&#125;\n在这个示例中，replace_printf 函数将 printf 函数的实现替换为 new_printf，并在控制台上输出 “Intercepted: “。\nFrida使用 Frida 来进行动态分析和调试\n\n准备工作\n\n\nFrida 工具链: 安装 Frida 的命令行工具。在 macOS 上可以通过 pip 安装： bash pip install frida-tools \n开发者证书: 需要一个有效的苹果开发者账号，用于签名自定义的 Frida 服务器应用。\n\n\n编译并签名 Frida Server\n\n\n下载 Frida 源码: 从 Frida 的 GitHub 仓库克隆源码。\n\ngit clone https://github.com/frida/frida.gitcd frida\n\n编译 Frida Server: 使用 Frida 提供的构建脚本来编译 Frida Server。这个步骤可能需要一些配置，具体过程可以参考 Frida 官方文档。编-译完成后，你会得到一个 frida-server 可执行文件。\n使用开发者证书签名: 将编译好的 frida-server 文件进行签名，确保它可以在非越狱的设备上运行。\n\ncodesign -s &quot;iPhone Developer: Your Name (Team ID)&quot; --entitlements entitlements.plist frida-server\nentitlements.plist 文件需要包括允许调试和 taskforpid 权限的配置。\n\n部署 Frida Server 到设备\n\n\n使用 Xcode 部署: 将 frida-server 文件打包成一个应用，然后通过 Xcode 部署到目标设备上。\n或者通过 SSH 部署: 如果你已经有其他方式在非越狱设备上运行自签名应用，可以通过 SSH 将 frida-server 直接拷贝到设备上。\n\n\n启动 Frida Server\n\n\n在设备上启动: 打开你部署的应用，确保 frida-server 在后台运行。你可以通过 Xcode 的调试控制台或终端命令来启动它。\n连接 Frida Server: 在你的电脑上通过 USB 连接设备，并使用 Frida CLI 连接到运行中的 Frida Server。\n\nfrida-ps -U\n\n开始调试: 你可以使用 Frida 的各种命令来分析和调试目标应用。\n\n\nFrida CLI 使用示例\n\n\n列出所有进程:\n\nfrida-ps -U\n\n附加到目标进程:\n\nfrida -U -n &lt;AppName&gt;\n\n运行脚本:\n\nfrida -U -n &lt;AppName&gt; -l script.js","categories":["性能优化"],"tags":["性能优化","性能分析"]},{"title":"学习计划","url":"/2025/04/23/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","content":"每日节奏建议：\n📖 技术知识学习：1.5h\n🧱 项目回顾 &amp; 系统设计：1h\n🧠 算法训练：1h\n🎤 面试题演练：1h\n📓 总结记录：0.5h\n\n\n🗓️ 第 1 周：UIKit、Block、Runtime\n\n\n星期\n学习内容\n\n\n\n周一\nUIKit 事件传递机制 &amp; Responder Chain\n\n\n周二\nView 布局流程（layoutSubviews 等）\n\n\n周三\nBlock 分类、变量捕获与作用域\n\n\n周四\nBlock 内存管理 &amp; 循环引用分析\n\n\n周五\nObjective-C Runtime 基础结构\n\n\n周六\nRuntime 实战技巧（Swizzling、消息转发）\n\n\n周日\n复盘总结 + 输出笔记（Runtime&#x2F;Block&#x2F;UI）\n\n\n\n🗓️ 第 2 周：RunLoop、线程、内存管理\n\n\n星期\n学习内容\n\n\n\n周一\nRunLoop 构成与线程保活\n\n\n周二\nRunLoop 卡顿优化场景实战\n\n\n周三\nGCD 进阶：barrier&#x2F;group&#x2F;target queue\n\n\n周四\nGCD vs NSOperation 框架对比\n\n\n周五\nARC 本质、Weak 实现、循环引用处理\n\n\n周六\n内存泄漏排查、僵尸对象与 MRC 回顾\n\n\n周日\n总结脑图：RunLoop + 多线程 + 内存管理\n\n\n\n🗓️ 第 3 周：项目复盘 + 网络 &amp; 缓存\n\n\n星期\n学习内容\n\n\n\n周一\n主项目架构梳理 + 架构图初稿\n\n\n周二\nNSURLSession 断点续传 + 网络封装\n\n\n周三\n网络库底层：AFNetworking、Alamofire\n\n\n周四\n缓存策略 + URLProtocol 拦截\n\n\n周五\n数据持久化方案（CoreData&#x2F;SQLite）\n\n\n周六\n离线缓存架构图 + 实际场景总结\n\n\n周日\n输出：项目亮点 bullet list（10 条）\n\n\n\n🗓️ 第 4 周：架构模式 &amp; 动态化技术\n\n\n星期\n学习内容\n\n\n\n周一\nMVC&#x2F;MVVM&#x2F;VIPER&#x2F;Redux 模式总结\n\n\n周二\n模块化设计 + 路由机制实践\n\n\n周三\n跨组件通信方案（Router &#x2F; URLScheme）\n\n\n周四\n热更新方案（JSPatch &#x2F; Flutter &#x2F; RN）\n\n\n周五\n字节跳动高频架构类面试题整理\n\n\n周六\n项目架构演讲模拟\n\n\n周日\n架构图最终版 + 项目复盘文档整理\n\n\n\n🗓️ 第 5 周：系统设计 &amp; 算法进阶\n\n\n星期\n学习内容\n\n\n\n周一\n系统设计题：视频播放 App 设计\n\n\n周二\n视频缓存、异常处理模块\n\n\n周三\n图片加载优化（LRU&#x2F;异步解码）\n\n\n周四\n多线程数据一致性场景题\n\n\n周五\n启动优化 &amp; 白屏优化场景\n\n\n周六\n算法专题：滑动窗口 + 搜索类\n\n\n周日\n输出系统设计答题稿（附图+要点）\n\n\n\n🗓️ 第 6 周：真题精练 + 模拟面试\n\n\n星期\n学习内容\n\n\n\n周一\n字节跳动 iOS 面经模拟一轮\n\n\n周二\n算法 + 项目 + 系统设计自测\n\n\n周三\n面经高频题口头回答训练\n\n\n周四\n系统设计 + 框架类问题演练\n\n\n周五\n算法面试题：手写经典题\n\n\n周六\n模拟面试（可找朋友&#x2F;AI 演练）\n\n\n周日\n总结错题、面试表现复盘笔记\n\n\n\n🗓️ 第 7 周：简历打磨 + 高频回顾\n\n\n星期\n学习内容\n\n\n\n周一\n简历优化 + STAR 法项目精炼\n\n\n周二\n高频 iOS 面试题 Top20 梳理\n\n\n周三\n项目深挖回答演练\n\n\n周四\n算法每日三题（链表&#x2F;DP&#x2F;字符串）\n\n\n周五\n突破知识短板模块\n\n\n周六\n录制项目讲解 or 技术讲演视频\n\n\n周日\n总结答题话术文档 &amp; PPT 资料\n\n\n\n🗓️ 第 8 周：冲刺 &amp; 模拟演练\n\n\n星期\n学习内容\n\n\n\n周一\n快速过一遍面试 50 问\n\n\n周二\n模拟完整项目答辩演讲\n\n\n周三\n高频算法刷题（6 题冲刺）\n\n\n周四\n模拟完整面试（全流程）\n\n\n周五\n总结所有笔记 + 精选答题卡\n\n\n周六\n心态调整 &amp; 准备环境\n\n\n周日\n正式面试 day 🚀（或休息备战）\n\n\n\n"},{"title":"检测和诊断内存问题","url":"/2025/05/12/%E6%A3%80%E6%B5%8B%E5%92%8C%E8%AF%8A%E6%96%AD%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/","content":"OOM内存泄漏，难以监控。内存泄漏是指程序在运行过程中，由于设计错误或者代码实现不当，导致程序未能释放已经不再使用的内存，从而造成系统内存的浪费，严重的会导致程序崩溃。内存泄漏是一个非常严重的问题，因为它会导致程序运行速度变慢，甚至会导致程序崩溃。因此，我们在开发过程中，一定要注意内存泄漏的问题。\nOOM（Out Of Memory）指的是iOS设备上应用因内存占用过高被系统强制终止的现象。iOS通过Jetsam机制管理内存资源，当设备内存紧张时，会终止优先级低或内存占用大的进程。分为FOOM（前台OOM）和BOOM（后台OOM），FOOM对用户体验影响更大。\nJetsam日志包括pageSize（内存页大小）、states（应用状态）、rpages（占用的内存页数）、reason（终止原因）。通过pageSize和rpages可计算出应用崩溃时占用的内存大小。\n在现代操作系统中，内存管理是一项关键任务。随着移动设备和桌面系统的复杂性增加，内存资源的高效使用变得更加重要。iOS和macOS通过引入“内存压力”（Memory Pressure）机制来优化内存管理，取代了传统的基于虚拟内存分页的管理方法。\n虚拟内存系统允许操作系统将物理内存（RAM）和磁盘存储结合使用，以便在内存不足时将不常用的数据移至磁盘。分页（paging）是虚拟内存管理中的一种技术，它将内存划分为小块（页面），并根据需要将它们从物理内存交换到磁盘。然而，分页存在性能瓶颈，尤其是在存储访问速度远低于内存的情况下。\n随着设备硬件的变化和用户体验要求的提高，苹果公司在iOS和macOS中引入了“内存压力”机制。内存压力是一种动态监测内存使用情况的技术，它能够实时评估系统内存的使用状态，并根据不同的压力级别采取相应的措施。\n内存压力机制通过系统级别的反馈来管理内存。系统会监测内存的使用情况，并将压力分为四个级别：无压力（No Pressure）、轻度压力（Moderate Pressure）、重度压力（Critical Pressure）和紧急压力（Jetsam）。\n压力级别的定义与响应：\n\n无压力（No Pressure）：系统内存充足，没有特别的内存管理措施。\n轻度压力（Moderate Pressure）：系统内存开始紧张，操作系统会建议应用程序释放缓存或非必要的资源。\n重度压力（Critical Pressure）：系统内存非常紧张，操作系统可能会暂停后台任务或终止不活跃的应用程序。\n紧急压力（Jetsam）：这是最严重的内存压力状态，系统可能会直接强制关闭占用大量内存的应用程序，以释放资源确保系统的稳定性。系统对内存压力的应对措施\n\n为了应对不同的内存压力，iOS和macOS系统采取了多种策略，包括：\n\n缓存管理：系统会首先清除可丢弃的缓存数据，以减轻内存负担。\n后台任务管理：在压力增加时，操作系统会优先暂停或终止低优先级的后台任务。\n应用程序终止：在紧急情况下，系统会选择性地关闭那些占用大量内存且当前不活跃的应用程序，这一过程被称为“Jetsam”。\n\n使用系统提供的工具（如vm_stat、memory_pressure等）监测应用程序的内存使用情况。这些工具可以帮助开发者识别内存泄漏、过度的缓存使用等问题。开发者可以-通过这些机制感知内存压力的变化。例如，当系统发出UIApplicationDidReceiveMemoryWarningNotification通知时，应用程序应立即释放不必要的资源。\n图像处理的过程中内存容易出现相当大的峰值，这会导致了崩溃。比如导入或裁剪大图时。\n避免不必要的图片解码，使用更高效的图像处理方法可以对图形处理进行优化。\n通过避免提前解码和加载高分辨率图片，只在需要时解码指定尺寸的图片。例如，在加载和裁剪图片时，只处理实际显示在屏幕上的部分，而不是整个图片。通过引入 CGImageSource 和 CGImageThumbnailOptions，在图像加载时直接生成缩略图，从而减少内存占用。与直接使用 UIImage 处理整个图像相比，这种方法更加高效。\n示例如下：\nimport SwiftUIimport SwiftDatastruct ContentView: View &#123;    @State private var image: UIImage? = nil    var body: some View &#123;        VStack &#123;            if let image = image &#123;                Image(uiImage: image)                    .resizable()                    .scaledToFit()                    .frame(width: 200, height: 200)            &#125; else &#123;                Text(&quot;Loading image...&quot;)            &#125;        &#125;        .onAppear(perform: loadImage)    &#125;    func loadImage() &#123;        Task &#123;            // `CGImageSourceCreateWithURL` 从图片的 URL 创建一个 `CGImageSource`，而不是直接加载整个图片。            if let url = Bundle.main.url(forResource: &quot;largeImage&quot;, withExtension: &quot;jpg&quot;),               let source = CGImageSourceCreateWithURL(url as CFURL, nil) &#123;                // 设置缩略图选项                let options: [CFString: Any] = [                    kCGImageSourceThumbnailMaxPixelSize: 200,                    kCGImageSourceCreateThumbnailFromImageAlways: true                ]                                // 生成缩略图。通过设置 `kCGImageSourceThumbnailMaxPixelSize`，仅生成所需尺寸的缩略图，而不是加载整个图片，从而大幅减少内存占用。                if let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) &#123;                    let uiImage = UIImage(cgImage: cgImage)                                        // 更新 UI，回到主线程                    await MainActor.run &#123;                        self.image = uiImage                    &#125;                &#125;            &#125; // end if        &#125; // end Task    &#125;&#125;\n查看内存使用情况在 iOS 中，可以使用 mach_task_basic_info 结构体来查看应用的实际内存使用情况。mach_task_basic_info 是一个 task_info 结构体的子集，它提供了关于任务（进程）的基本信息，包括内存使用情况。特别地，你可以通过 phys_footprint 字段来获取应用程序实际占用的物理内存量。\nimport Foundationfunc getMemoryUsage() -&gt; UInt64? &#123;    var info = mach_task_basic_info()    var count = mach_msg_type_number_t(MemoryLayout&lt;mach_task_basic_info&gt;.size) / 4        let kret = withUnsafeMutablePointer(to: &amp;info) &#123; infoPtr in        infoPtr.withMemoryRebound(to: integer_t.self, capacity: 1) &#123; intPtr in            task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), intPtr, &amp;count)        &#125;    &#125;        if kret == KERN_SUCCESS &#123;        return info.phys_footprint    &#125; else &#123;        print(&quot;Failed to get task info with error code \\(kret)&quot;)        return nil    &#125;&#125;// Usageif let memoryUsage = getMemoryUsage() &#123;    print(&quot;Memory usage: \\(memoryUsage / 1024 / 1024) MB&quot;)&#125;\n在这个示例中，mach_task_basic_info 结构体用于存储基本信息，task_info() 函数用来填充这些信息，phys_footprint 字段提供了物理内存占用的实际数据。使用这些底层 API 需要适当的权限，有时可能无法在应用程序的沙盒环境中访问所有内存信息。\n在 iOS 中，NSProcessInfo 的 physicalMemory 属性可以用来获取设备的总物理内存大小。这个属性返回一个 NSUInteger 类型的值，表示物理内存的大小（以字节为单位）。这个方法在 iOS 9 及更高版本中可用。\nimport Foundationfunc getPhysicalMemorySize() -&gt; UInt64 &#123;    let physicalMemory = ProcessInfo.processInfo.physicalMemory    return physicalMemory&#125;// Usagelet memorySize = getPhysicalMemorySize()print(&quot;Total physical memory: \\(memorySize / 1024 / 1024) MB&quot;)\nvm_statistics_data_t 是一个与虚拟内存相关的数据结构，它提供了关于虚拟内存的统计信息，包括系统的内存使用情况。虽然它不能直接提供应用程序使用的内存，但它可以提供有关整个系统的虚拟内存状态的信息。使用 vm_statistics_data_t 可以获取有关系统内存的更详细的统计数据。\nimport Foundationimport MachOfunc getVMStatistics() -&gt; (freeMemory: UInt64, usedMemory: UInt64)? &#123;    var vmStats = vm_statistics_data_t()    var count = mach_msg_type_number_t(MemoryLayout&lt;vm_statistics_data_t&gt;.size) / 4    var hostPort: mach_port_t = mach_host_self()        let result = withUnsafeMutablePointer(to: &amp;vmStats) &#123; vmStatsPtr in        vmStatsPtr.withMemoryRebound(to: integer_t.self, capacity: 1) &#123; intPtr in            // 用于获取主机的统计信息。通过指定 `HOST_VM_INFO`，可以获取虚拟内存相关的数据。            host_statistics(hostPort, HOST_VM_INFO, intPtr, &amp;count)        &#125;    &#125;        if result == KERN_SUCCESS &#123;        let pageSize = vm_kernel_page_size // 系统的页面大小（通常为 4096 字节）。        let freeMemory = UInt64(vmStats.free_count) * UInt64(pageSize)        let usedMemory = (UInt64(vmStats.active_count) + UInt64(vmStats.inactive_count) + UInt64(vmStats.wire_count)) * UInt64(pageSize)        return (freeMemory, usedMemory)    &#125; else &#123;        print(&quot;Failed to get VM statistics with error code \\(result)&quot;)        return nil    &#125;&#125;// Usageif let vmStats = getVMStatistics() &#123;    print(&quot;Free memory: \\(vmStats.freeMemory / 1024 / 1024) MB&quot;)    print(&quot;Used memory: \\(vmStats.usedMemory / 1024 / 1024) MB&quot;)&#125;\nvm_statistics_data_t 数据结构包含了有关虚拟内存的统计信息，如 free_count（自由页数）、active_count（活跃页数）、inactive_count（非活跃页数）和 wire_count（被锁定的页数）。\n获取可用内存的方法如下：\nimport Foundationimport MachOfunc getAvailableMemory() -&gt; UInt64? &#123;    var vmStats = vm_statistics_data_t()    var count = mach_msg_type_number_t(MemoryLayout&lt;vm_statistics_data_t&gt;.size) / 4    var hostPort: mach_port_t = mach_host_self()        let result = withUnsafeMutablePointer(to: &amp;vmStats) &#123; vmStatsPtr in        vmStatsPtr.withMemoryRebound(to: integer_t.self, capacity: 1) &#123; intPtr in            host_statistics(hostPort, HOST_VM_INFO, intPtr, &amp;count)        &#125;    &#125;        if result == KERN_SUCCESS &#123;        let pageSize = vm_kernel_page_size        let freeMemory = UInt64(vmStats.free_count) * UInt64(pageSize)        let inactiveMemory = UInt64(vmStats.inactive_count) * UInt64(pageSize)        return freeMemory + inactiveMemory    &#125; else &#123;        print(&quot;Failed to get VM statistics with error code \\(result)&quot;)        return nil    &#125;&#125;// Usageif let availableMemory = getAvailableMemory() &#123;    print(&quot;Available memory: \\(availableMemory / 1024 / 1024) MB&quot;)&#125;\nfree_count 表示系统中未使用的空闲内存页数。inactive_count 表示系统中未使用但可能会重新使用的内存页数。可用内存可以通过将空闲内存和非活跃内存的页数乘以页面大小来计算得到。\n造成内存泄漏的常见原因内存泄漏指的是程序中已动态分配的堆内存由于某些原因未能释放或无法释放，导致系统内存浪费，程序运行速度变慢甚至系统崩溃。\n\n循环引用：对象A强引用对象B，对象B又强引用对象A，或多个对象互相强引用形成闭环。使用Weak-Strong Dance、断开持有关系（如使用__block关键字、将self作为参数传入block）。\nBlock导致的内存泄漏：Block会对其内部的对象强引用，容易形成循环引用。使用Weak-Strong Dance、断开持有关系（如将self作为参数传入block）。\nNSTimer导致的内存泄漏：NSTimer的target-action机制容易导致self与timer之间的循环引用。在合适的时机销毁NSTimer、使用GCD的定时器、借助中介者（如NSObject对象或NSProxy子类）断开循环引用、使用iOS 10后提供的block方式创建timer。\n委托模式中的内存泄漏：UITableView的delegate和dataSource、NSURLSession的delegate。根据具体场景选择使用weak或strong修饰delegate属性，或在请求结束时手动销毁session对象。\n非OC对象的内存管理：CoreFoundation框架下的对象（如CI、CG、CF开头的对象）和C语言中的malloc分配的内存。使用完毕后需手动释放（如CFRelease、free）。\n\nMetricsMetrics和XCTest中的memgraph 了解和诊断 Xcode 的内存性能问题。\n内存泄漏检测工具原理内存泄漏指的是程序在运行过程中，分配的内存未能及时释放，导致程序占用的内存持续增加。内存泄漏检测工具的基本原理是监控和管理对象的生命周期，检测那些在生命周期结束后仍未被释放的对象。\nFBRetainCycleDetectorFBRetainCycleDetector 是由 Facebook 开源的一个用于检测 iOS 应用中的内存泄漏的工具。内存泄漏通常是由于对象之间的强引用循环导致的，FBRetainCycleDetector 的工作原理就是检测对象图中的强引用循环，进而帮助开发者识别和修复这些泄漏。\nFBRetainCycleDetector 的核心思想是通过分析对象之间的引用关系来识别可能的循环引用。它通过以下步骤实现这一点：\n\n对象图构建：FBRetainCycleDetector 首先会从一个指定的对象开始，递归地遍历该对象的所有属性和关联对象，构建一个引用图。这个图的节点是对象，边是对象之间的强引用。\n深度优先搜索 (DFS)：在构建完对象图之后，FBRetainCycleDetector 会对图进行深度优先搜索，寻找从起始对象到自身的循环路径。换句话说，它会查找路径起始和终止于同一个对象的闭环。\n循环检测：当找到一个循环路径时，FBRetainCycleDetector 就会将其标记为潜在的内存泄漏。检测到的循环会以易于理解的方式输出，帮助开发者定位和解决问题。\n\n为了避免不必要的检测，FBRetainCycleDetector 允许开发者定义一些属性过滤规则，忽略一些不会导致泄漏的引用。例如，可以跳过一些不可见的系统属性或自定义的非持有性引用。工具能够识别并忽略弱引用（weak或unowned），因为这些引用不会导致内存泄漏。FBRetainCycleDetector 具有较高的灵活性，开发者可以通过扩展和定制对象图的遍历规则，使其适应不同的应用场景和复杂对象结构。由于对象图的遍历和循环检测可能会带来性能开销，FBRetainCycleDetector 主要用于开发和调试阶段，而不建议在生产环境中长期使用。\n通常，FBRetainCycleDetector 会在调试时被使用。开发者可以通过简单的代码调用，检测指定对象是否存在循环引用。例如：\nFBRetainCycleDetector *detector = [FBRetainCycleDetector new];[detector addCandidate:someObject];NSSet *retainCycles = [detector findRetainCycles];\n通过以上代码，可以查找someObject 是否存在循环引用，并返回检测到的循环路径。\n在实际应用中，FBRetainCycleDetector 被广泛用于检测复杂的对象之间的引用关系，特别是在自定义控件、大型视图控制器、网络回调等场景下，容易产生强引用循环的问题。通过早期检测和解决这些循环引用，可以大大提高应用的内存管理效率，减少内存泄漏带来的问题。\nMLeaksFinderMLeaksFinder 是一款由腾讯 WeRead 团队开源的 iOS 内存泄漏检测工具，其原理主要基于对象生命周期的监控和延迟检测机制。\nMLeaksFinder 通过为基类 NSObject 添加一个 -willDealloc 方法来监控对象的生命周期。当对象应该被释放时（例如，ViewController 被 pop 或 dismiss 后），该方法被调用。在 -willDealloc 方法中，MLeaksFinder 使用一个弱指针（weak pointer）指向待检测的对象，以避免因为对象已经被释放而导致的野指针访问问题。MLeaksFinder 通过检查视图控制器的生命周期来检测内存泄漏。每个 UIViewController 都有一个 viewDidDisappear 方法，这个方法会在视图控制器从屏幕上消失时被调用。MLeaksFinder 通过在 viewDidDisappear 被调用时，检测该视图控制器是否已经被释放，如果没有被释放则认为存在内存泄漏。对于视图 (UIView)，MLeaksFinder 会在视图被从其父视图中移除时（即 removeFromSuperview 调用后）检查视图是否已经被释放。如果视图没有被释放，则认为存在内存泄漏。MLeaksFinder 通过扩展 NSObject 的功能（即为 NSObject 添加一个 Category）来追踪对象的生命周期。当对象的 dealloc 方法没有在预期的时间内被调用时，就可以判断该对象是否泄漏。\n在 -willDealloc 方法中，MLeaksFinder 使用 dispatch_after 函数在 GCD（Grand Central Dispatch）的主队列上设置一个延迟（通常是2到3秒）执行的 block。这个 block 在延迟时间后执行，尝试通过之前设置的弱指针访问对象。如果对象已经被释放（即弱指针为 nil），则认为没有内存泄漏；如果对象仍然存活，则认为存在内存泄漏。MLeaksFinder 通过将对象的检测任务加入到下一个 Runloop 中执行，从而避免在当前线程中直接执行检测操作。这种方式确保了不会影响主线程的性能，同时能在适当的时间进行内存泄漏的检测。\n如果在延迟时间后对象仍然存活，MLeaksFinder 会执行相应的检测逻辑，并可能通过断言（assertion）中断应用（具体行为可能根据配置和版本有所不同）。MLeaksFinder 会在应用运行时自动检测内存泄漏，不需要开发者手动触发。检测到内存泄漏后，MLeaksFinder 通常会弹出警告框（alert）或通过日志（log）输出相关信息，帮助开发者定位和解决内存泄漏问题。\nMLeaksFinder 使用了方法交换技术替换如dismissViewControllerAnimated:completion:等方法，确保释放时触发检测。调用willDealloc方法，设置延时检查对象是否已释放。若未释放，则进入assertNotDealloc方法，中断言提醒开发者。\n当 MLeaksFinder 检测到潜在的内存泄漏时，它还可以打印堆栈信息，帮助开发者找出导致对象无法释放的具体代码路径。通过willReleaseChild、willReleaseChildren方法构建子对象的释放堆栈信息。这通常通过递归遍历子对象，并将父对象和子对象的类名组合成视图堆栈（view stack）来实现。\nMLeaksFinder 还可能集成了循环引用检测功能，使用如 Facebook 的 FBRetainCycleDetector 这样的工具来找出由 block 等造成的循环引用问题。MLeaksFinder 提供了一种白名单机制，允许开发者将一些特定的对象排除在泄漏检测之外。这在某些对象确实需要持久存在的场景下非常有用。MLeaksFinder 非常轻量，不会显著影响应用的性能。集成简单，自动化检测，极大地方便了开发者发现内存泄漏问题。在某些复杂的情况下，可能会有误报（即认为对象泄漏了，但实际上没有）。\nPLeakSnifferPLeakSniffer是一个用于检测iOS应用程序中内存泄漏的工具。PLeakSniffer的基本工作原理：通过对控制器和视图对象设置弱引用，并使用单例对象周期性地发送ping通知，如果对象在控制器已释放的情况下仍然响应通知，则可能存在内存泄漏。\nPLeakSnifferCitizen协议的设计及其在NSObject、UIViewController、UINavigationController和UIView中的实现。每个类都通过实现prepareForSniffer方法来挂钩适当的生命周期方法（如viewDidAppear、pushViewController等），在适当的时机调用markAlive方法，将代理对象附加到被监测的对象上，以便后续的ping操作能够检测到对象的存活状态。\n代理对象PObjectProxy的功能，它主要负责接收ping通知并检查宿主对象是否应当被释放，如果检测到可能的内存泄漏，就会触发警报或打印日志。通过这种方式，PLeakSniffer能够在运行时检测到iOS应用中可能存在的内存泄漏问题。\n其他内存泄漏检测工具\nLifetimeTracker\n\nhook malloc方法要在 iOS 上 hook malloc 方法，可以使用函数拦截技术。以下是一个示例，展示如何使用 Fishhook 库来 hook malloc 方法。\n将 Fishhook 库添加到你的项目中。你可以通过 CocoaPods 或手动添加 Fishhook 源代码。\n#import &lt;Foundation/Foundation.h&gt;#import &lt;malloc/malloc.h&gt;#import &quot;fishhook.h&quot;// 原始 malloc 函数指针static void* (*original_malloc)(size_t size);// 自定义 malloc 函数void* custom_malloc(size_t size) &#123;    void *result = original_malloc(size);    NSLog(@&quot;Allocated %zu bytes at %p&quot;, size, result);    return result;&#125;// Hook 函数void hookMalloc() &#123;    // 重新绑定 malloc 函数    rebind_symbols((struct rebinding[1])&#123;&#123;&quot;malloc&quot;, custom_malloc, (void *)&amp;original_malloc&#125;&#125;, 1);&#125;int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        // Hook malloc        hookMalloc();                // 测试 malloc 和 free        void *ptr = malloc(1024);        free(ptr);    &#125;    return 0;&#125;\n在实际项目中使用时，注意性能开销和日志记录的影响。\nmalloc loggermalloc_logger 是 iOS 和 macOS 中用于内存分配调试的一个工具。它允许开发者设置一个自定义的日志记录器函数，以便在内存分配和释放操作发生时记录相关信息。通过使用 malloc_logger，开发者可以更容易地检测和诊断内存问题，如内存泄漏、过度分配等。\n以下是一个使用 Objective-C 实现的示例，展示如何设置和使用 malloc_logger：\n#import &lt;Foundation/Foundation.h&gt;#import &lt;malloc/malloc.h&gt;// 定义自定义的 malloc logger 函数void custom_malloc_logger(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t result, uintptr_t num_bytes) &#123;    switch (type) &#123;        case MALLOC_LOG_TYPE_ALLOCATE:            NSLog(@&quot;Allocated %lu bytes at %p&quot;, (unsigned long)num_bytes, (void *)result);            break;        case MALLOC_LOG_TYPE_DEALLOCATE:            NSLog(@&quot;Deallocated memory at %p&quot;, (void *)arg1);            break;        case MALLOC_LOG_TYPE_HAS_ZONE:            NSLog(@&quot;Memory operation with zone at %p&quot;, (void *)arg1);            break;        default:            break;    &#125;&#125;// 设置自定义的 malloc loggervoid setCustomMallocLogger() &#123;    malloc_logger = custom_malloc_logger;&#125;int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        // 设置自定义 malloc logger        setCustomMallocLogger();                // 测试 malloc 和 free        void *ptr = malloc(1024);        free(ptr);    &#125;    return 0;&#125;\n在这个示例中，我们定义了一个自定义的 malloc_logger 函数 custom_malloc_logger，并在 setCustomMallocLogger 函数中将其设置为当前的 malloc_logger。然后，在 main 函数中，我们测试了内存的分配和释放操作，并通过日志记录器记录这些操作的信息。\n通过这种方式，开发者可以在内存分配和释放时记录相关信息，从而更好地理解和优化应用程序的内存使用情况。\n内存快照检测方案扫描进程中所有Dirty内存，建立内存节点之间的引用关系有向图，用于内存问题的分析定位。\n在 iOS 中，可以使用 vmregionrecurse_64 函数来获取所有内存区域的信息。\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;mach/mach.h&gt;  #include &lt;mach/vm_map.h&gt;    int main(int argc, const char * argv[]) &#123;      mach_port_t task = mach_task_self();      vm_address_t address = VM_MIN_ADDRESS;      vm_size_t size = VM_MAX_ADDRESS - VM_MIN_ADDRESS;      vm_region_basic_info_data_64_t info;      mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;      memory_object_name_t object_name;      mach_port_t object_handle;        kern_return_t kr;        while (size &gt; 0) &#123;          kr = vm_region_recurse_64(task, &amp;address, &amp;size, VM_REGION_BASIC_INFO,                                    (vm_region_info_t)&amp;info, &amp;info_count, &amp;object_name,                                    &amp;object_handle);            if (kr != KERN_SUCCESS)              break;            printf(&quot;Address: 0x%llx, Size: 0x%llx, Protection: 0x%x, In Use: %s\\n&quot;,                 (unsigned long long)info.protection,                 (unsigned long long)info.size,                 (unsigned int)info.protection,                 info.is_submap ? &quot;Yes&quot; : &quot;No&quot;);            address += info.size;          size -= info.size;      &#125;        if (kr != KERN_SUCCESS) &#123;          char *err = mach_error_string(kr);          fprintf(stderr, &quot;vm_region_recurse_64 failed: %s\\n&quot;, err);          free(err);      &#125;        return 0;  &#125;\n在iOS中，可以使用libmalloc库提供的malloc_get_all_zones函数来获取所有内存区域（zone）的信息。malloc_get_all_zones可以遍历所有的内存区域，并为每个区域执行一个回调函数，从而获取详细的内存分配信息。\n以下是一个简单的代码示例，展示如何使用malloc_get_all_zones来获取并打印内存区域的信息：\n#import &lt;malloc/malloc.h&gt;#import &lt;mach/mach.h&gt;// 自定义的回调函数，用于处理每个内存区域的块。该函数用于处理每个zone中的内存块，在这个例子中，它简单地打印出每个内存块的地址和大小。void my_zone_enumerator(task_t task, void *context, unsigned type_mask, vm_range_t *ranges, unsigned range_count) &#123;    for (unsigned i = 0; i &lt; range_count; i++) &#123;        printf(&quot;Memory range: 0x%llx, Size: %llu\\n&quot;, ranges[i].address, ranges[i].size);    &#125;&#125;void print_all_zones() &#123;    // 获取当前任务的mach port。用于获取当前任务的Mach端口，这对于与Mach内核通信是必需的。    task_t task = mach_task_self();    unsigned int count;    // 这是`libmalloc`库中的一个结构体，表示内存区域。通过调用其`introspect`属性下的`enumerator`函数，可以遍历该zone中的所有内存块。    malloc_zone_t **zones = NULL;    // 获取所有的内存区域。这个函数返回当前任务的所有内存区域（zone），这些zone通常对应于不同的分配器或内存池。    kern_return_t kr = malloc_get_all_zones(task, NULL, &amp;zones, &amp;count);    if (kr != KERN_SUCCESS) &#123;        fprintf(stderr, &quot;Error: Unable to get all zones\\n&quot;);        return;    &#125;    // 遍历所有的zone    for (unsigned int i = 0; i &lt; count; i++) &#123;        malloc_zone_t *zone = zones[i];        if (zone != NULL) &#123;            printf(&quot;Zone name: %s\\n&quot;, zone-&gt;zone_name);            // 枚举zone中的内存块            zone-&gt;introspect-&gt;enumerator(task, NULL, MALLOC_PTR_IN_USE_RANGE_TYPE, (vm_address_t)zone, my_zone_enumerator);        &#125;    &#125;&#125;int main(int argc, const char * argv[]) &#123;    print_all_zones();    return 0;&#125;\n使用单独的malloc_zone管理采集模块的内存使用，减少非法内存访问。遍历进程内所有VM Region（虚拟内存区域），获取Dirty和Swapped内存页数。重点关注libmalloc管理的堆内存，获取存活内存节点的指针和大小。\n为内存节点赋予详细的类型名称，如Objective-C&#x2F;Swift&#x2F;C++实例类名等。通过运行时信息和mach-o、C++ ABI文档获取C++对象的类型信息。遍历内存节点，搜索并确认节点间的引用关系。对栈内存和Objective-C&#x2F;Swift堆内存进行特殊处理，获取更详细的引用信息。\n后台线程定时检测内存占用，超过设定的危险阈值后触发内存分析。内存分析过程中，对内存节点进行引用关系分析，生成内存节点之间的引用关系有向图。通过图算法，找到内存泄漏的根原因。\nlibmalloc 内存日志分析通过代码控制内存日志开关，可以在内存泄漏发生时，输出内存日志。内存日志包括内存分配、释放、引用计数变化等信息，用于分析内存泄漏的原因。\n在 iOS 开发中，libmalloc 提供了 turn_on_stack_logging 和 turn_off_stack_logging 方法，用于启用和禁用堆栈日志记录。这些方法可以帮助开发者在调试和分析内存问题时记录内存分配的堆栈信息。以下是一个使用这些方法的代码示例：\n#import &lt;Foundation/Foundation.h&gt;#import &lt;malloc/malloc.h&gt;#import &lt;mach/mach.h&gt;#import &lt;mach/mach_init.h&gt;#import &lt;mach/mach_vm.h&gt;// 启用堆栈日志记录void enableStackLogging() &#123;    turn_on_stack_logging(1);    NSLog(@&quot;Stack logging turned on&quot;);&#125;// 禁用堆栈日志记录void disableStackLogging() &#123;    turn_off_stack_logging();    NSLog(@&quot;Stack logging turned off&quot;);&#125;// 获取堆栈日志记录void getStackLoggingRecords() &#123;    // 获取当前任务    task_t task = mach_task_self();        // 获取所有堆栈日志记录    mach_vm_address_t *records;    uint32_t count;    kern_return_t kr = __mach_stack_logging_enumerate_records(task, &amp;records, &amp;count);        if (kr != KERN_SUCCESS) &#123;        NSLog(@&quot;Failed to enumerate stack logging records: %s&quot;, mach_error_string(kr));        return;    &#125;        for (uint32_t i = 0; i &lt; count; i++) &#123;        mach_vm_address_t record = records[i];        NSLog(@&quot;Record %u: %p&quot;, i, (void *)record);                // 定义堆栈帧数组        uint64_t frames[128];        // 获取堆栈帧信息        uint32_t frameCount = __mach_stack_logging_frames_for_uniqued_stack(task, record, frames, 128);                // 遍历堆栈帧，每次循环中，获取当前堆栈帧地址并打印地址信息        for (uint32_t j = 0; j &lt; frameCount; j++) &#123;            NSLog(@&quot;Frame %u: %p&quot;, j, (void *)frames[j]);        &#125;    &#125;        // 释放记录数组    vm_deallocate(task, (vm_address_t)records, count * sizeof(mach_vm_address_t));&#125;// 示例函数，分配一些内存void allocateMemory() &#123;    void *ptr1 = malloc(1024);    void *ptr2 = malloc(2048);    free(ptr1);    free(ptr2);&#125;// 主函数int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        // 启用堆栈日志记录        enableStackLogging();                // 分配内存        allocateMemory();                // 获取堆栈日志记录        getStackLoggingRecords();                // 禁用堆栈日志记录        disableStackLogging();    &#125;    return 0;&#125;\n在这个示例中，我们首先调用 turnonstacklogging 方法来启用堆栈日志记录，然后进行一些内存分配和释放操作。接着，我们调用 __machstackloggingenumeraterecords 方法获取所有堆栈日志记录，并使用 __machstackloggingframesforuniquedstack 方法解析每个日志记录以获取堆栈帧信息。最后，我们调用 turnoffstacklogging 方法来禁用堆栈日志记录。\n通过这种方式，开发者可以在需要时启用和禁用堆栈日志记录，并解析这些日志记录以获取详细的堆栈信息。需要注意的是，这些函数在实际项目中使用时，需要确保在合适的时机启用和禁用堆栈日志记录，以避免性能开销和不必要的日志记录。\n","categories":["性能优化"],"tags":["性能优化","内存管理"]},{"title":"静态分析","url":"/2025/05/19/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/","content":"概述静态程序分析是一种在不执行代码的情况下，对代码进行分析以发现潜在问题、优化代码质量或检测安全漏洞的方法。\n静态分析方法有：\n\n语法检查 (Syntax Checking)\n代码规范检查 (Linting)\n数据流分析 (Data Flow Analysis)\n控制流分析 (Control Flow Analysis)\n安全漏洞检测 (Security Vulnerability Detection)\n\n常用静态分析工具有：\nXcode 静态分析器。Xcode 自带的静态分析器能够分析 Objective-C 和 Swift 代码，自动检测潜在的内存管理问题、逻辑错误以及可能的安全漏洞。开发者可以在 Xcode 中开启静态分析功能，通过菜单路径 Product -&gt; Analyze 来执行分析。\nSwiftLint 是一个专为 Swift 语言设计的静态分析工具，用于确保代码符合 Swift 的编码风格和最佳实践。它能够检测代码中的格式问题、不规范的命名、未使用的代码等。\nbrew install swiftlintswiftlint lint\n\nOCLint 是一款适用于 Objective-C、C 和 C++ 代码的静态分析工具，专注于代码质量的提升。它能够检测代码中的常见问题，如复杂度过高、未使用的代码等，并提供详细的报告。\nbrew install oclintoclint-json-compilation-database -e Pods -- -report-type html -o oclint_report.html\n\nInfer 是由 Facebook 开发的一款开源静态分析工具，支持分析 Objective-C 和 Swift 代码。它特别擅长检测空指针引用、内存泄漏和资源泄漏等常见问题。\nbrew install inferinfer run -- xcodebuild -workspace YourApp.xcworkspace -scheme YourApp\n为了获得更全面的静态分析结果，开发者通常会结合多种工具和方法。例如，可以使用 Xcode 的静态分析器进行基本的代码检查，使用 SwiftLint 和 OCLint 确保代码规范，最后通过 Infer 进行深入的逻辑和安全分析。\n此外，许多静态分析工具支持集成到持续集成（CI）系统中，使得静态分析成为开发流程的一部分，确保每次代码提交都符合质量标准。\nClang静态分析器使用静态分析器是Xcode内置的一个工具，它可以在不运行源代码的情况下进行静态的代码分析。静态分析器不执行代码，而是通过静态分析来检查代码中的逻辑、安全和API使用等问题。主要支持C&#x2F;C++&#x2F;Objective-C，对Objective-C和Swift混编的工程也有很好的支持。\n在Xcode中，通过点击Product菜单下的Analyze选项来启动静态分析器。分析完成后，问题会以蓝色的感叹号在Xcode上方显示，也可以在Issue Navigator中查看。\nClang静态分析器的模块位于&#x2F;llvm&#x2F;tools&#x2F;clang&#x2F;lib&#x2F;StaticAnalyzer。Checkers目录下包含了各种检查器，每个检查器负责一个独立的检查项目。共用逻辑部分下沉到Core模块中，大量依赖LLVM和Clang的库。\n\nscan-build：负责对目标代码进行分析，并生成HTML样式的分析报告。\nscan-view：负责在本地运行一个简易的web server，方便查看生成的报告。\n\n你也可以直接使用 clang 命令来运行静态分析。假设你有一个 C 文件 example.c，可以这样运行分析：\nclang --analyze example.c\n这将对 example.c 进行静态分析，并输出分析结果。\n让我们以一个简单的 C 程序为例，它可能包含一些潜在的错误：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void risky_function(int *ptr) &#123;    if (*ptr &gt; 0) &#123;        printf(&quot;Value: %d\\n&quot;, *ptr);    &#125;&#125;int main() &#123;    int *p = malloc(sizeof(int) * 10);    // 错误：没有检查 malloc 是否成功    p[0] = 10;    // 潜在的空指针引用    risky_function(p);    free(p);    return 0;&#125;\n在这段代码中，存在以下问题：\n\nmalloc 之后没有检查是否成功分配内存。\n函数 risky_function 中，如果传入一个空指针 ptr，则可能会解引用空指针。\n\n使用 clang –analyze 来分析这段代码：\nclang --analyze example.c\n输出可能会包括如下警告：\nexample.c:12:5: warning: Dereference of null pointer (loaded from variable &#x27;p&#x27;)    p[0] = 10;    ^example.c:15:5: warning: Dereference of null pointer (loaded from variable &#x27;ptr&#x27;)    if (*ptr &gt; 0) &#123;    ^\n如果你在使用 Xcode 进行开发，你可以通过以下方式启用静态分析：\n\n在 Xcode 中打开你的项目。\n选择 Product &gt; Analyze，Xcode 将运行静态分析并在报告导航器中显示发现的所有问题。\n\n根据 Clang 静态分析器的提示，我们可以修改代码来修复这些潜在的问题：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void risky_function(int *ptr) &#123;    if (ptr != NULL &amp;&amp; *ptr &gt; 0) &#123;        printf(&quot;Value: %d\\n&quot;, *ptr);    &#125;&#125;int main() &#123;    int *p = malloc(sizeof(int) * 10);    if (p == NULL) &#123;        printf(&quot;Memory allocation failed\\n&quot;);        return 1;    &#125;    p[0] = 10;    risky_function(p);    free(p);    return 0;&#125;\n在修复后的代码中：\n\n我们在使用 malloc 后检查了是否分配成功。\n在 risky_function 中添加了一个检查，以确保 ptr 不为 NULL。\n\nClang 静态分析器可以集成到持续集成（CI）系统中，自动分析代码库中的潜在问题。一个简单的方式是将 clang –analyze 命令添加到你的 CI 脚本中，这样每次提交代码时都会自动运行分析。\n自定义Clang 静态分析器允许你自定义分析器，以便检测特定的代码模式或遵循自定义规则。你可以通过编写 Clang 插件或直接修改 Clang 源代码来实现自定义分析。\n自定义检查器是 Clang 静态分析器的一个模块，用于分析特定的代码模式。你可以通过创建一个新的 C++ 类并继承自 Checker 基类来实现它。\n#include &quot;clang/StaticAnalyzer/Core/Checker.h&quot;#include &quot;clang/StaticAnalyzer/Core/CheckerManager.h&quot;#include &quot;clang/StaticAnalyzer/Core/BugReporter/BugType.h&quot;#include &quot;clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h&quot;using namespace clang;using namespace ento;class NullDerefChecker : public Checker&lt;check::PreStmt&lt;UnaryOperator&gt;&gt; &#123;    mutable std::unique_ptr&lt;BugType&gt; BT;public:    void checkPreStmt(const UnaryOperator *U, CheckerContext &amp;C) const;private:    void reportBug(const UnaryOperator *U, CheckerContext &amp;C) const;&#125;;void NullDerefChecker::checkPreStmt(const UnaryOperator *U, CheckerContext &amp;C) const &#123;    if (U-&gt;getOpcode() == UO_Deref) &#123;        const Expr *SubExpr = U-&gt;getSubExpr()-&gt;IgnoreParenCasts();        const LocationContext *LCtx = C.getLocationContext();        const SVal &amp;Val = C.getState()-&gt;getSVal(SubExpr, LCtx);        if (Val.isUndef() || Val.isZeroConstant()) &#123;            reportBug(U, C);        &#125;    &#125;&#125;void NullDerefChecker::reportBug(const UnaryOperator *U, CheckerContext &amp;C) const &#123;    if (!BT)        BT.reset(new BugType(this, &quot;Dereference of null pointer&quot;, &quot;Example Checker&quot;));    auto Report = std::make_unique&lt;PathSensitiveBugReport&gt;(*BT, BT-&gt;getName(), C.generateErrorNode());    Report-&gt;addRange(U-&gt;getSourceRange());    C.emitReport(std::move(Report));&#125;extern &quot;C&quot; void clang_registerCheckers(CheckerRegistry &amp;registry) &#123;    registry.addChecker&lt;NullDerefChecker&gt;(&quot;example.NullDerefChecker&quot;, &quot;Checks for null pointer dereference&quot;, &quot;&quot;);&#125;\n将上述代码保存为 NullDerefChecker.cpp，然后编译它：\nclang++ -shared -fPIC -o NullDerefChecker.so NullDerefChecker.cpp \\    $(llvm-config --cxxflags --ldflags --system-libs --libs all)\n生成的 NullDerefChecker.so 是一个共享库，可以在运行 Clang 静态分析时加载这个自定义检查器。\n使用 clang 命令运行你的自定义检查器：\nclang --analyze -Xclang -load -Xclang ./NullDerefChecker.so -Xclang -analyzer-checker=example.NullDerefChecker example.c\n这里 example.c 是要分析的代码文件。自定义检查器将会在分析时查找空指针解引用的情况，并报告任何发现的问题。\n上面的代码实现了一个简单的检查器 NullDerefChecker，它会检测所有的指针解引用操作，并检查该指针是否为空或未定义。如果发现潜在的空指针解引用，它将报告一个错误。\n\ncheckPreStmt 方法：在每个解引用操作之前调用，检查指针是否为空。\nreportBug 方法：当检测到潜在问题时，生成并报告一个错误。\n\n你可以扩展自定义检查器来支持更多类型的检查，或使用其他 Clang API 来分析更复杂的代码结构。例如，可以在 checkPostCall 中检查函数调用后的返回值，或者在 checkEndAnalysis 中对整个代码路径进行总结分析。\n代码规范代码规范指南一些常见的 iOS 代码规范及其参考资料：\n\nSwift 官方文档：包含 Swift 语言的详细说明和规范。\nGoogle Swift Style Guide：Google 提供的 Swift 代码风格指南。\nSwiftLint：一个用于强制执行 Swift 代码风格和规范的工具。\nSwiftFormat：一个用于自动格式化 Swift 代码的工具。\nNSHipster：一个涵盖 iOS 和 macOS 编程的博客，提供了许多有用的技巧和最佳实践。\n\nCode Review 的重要性\n提高代码质量：通过复查代码，能够及时发现并修复潜在的问题，如逻辑错误、性能瓶颈、安全漏洞等。\n促进知识共享：高手可以通过审查新手的代码，传授好的编程实践和经验，帮助新手快速成长。同时，审查过程也是互相学习的过程，有助于团队成员之间的知识传递。\n保证团队规范的执行：每个团队都有自己的代码规范和开发规范，通过代码审查可以确保这些规范得到执行，避免代码中出现不规范的情况。\n减少技术债务：在代码合并前进行审查，可以及时发现并修复问题，避免问题在后续开发中被放大，从而减少技术债务。\n\nCode Review 的最佳实践\n作为开发流程的必选项：将Code Review作为开发流程的一个必要环节，确保每次代码合并前都经过审查。这样可以保证审查的代码量适中，减轻审查者的压力，同时也使被审查者更愿意积极修改问题。\n形成开发文化：让Code Review成为团队的一种文化，而不是仅仅作为一种制度来执行。这需要团队成员从心底接受并认真执行Code Review，同时管理者也需要通过激励和表率作用来推动这一文化的形成。\n使用合适的工具：现在许多源代码管理工具都自带Code Review工具，如Github、Gitlab、Azure DevOps等。这些工具提供了丰富的功能，如线上讨论、行级别的注释、版本历史等，有助于更高效地进行Code Review。\n做好设计审查：在开发新功能之前，建议先写一个简单的设计文档，并找资深的团队成员进行设计审查。这样可以确保设计上的合理性，减少在Code Review时出现的问题。\n提交前自我审查：开发人员在提交代码进行Code Review之前，应该先进行自我审查，确保代码的基本质量。这包括编写必要的自动化测试代码、运行测试用例等。\n小范围提交：在提交Pull Request（PR）时，尽量保持小范围的修改。如果改动较大，可以分批提交，以减轻审查者的压力。\n明确审查标准：制定明确的审查标准，如代码风格、注释规范、性能要求等。这有助于审查者更准确地评估代码质量，并给出有针对性的反馈。\n分级评论：对Review的评论进行分级，如[blocker]（必须修改）、[optional]（可改可不改）、[question]（需要澄清）等。这有助于被审查者更直观地了解Review结果，并提高Review效率。\n\n应重点关注的方面\n代码的整体结构是否合理？模块化是否清晰？\n代码是否正确地实现了预期功能？是否存在逻辑错误？\n代码是否可以进一步简化？是否有重复代码？\n代码是否有充分的测试覆盖？是否有边界条件的测试？\n命名是否清晰且符合团队风格？是否有注释？\n\nCode Review 遵循的原则遵循 KISS 原则（Keep It Simple, Stupid!）简单是编码的最高境界。确保你的代码简洁明了，易于理解和维护。\n示例\n// 示例：一个简单的用户模型和用户视图// SwiftData: UserModelstruct UserModel: Codable, Identifiable &#123;    var id: String    var name: String    var email: String&#125;// SwiftUI: UserViewstruct UserView: View &#123;    @ObservedObject var viewModel: UserViewModel    var body: some View &#123;        VStack &#123;            Text(viewModel.user.name)            Text(viewModel.user.email)        &#125;        .padding()    &#125;&#125;// ViewModel 简化逻辑处理class UserViewModel: ObservableObject &#123;    @Published var user: UserModel    init(user: UserModel) &#123;        self.user = user    &#125;&#125;// 使用let user = UserModel(id: &quot;123&quot;, name: &quot;John Doe&quot;, email: &quot;john@example.com&quot;)let viewModel = UserViewModel(user: user)UserView(viewModel: viewModel)\n避免重复代码检查并删除重复的代码段，使用函数、类、结构体或枚举来封装重复逻辑。\n// 避免在每个视图中重复写用户信息展示逻辑func displayUserInfo(user: UserModel) -&gt; some View &#123;    VStack &#123;        Text(user.name)        Text(user.email)    &#125;&#125;// 在需要的地方使用UserView &#123;    displayUserInfo(user: viewModel.user)&#125;\n保持函数职责单一确保每个函数只负责一项功能，这有助于代码的可读性和可维护性。\n// 假设有一个函数处理用户登录func loginUser(username: String, password: String) -&gt; Bool &#123;    // 假设这里是登录逻辑    // ...    return true // 登录成功&#125;// 而不是func handleLogin(username: String, password: String, onSuccess: @escaping () -&gt; Void, onFailure: @escaping (Error) -&gt; Void) &#123;    // 登录逻辑 + UI 更新逻辑    // ...&#125;\n\n优化错误处理和日志记录确保代码中有适当的错误处理和日志记录，以便在出现问题时能够快速定位和解决。\n// 假设的日志记录函数func logError(_ error: Error) &#123;    print(&quot;Error: \\(error.localizedDescription)&quot;)&#125;// 示例函数使用日志记录func fetchData() &#123;    do &#123;        // 假设这里是数据获取逻辑        // ...    &#125; catch let error &#123;        logError(error)    &#125;&#125;\n\n代码审查和反馈在团队中进行定期的代码审查，分享最佳实践，指出潜在的问题，并促进团队整体代码质量的提升。\n实际操作：\n\n使用 GitHub Pull Requests, GitLab Merge Requests 或其他代码托管平台的审查功能。\n在审查过程中，注重代码的可读性、可维护性、性能优化等方面。\n提供具体的改进建议和反馈，而不是简单的“这个不好”。\n\n度量与改进项目提测后第一时间进行 Code Review。小模块随时review，项目代码面对面投屏。关注代码设计、总体流程、关键设计、重点功能等。遵循checklist。\n改进\n\n跟踪Code Review结果的执行，必要时加todo指定时间和人员修改。\n定期回顾和总结，更新checklist和代码规范。\n发现好的代码和设计，定期展示并给予奖励。\n\nCode Review的注意事项\n保持友好沟通：在Code Review过程中，应保持友好和尊重的沟通态度。避免使用负面词汇和攻击性语言，以免对团队成员的士气造成负面影响。\n及时反馈：审查者应及时给出反馈意见，并尽量在代码提交后的短时间内完成审查。这有助于被审查者及时修改问题，并保持开发进度。\n重视代码可读性：代码的可读性对于维护性和扩展性至关重要。在Code Review时，应特别关注代码的可读性，如命名规范、注释清晰等。\n考虑性能和安全：除了关注代码的基本逻辑和可读性外，还应考虑代码的性能和安全性。审查者应评估代码的性能瓶颈和潜在的安全漏洞，并给出相应的改进建议。\n\nPre-Commit Hooks实现代码评审（Code Review）与 pre-commit 钩子的结合，可以在代码提交前自动执行代码评审，确保代码质量。\n\n安装 Pre-Commit： 首先需要在项目中安装 pre-commit，可以通过 pip 或其他包管理器安装。\n\npip install pre-commit\n\n配置 Pre-Commit： 在项目根目录创建 .pre-commit-config.yaml 文件，定义需要运行的钩子。例如：\n\nrepos:  - repo: https://github.com/pre-commit/pre-commit-hooks    rev: v4.0.1    hooks:      - id: trailing-whitespace      - id: end-of-file-fixer  - repo: https://github.com/psf/black    rev: 23.1a1    hooks:      - id: black\n这个配置文件定义了几个常用的钩子，比如去除多余空格、确保文件末尾有换行符以及代码格式化。\n\n安装 Pre-Commit 钩子： 运行以下命令来安装预定义的钩子到 Git 仓库中。\n\npre-commit install\n\n自定义 Shell 脚本钩子： 如果需要自定义一些特定的代码检查，可以编写 shell 脚本作为钩子。例如，检查代码中是否存在 TODO 注释：\n\n#!/bin/bashif git grep -q &#x27;TODO&#x27;; then  echo &quot;Error: There are TODO comments in the code.&quot;  exit 1fi\n然后在 .pre-commit-config.yaml 中添加这个钩子：\n- repo: local  hooks:    - id: check-todos      name: Check for TODO comments      entry: ./check_todos.sh      language: script      files: \\.swift$\n代码评审（Code Review）流程中的集成\n\n团队约定： 在团队中约定每个开发者都必须启用 pre-commit 钩子，确保提交的代码符合项目的代码规范，并经过基本检查。\n持续集成（CI）支持： 在 CI 流程中，也可以使用相同的 pre-commit 配置，确保所有提交和合并请求都经过统一的检查。可以在 CI 管道中运行 pre-commit run –all-files 来检查所有代码。假设我们希望在 Swift 项目中检查代码格式（使用 SwiftFormat）、静态分析（使用 SwiftLint），以及确保没有 TODO 注释，可以这样配置：\n\nrepos:  - repo: https://github.com/nicklockwood/SwiftFormat    rev: &#x27;0.48.17&#x27;    hooks:      - id: swiftformat  - repo: https://github.com/realm/SwiftLint    rev: &#x27;0.42.0&#x27;    hooks:      - id: swiftlint  - repo: local    hooks:      - id: check-todos        name: Check for TODO comments        entry: ./check_todos.sh        language: script        files: \\.swift$\n扩展阅读《编写可读代码的艺术》、《重构》、《重构与模式》、《代码精进之路》以及Google Engineering Practices Documentation等。\nLanguage Server Protocol介绍Language Server Protocol (LSP) 是一种协议，用于在代码编辑器和语言服务器之间交换信息。LSP 由 Microsoft 提出的，旨在使不同的编辑器能够与各种编程语言的语言服务器进行交互，以提供统一的代码编辑功能。LSP 的核心思想是将语言特定的功能（如语法检查、代码补全、跳转到定义等）封装在语言服务器中，而将编辑器的功能（如用户界面）与语言服务解耦。LSP 定义了一组标准化的协议和消息格式，使得语言服务器和编辑器可以通过这些协议进行通信。\n主要组件\n\n语言服务器：提供语言特定的服务，如语法检查、代码补全、错误提示等。一个语言服务器可以服务于多个编辑器。\n客户端（编辑器）：实现 LSP 协议，并通过协议与语言服务器进行通信。常见的编辑器如 VS Code、Sublime Text、Atom 等都可以作为 LSP 客户端。\n\nLSP 协议包括以下主要部分：\n\n初始化：客户端和服务器建立连接时，进行初始化协商。\n文本同步：客户端通知服务器文件内容的变化，包括文件的创建、修改和删除。\n代码补全：客户端请求语言服务器提供代码补全建议。\n错误检查：服务器返回代码中的错误和警告信息。\n代码导航：支持跳转到定义、查找引用等功能。\n文档注释：提供关于符号的详细信息和文档注释。\n\nLSP 的优点\n\n统一接口：为不同编辑器和 IDE 提供一致的语言服务接口，简化了语言服务的实现和维护。\n提升效率：减少了编辑器和语言服务之间的重复工作，提高了开发效率。\n增强兼容性：支持多种编辑器和 IDE，使得语言服务可以跨平台使用。\n\nsourcekit-lspsourcekit-lsp 是一个开源项目，由 Swift 团队开发，用于为 Swift 代码提供语言服务。它基于 Language Server Protocol (LSP)，提供了一组功能来支持编辑器和 IDE 中的代码智能化。\nsourcekit-lsp 提供了以下主要功能：\n\n代码补全：在编辑代码时提供智能提示和自动补全建议。\n语法高亮：对 Swift 代码进行语法高亮显示。\n错误检查：实时显示代码中的语法错误和警告。\n代码导航：支持跳转到定义、查看符号、查找所有引用等。\n代码重构：支持重命名符号等基本的代码重构操作。\n文档注释：显示函数、方法、变量等的文档注释信息。\n\n在 Swift 5.1 及更高版本中，sourcekit-lsp 已经包含在 Swift 工具链中，可以通过以下命令安装：\nswift package update\n如果你使用的是 macOS，可以通过 Homebrew 安装 sourcekit-lsp：\nbrew install sourcekit-lsp\nsourcekit-lsp 需要配置到你的代码编辑器中。支持的编辑器包括 Visual Studio Code、Sublime Text、Atom 等。在 Visual Studio Code 中，打开扩展市场（Extensions），搜索并安装 “Swift” 扩展，这个扩展通常会自动安装 sourcekit-lsp。在 VS Code 的设置中，你可以配置 sourcekit-lsp 的路径。如果你通过 Homebrew 安装了 sourcekit-lsp，通常它会自动配置好。\n在 VS Code 中打开你的 Swift 项目。编辑器会自动启动 sourcekit-lsp，并在后台提供语言服务。你可以在编辑器的状态栏中看到相关的信息。\n","categories":["性能优化"]},{"title":"避免视图绘制掉帧","url":"/2025/05/07/%E9%81%BF%E5%85%8D%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E6%8E%89%E5%B8%A7/","content":"图像显示原理iOS 图像显示的原理涉及多个层次，从底层的硬件加速到上层的框架实现。UIKit 提供了高层次的 API，用于管理应用的用户界面元素，包括视图、控件和图像显示。UIImageView 是 UIKit 中用于显示图像的主要类。Core Graphics (也称为 Quartz) 是 iOS 的 2D 绘图引擎。它直接与硬件交互，负责图形的绘制和处理。UIKit 的许多绘图操作最终都通过 Core Graphics 实现。Core Animation 是 iOS 用来处理动画和图像渲染的框架。每个 UIView 都有一个关联的 CALayer，用于处理图像和内容的渲染。Core Animation 负责将这些图层的内容提交到屏幕上，并处理图层之间的动画。\niOS 使用 OpenGL ES 或 Metal 作为底层图形渲染管线。UIKit 和 Core Animation 会将图像、视图和动画转换为 GPU 可理解的命令，并通过 OpenGL ES 或 Metal 渲染到屏幕上。\n当你使用 UIImageView 来显示图像时，以下步骤会发生：\n\n加载图像：UIImage 类用于加载图像资源。你可以从文件系统、网络、或资源包中加载图像。\n设置图像：将 UIImage 对象分配给 UIImageView 的 image 属性。\n图层显示：UIImageView 是一个 UIView 子类，因此它有一个关联的 CALayer。UIImageView 会将图像设置为其图层的 contents。\n渲染图像：Core Animation 将负责将 CALayer 的内容提交到 GPU 进行渲染，最后显示在屏幕上。以下是一个简单的示例，展示如何在 iOS 中使用 UIImageView 来显示图像。\n\nimport UIKitclass ViewController: UIViewController &#123;    override func viewDidLoad() &#123;        super.viewDidLoad()                // 创建 UIImage 对象        if let image = UIImage(named: &quot;example.jpg&quot;) &#123;                        // 创建 UIImageView 对象            let imageView = UIImageView(image: image)                        // 设置 UIImageView 的大小和位置            imageView.frame = CGRect(x: 50, y: 100, width: 200, height: 200)                        // 设置内容模式            imageView.contentMode = .scaleAspectFill                        // 将 UIImageView 添加到视图中            self.view.addSubview(imageView)        &#125;    &#125;&#125;\niOS 会自动缓存 UIImage 对象，以提高性能并减少内存消耗。UIImageView 使用的图像可以通过系统的图像缓存机制优化。\n对于大图像，最好使用分块加载或缩略图显示以减少内存占用。可以使用 CGImageSource 来逐步加载图像。\n举个例子：\nimport SwiftUIstruct ThumbnailImageView: View &#123;    let thumbnailImage: UIImage    let fullSizeImageURL: URL        @State private var fullSizeImage: UIImage? = nil    var body: some View &#123;        ZStack &#123;            if let fullSizeImage = fullSizeImage &#123;                Image(uiImage: fullSizeImage)                    .resizable()                    .scaledToFit()            &#125; else &#123;                Image(uiImage: thumbnailImage)                    .resizable()                    .scaledToFit()                    .onAppear(perform: loadFullSizeImage)            &#125;        &#125;    &#125;    private func loadFullSizeImage() &#123;        DispatchQueue.global().async &#123;            if let data = try? Data(contentsOf: fullSizeImageURL),               let image = UIImage(data: data) &#123;                DispatchQueue.main.async &#123;                    self.fullSizeImage = image                &#125;            &#125;        &#125;    &#125;&#125;\n在加载大图时使用 CGImageSource 逐步解码图片，在低分辨率时减少内存占用。\nimport UIKitfunc loadImageWithLowMemoryUsage(url: URL) -&gt; UIImage? &#123;    guard let source = CGImageSourceCreateWithURL(url as CFURL, nil) else &#123;        return nil    &#125;        let options: [NSString: Any] = [        kCGImageSourceShouldCache: false, // 避免直接缓存到内存        kCGImageSourceShouldAllowFloat: true    ]        return CGImageSourceCreateImageAtIndex(source, 0, options as CFDictionary).flatMap &#123;        UIImage(cgImage: $0)    &#125;&#125;\n如果图像需要从网络加载，建议使用异步加载来避免阻塞主线程。可以结合使用 URLSession 或第三方库如 SDWebImage 来实现。\n如果你需要自定义图像显示或进行复杂的图形处理，可以直接使用 Core Graphics。以下是一个使用 Core Graphics 绘制图像的例子：\nimport UIKitclass CustomView: UIView &#123;    override func draw(_ rect: CGRect) &#123;        guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;        // 设置填充颜色        context.setFillColor(UIColor.red.cgColor)        context.fill(rect)                // 加载图片        if let image = UIImage(named: &quot;example.jpg&quot;)?.cgImage &#123;            context.draw(image, in: rect)        &#125;    &#125;&#125;class ViewController: UIViewController &#123;    override func viewDidLoad() &#123;        super.viewDidLoad()                let customView = CustomView(frame: self.view.bounds)        self.view.addSubview(customView)    &#125;&#125;\nCPU 和 GPU 分别做了什么CPU 做的事情：\n\n视图层次结构的计算（View Hierarchy Calculation）： CPU 负责计算视图的层次结构，包括视图的位置、尺寸、透明度和其他属性。每当视图的这些属性发生变化时，CPU 会重新计算这些信息。\n布局（Layout）： 当使用 Auto Layout 或手动布局时，CPU 会计算所有视图的位置和尺寸。比如调用 layoutSubviews() 方法时，CPU 会参与布局计算。\n文本绘制（Text Rendering）： 如果你在视图中绘制文本，比如使用 UILabel 或 CATextLayer，CPU 会负责对文本进行排版和绘制。\n图像解码（Image Decoding）： 从网络或磁盘加载的图像通常是经过压缩的格式（如 PNG、JPEG）。CPU 负责将这些图像解码为可供 GPU 使用的原始位图格式。\nCore Graphics 绘制（Core Graphics Drawing）： 使用 CGContext 进行的所有绘制操作（如绘制路径、填充颜色等）都是在 CPU 上执行的。\n\n代码示例\nclass CustomView: UIView &#123;    override func layoutSubviews() &#123;        super.layoutSubviews()        // CPU 负责布局计算        let subview = UIView(frame: CGRect(x: 10, y: 10, width: 100, height: 50))        addSubview(subview)    &#125;    override func draw(_ rect: CGRect) &#123;        super.draw(rect)        // CPU 负责文本绘制        let text = &quot;Hello, World!&quot;        let attributes: [NSAttributedString.Key: Any] = [            .font: UIFont.systemFont(ofSize: 16),            .foregroundColor: UIColor.black        ]        text.draw(in: rect, withAttributes: attributes)    &#125;&#125;\nGPU 做的事情：\n\n图层合成（Layer Composition）： GPU 负责将各个图层（如 UIView 或 CALayer）进行合成和渲染。每个视图或图层都会被转换为一个纹理，GPU 会将这些纹理组合到最终的帧缓冲区中。\n图像渲染（Image Rendering）： GPU 负责渲染已经由 CPU 解码的图像位图。它还负责处理各种图像特效，如模糊、阴影、透明度等。\n动画处理（Animations Handling）： iOS 中的大多数动画（如 UIView 动画和 Core Animation）都是在 GPU 上执行的。GPU 负责处理动画的中间帧渲染。\nOpenGL&#x2F;Metal 绘制： 当使用 OpenGL ES 或 Metal 直接进行图形绘制时，GPU 会负责执行这些绘制命令。\n\nUIView.animate(withDuration: 1.0) &#123;    self.view.alpha = 0.5    // 这段代码的动画渲染由 GPU 处理&#125;\n通常，CPU 负责准备数据，GPU 负责渲染这些数据。为了优化性能，我们应该尽量减少 CPU 的负担，减少复杂的布局计算、避免频繁的视图层次变更，以及尽量延迟图像解码等操作。\n优化建议：\n\n尽量简化视图层次结构： 过多的子视图会增加 CPU 的计算负担。\n减少过度的重绘： 尽量避免频繁调用 setNeedsDisplay 或 layoutSubviews。\n使用异步图像加载和解码： 避免在主线程上进行图像解码，以减轻 CPU 的负担。\n合理使用图像缓存： 尽量使用适合尺寸的图片，避免 GPU 处理过大图像带来的额外开销。\n\nUIView 的绘制原理UIView 是所有用户界面元素的基础。每个 UIView 对象都负责显示内容，并响应用户输入。UIView 的绘制过程涉及多个步骤，从层级视图系统到 Core Graphics 和 Core Animation。\nUIView 是基于层次结构的，每个 UIView 都可以有多个子视图 (subviews)。所有的视图都由一个根视图 (root view) 管理，通常是 UIViewController 的 view 属性。\n绘制流程：\n\n当需要更新界面时（如屏幕首次渲染、视图内容更新、视图大小变化等），系统会触发视图的绘制过程。\n系统调用视图的 setNeedsDisplay 或 setNeedsLayout 方法标记视图为“需要更新”状态。\n系统在下一个运行循环中调用 drawRect: 方法绘制视图。\n\nUIView 的绘制是通过 Core Graphics 来完成的。Core Graphics 是一个 2D 绘图引擎，可以进行图形绘制、图像处理等。Core Animation 负责将 UIView 的内容显示在屏幕上。它将所有的绘制操作作为动画图层 (CALayer&#96;) 的更新并进行合成，最后呈现给用户。\nUIView 绘制流程的关键步骤：\n\nsetNeedsDisplay 和 setNeedsLayout：\nsetNeedsDisplay：标记视图为需要重绘，会在下一次屏幕刷新时调用 drawRect: 方法。\nsetNeedsLayout：标记视图需要重新布局，会在下一次布局周期调用 layoutSubviews 方法。\n\n\ndrawRect:：\ndrawRect: 方法是 UIView 自定义绘制的入口。在这里，可以使用 Core Graphics 进行图形绘制。\n\n\n\n以下是一个自定义 UIView 的示例，它在屏幕上绘制一个简单的矩形：\nimport UIKitclass CustomView: UIView &#123;        // 仅在初始化时调用一次    override init(frame: CGRect) &#123;        super.init(frame: frame)        // 设置视图的一些属性，例如背景颜色        self.backgroundColor = UIColor.white    &#125;        required init?(coder: NSCoder) &#123;        super.init(coder: coder)    &#125;        // 重写 drawRect: 方法来执行自定义绘制。使用 Core Graphics API 来绘制一个蓝色的矩形。    override func draw(_ rect: CGRect) &#123;        super.draw(rect)                // 获取当前的绘图上下文，这是一个 Core Graphics 的 `CGContext` 对象，它代表着一个绘制环境。        guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;                // 设置填充颜色        context.setFillColor(UIColor.blue.cgColor)                // 创建一个矩形        let rectangle = CGRect(x: 50, y: 50, width: 200, height: 100)                // 在上下文中绘制矩形        context.addRect(rectangle)        context.drawPath(using: .fill)    &#125;&#125;// 使用自定义视图class ViewController: UIViewController &#123;        override func viewDidLoad() &#123;        super.viewDidLoad()                // 创建并添加自定义视图        let customView = CustomView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))        self.view.addSubview(customView)    &#125;&#125;\nUIView 的绘制原理核心是基于 Core Graphics 和 Core Animation，通过 drawRect: 方法进行自定义绘制。这个过程涉及到多个步骤，包括视图层次结构、绘制流程、上下文获取，以及最终的内容合成并呈现给用户。在实际开发中，自定义绘制的 UIView 往往用于实现特殊的图形效果或自定义 UI 控件。\n异步绘制异步绘制主要指的是在后台线程中处理绘制操作，以避免阻塞主线程。Core Graphics 和 UIKit 提供了支持异步绘制的功能。\n使用 Core Graphics 的异步绘制。使用 UIGraphicsBeginImageContextWithOptions 函数在后台线程中创建一个 CGContext。使用 GCD 或 NSOperationQueue 来在后台线程中进行绘制操作。完成绘制后，将结果返回主线程以更新 UI。下面是一个异步绘制的示例代码：\nimport UIKitclass AsyncDrawingView: UIView &#123;        private var asyncImage: UIImage?        override func draw(_ rect: CGRect) &#123;        super.draw(rect)                // 如果有异步绘制的图片，直接绘制它        asyncImage?.draw(in: rect)    &#125;        func drawAsync() &#123;        Task &#123;            // 创建图形上下文            let size = self.bounds.size            UIGraphicsBeginImageContextWithOptions(size, false, 0.0)            guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;                        // 进行绘制操作            context.setFillColor(UIColor.blue.cgColor)            context.fill(CGRect(x: 0, y: 0, width: size.width, height: size.height))                        // 获取绘制结果            let image = UIGraphicsGetImageFromCurrentImageContext()            UIGraphicsEndImageContext()                        // 更新 UI，回到主线程            await MainActor.run &#123;                self.asyncImage = image                self.setNeedsDisplay() // 触发 draw(_:) 方法重新绘制            &#125;        &#125;    &#125;&#125;\n使用 UIKit 的异步绘制\n对于复杂的异步绘制，特别是涉及 UIView 的情况下，可以考虑这两个方法。首先是自定义 CALayer 并实现其 draw(in:) 方法来进行异步绘制。其次是使用 UIView 的 draw(:) 方法，在子类中重写 draw(:) 方法，并结合异步操作来更新绘制内容。\nimport UIKitclass AsyncDrawingLayer: CALayer &#123;        override func draw(in ctx: CGContext) &#123;        super.draw(in: ctx)                Task &#123;            // 在子线程中执行绘制操作            await withCheckedContinuation &#123; continuation in                Task.detached &#123;                    // 执行绘制操作                    ctx.setFillColor(UIColor.red.cgColor)                    ctx.fill(self.bounds)                                        // 完成绘制操作后继续                    continuation.resume()                &#125;            &#125;                        // 回到主线程更新 UI            await MainActor.run &#123;                self.setNeedsDisplay() // 触发 draw(in:) 重新绘制            &#125;        &#125;    &#125;&#125;\n离屏渲染离屏渲染（Offscreen Rendering）在 iOS 中是指在显示器显示内容之前，先在内存中完成渲染。这种方式的主要代价体现在以下几个方面：\n\n内存消耗：离屏渲染会占用额外的内存，因为每次渲染都会创建一个新的图像缓冲区（即离屏缓存）。这些缓存可能会迅速消耗大量内存，特别是对于复杂的视图或高分辨率的图像。\n处理时间：进行离屏渲染时，CPU 和 GPU 需要额外的时间来处理渲染操作。这可能会导致渲染时间增加，影响到应用的流畅性。\n上下文切换：离屏渲染需要将渲染操作从主线程转移到后台线程或额外的图形上下文，这增加了上下文切换的开销。\n绘制次数：每次需要重新绘制时（例如视图的内容更新），都需要执行离屏渲染，这可能导致频繁的渲染操作，从而影响性能。\n\n产生离屏渲染的常见原因有：\n\n圆角（Corner Radius）：如果在视图或图层上应用圆角效果，iOS 需要在离屏缓存中完成这些操作，尤其是当圆角半径较大时。\n阴影（Shadow）：阴影效果通常需要离屏渲染，因为阴影需要在原始视图之外的区域进行处理。\n透明度（Opacity）：对于半透明的视图或图层，iOS 需要进行离屏渲染以正确处理混合效果。\n复杂的图形操作：比如路径（UIBezierPath）的复杂绘制，也可能导致离屏渲染。\n\n避免离屏渲染的优化。如果视图的内容不会频繁变化，可以将视图渲染到 layer.contents 中，从而避免每次绘制时的离屏渲染开销。尽量避免复杂的圆角、阴影效果，或者使用更简单的图形操作。如可能，减少对 layer 的属性设置，尤其是那些可能引起离屏渲染的属性。\n","categories":["性能优化"],"tags":["性能优化","卡顿监控"]},{"title":"防止卡顿的方法","url":"/2025/05/09/%E9%98%B2%E6%AD%A2%E5%8D%A1%E9%A1%BF%E7%9A%84%E6%96%B9%E6%B3%95/","content":"使用缓存在 iOS 上使用 NSCache 可以有效减少主线程上的工作负担，特别是在需要频繁访问和重复计算的情况下。以下是一个简单的 SwiftUI 示例，展示如何在应用中使用 NSCache 来缓存图像以减少加载时间和主线程的负担。\n示例代码：\nimport SwiftUI// 使用 `NSCache` 创建一个单例 `ImageCache` 类，用于缓存图像。class ImageCache &#123;    static let shared = NSCache&lt;NSString, UIImage&gt;()&#125;// 这是一个自定义的视图，用于异步加载和显示图像。struct AsyncImageView: View &#123;    let url: URL    @State private var image: UIImage? = nil        var body: some View &#123;        Group &#123;            if let image = image &#123;                Image(uiImage: image)                    .resizable()                    .scaledToFit()            &#125; else &#123;                ProgressView() // 显示加载进度                    // `onAppear` 修饰符用于在视图出现时启动图像加载。                    .onAppear &#123;                        loadImage()                    &#125;            &#125;        &#125;    &#125;        // 在 `loadImage` 函数中，首先尝试从 `NSCache` 中获取图像。如果图像已经缓存，则直接使用；否则，它将在后台线程上异步加载图像，并在加载完成后更新 UI。    private func loadImage() &#123;        // 尝试从缓存中获取图像        if let cachedImage = ImageCache.shared.object(forKey: url.absoluteString as NSString) &#123;            self.image = cachedImage            return        &#125;                // 异步加载图像        DispatchQueue.global().async &#123;            if let data = try? Data(contentsOf: url), let loadedImage = UIImage(data: data) &#123;                // 将图像存储到缓存中                ImageCache.shared.setObject(loadedImage, forKey: url.absoluteString as NSString)                                // 更新 UI 必须在主线程上                DispatchQueue.main.async &#123;                    self.image = loadedImage                &#125;            &#125;        &#125;    &#125;&#125;// 显示 `AsyncImageView`，并提供要加载的图像 URL。struct ContentView: View &#123;    let imageUrl = URL(string: &quot;https://www.example.com/image.jpg&quot;)! // 替换为实际的图像 URL        var body: some View &#123;        AsyncImageView(url: imageUrl)            .frame(width: 300, height: 300)            .padding()    &#125;&#125;@mainstruct CacheExampleApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()        &#125;    &#125;&#125;\n\n添加观察者使用通知中心（NotificationCenter）来监听通知是一种常见的方式，可以有效地减少主线程的负担，从而提高应用的响应性。你可以通过添加观察者来监听特定的通知，并在接收到通知时再执行相应的操作，避免在主线程上一直等待，阻碍其它交互操作。以下是一个简单的 SwiftUI 示例，展示如何使用 NotificationCenter 来监听和处理通知。\n示例代码：\nimport SwiftUIimport Combine// 自定义通知名称extension Notification.Name &#123;    static let customNotification = Notification.Name(&quot;customNotification&quot;)&#125;struct ContentView: View &#123;    @State private var value: Int = 0    private var notificationObserver: AnyCancellable?        var body: some View &#123;        VStack &#123;            Text(&quot;Value: \\(value)&quot;)                .padding()                        // 当用户点击按钮时，`NotificationCenter.default.post` 方法会发布一个通知，并在 `userInfo` 中传递一个新的值。            Button(&quot;Increase Value&quot;) &#123;                // 发送通知                NotificationCenter.default.post(name: .customNotification, object: nil, userInfo: [&quot;newValue&quot;: value + 1])            &#125;        &#125;        // 在 `onAppear` 中，通过 `NotificationCenter.default.publisher(for:)` 添加一个通知观察者。当接收到通知时，`sink` 闭包会被调用，更新视图中的状态。        .onAppear &#123;            // 监听自定义通知            notificationObserver = NotificationCenter.default.publisher(for: .customNotification)                .sink &#123; notification in                    if let newValue = notification.userInfo?[&quot;newValue&quot;] as? Int &#123;                        value = newValue                    &#125;                &#125;        &#125;        // 在 `onDisappear` 中，通过调用 `cancel` 方法取消观察者，避免潜在的内存泄漏。        .onDisappear &#123;            // 取消观察者订阅            notificationObserver?.cancel()        &#125;    &#125;&#125;@mainstruct MyApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()        &#125;    &#125;&#125;\n异步为了避免主线程卡死，可以利用 Swift Concurrency 技术（如 async&#x2F;await）将耗时的计算任务转移到后台线程执行，同时在任务完成后将结果更新到主线程上。下面是一个使用 Swift Concurrency 技术的 SwiftUI 示例，展示如何在后台线程执行预加载任务，并在主线程上更新 UI。\n示例代码\nimport SwiftUIstruct ContentView: View &#123;    @State private var data: String = &quot;Loading...&quot;        var body: some View &#123;        VStack &#123;            Text(data)                .padding()                        // 用户可以点击按钮来手动触发数据加载任务，这时任务会在后台线程执行，而不会阻塞主线程。            Button(&quot;Load Data&quot;) &#123;                Task &#123;                    await loadData()                &#125;            &#125;        &#125;        .onAppear &#123;            // 在 SwiftUI 的 `onAppear` 或者按钮点击事件中，使用 `Task &#123;&#125;` 启动一个异步任务。这可以让你在不阻塞主线程的情况下执行耗时操作。            Task &#123;                // `loadData()` 函数是一个异步函数，在这个函数中使用 `await` 来等待 `performHeavyTask()` 的结果。`performHeavyTask()` 模拟了一个耗时的任务，如预加载数据或复杂的计算。                await loadData()            &#125;        &#125;    &#125;        // 异步加载数据    func loadData() async &#123;        // 在后台线程上执行耗时任务        let result = await performHeavyTask()                // 为了更新主线程上的 UI，你需要显式地将操作切换回主线程。`MainActor.run &#123;&#125;` 确保在主线程上执行更新操作。        await MainActor.run &#123;            data = result        &#125;    &#125;        // 模拟耗时任务    func performHeavyTask() async -&gt; String &#123;        // 模拟一个耗时的操作，比如一个复杂的计算或数据加载任务。实际开发中，这可以替换为网络请求或数据库操作等。        try? await Task.sleep(nanoseconds: 2_000_000_000) // 2秒                return &quot;Data Loaded&quot;    &#125;&#125;@mainstruct MyApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()        &#125;    &#125;&#125;\n这个示例展示了如何使用 Swift Concurrency 技术将耗时任务移到后台线程执行，从而避免主线程卡顿，并在任务完成后安全地更新 UI。这样可以确保你的应用在执行复杂任务时依然保持流畅的用户体验。\n","categories":["性能优化"],"tags":["性能优化","卡顿监控"]}]