[{"title":"Day1-UIKit事件传递机制 & Responder Chain","url":"/2025/04/23/Day1-UIKit%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6-Responder-Chain/","content":"UIKit 事件传递机制 &amp; Responder Chain一、事件类型UIKit 中主要的事件类型包括：\n\n触摸事件（Touch Events）：如 tap、swipe、pinch 等。\n运动事件（Motion Events）：如摇动设备。\n远程控制事件（Remote-Control Events）：如耳机控制、CarPlay。\n按键事件（Press Events）（仅限 tvOS 或支持硬件键盘时的 iOS）。\n\n\n二、事件传递流程\n事件产生：\n\n事件由硬件（屏幕、传感器等）检测后交给系统。\niOS 将事件加入到主线程的 UIApplication 对象中进行分发。\n\n\n事件分发路径：\n\nUIApplication → UIWindow → UIView\n\n\n命中测试（Hit-Testing）：\n\n从根视图（window 的 rootView）开始递归查找目标视图。\n使用两个方法：\npoint(inside:with:)\nhitTest(_:with:)\n\n\n最终找到最合适的视图接收触摸事件。\n\n\n\n\n三、Responder Chain（响应者链）1. 什么是 Responder Chain？Responder Chain 是一条事件响应链，用来处理视图无法响应的事件。\n2. Responder Chain 构成一个 UIResponder 对象（如 UIView、UIViewController）可以传递事件给其上层响应者：UIView → UIViewController → UIWindow → UIApplication → AppDelegate\n如果某个对象无法处理事件，它会把事件传递给下一个响应者。\n3. UIResponder 方法\n\n\n方法名\n说明\n\n\n\ntouchesBegan(_:with:)\n开始触摸\n\n\ntouchesMoved(_:with:)\n触摸移动\n\n\ntouchesEnded(_:with:)\n触摸结束\n\n\ntouchesCancelled(_:with:)\n触摸被取消\n\n\n还可以通过 canBecomeFirstResponder 和 becomeFirstResponder() 控制焦点。\n\n四、自定义事件传递（常见场景）1. UIView 不响应事件可能是因为以下原因：\n\nisUserInteractionEnabled = false\nalpha &lt; 0.01\nhidden = true\n\n2. 自定义控件事件传递可重写以下方法：\n\nhitTest(_:with:)：决定谁是事件的最终响应者。\npoint(inside:with:)：判断点是否在当前视图内。\n\n\n五、Responder Chain 应用场景\n控件事件传递：如 UIButton 点击事件向上传递。\n菜单处理：如复制粘贴菜单响应。\n键盘响应管理。\n自定义事件路由（target-action 无法处理时）。\n\n\n六、调试技巧\n使用 View Debugger 检查视图层级。\n打断点调试 hitTest 和 touchesBegan。\n查看 next 属性追踪 Responder Chain。\n\n\n七、总结\nUIKit 事件从 UIApplication 开始，经过 UIWindow 最终传递给具体的 UIView。\nResponder Chain 是事件冒泡机制的实现，支持事件的多级处理。\n通过合理利用 hitTest: 和 Responder Chain，可以实现复杂交互需求。\n\n","categories":["基础"]},{"title":"Day1-两数之和","url":"/2025/04/23/Day1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"🧠 算法题：两数之和（Two Sum）\n🎯 题目描述：\n给定一个整数数组 nums 和一个目标值 target，请你在数组中找出两个加起来等于目标值的数字，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但数组中同一个元素不能使用两遍。\n\n💡 示例：\n输入: nums = [2, 7, 11, 15], target = 9输出: [0, 1] 解释: 因为 nums[0] + nums[1] == 9\n\n✅ 解题要求：\t•\t时间复杂度尽量做到 O(n)\t•\t返回一组下标即可，无需考虑顺序\t•\t提供 Swift 或 Objective-C 实现\n\n✨ 提示：\n你可以用哈希表记录访问过的数字及其下标，在遍历时直接判断 target - 当前值 是否存在于 map 中。\n\n🚀 拓展思考（建议尝试）：\t1.\t如果要求返回所有可能的两数组合（即可能有多个答案），你会怎么做？\t2.\t如果输入是一个有序数组，你是否可以用双指针优化？\n\n🔧 模板（Swift 示例）：\nfunc twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;    var map = [Int: Int]()  // 记录数字和对应的下标    for (index, num) in nums.enumerated() &#123;        let complement = target - num        if let otherIndex = map[complement] &#123;            return [otherIndex, index]        &#125;        map[num] = index    &#125;    return []&#125;\n\nJS版本：\n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123;    let map = new Map();    for (let i = 0; i &lt; nums.length; i++) &#123;        let diff = target - nums[i];        if (map.has(diff)) &#123;            return [map.get(diff), i];        &#125;        map.set(nums[i], i);    &#125;&#125;;\n\n👉 LeetCode 1. 两数之和\n","categories":["算法"],"tags":["算法"]},{"title":"Day2-用栈实现队列","url":"/2025/04/24/Day2-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","content":"🔗 LeetCode 232 - Implement Queue using Stacks\n📌 题目描述：使用两个栈 stackIn 和 stackOut 实现一个队列，支持以下操作：\n\npush(x)：将元素 x 推到队列的末尾\npop()：移除队列开头的元素并返回\npeek()：返回队列开头的元素\nempty()：返回队列是否为空\n\n要求：只能使用栈的标准操作（push, pop, peek, empty）\n\n💡 解题思路：\n入队操作（push）直接往 stackIn 中加元素；\n出队操作（pop 或 peek）时，如果 stackOut 为空，则将 stackIn 中的所有元素倒序转移到 stackOut；\n保证先进先出（FIFO）的顺序。\n\n\n✅ JavaScript 实现：var MyQueue = function () &#123;    this.stackIn = [];    this.stackOut = [];&#125;;MyQueue.prototype.push = function (x) &#123;    this.stackIn.push(x);&#125;;MyQueue.prototype.pop = function () &#123;    if (this.stackOut.length === 0) &#123;        while (this.stackIn.length) &#123;            this.stackOut.push(this.stackIn.pop());        &#125;    &#125;    return this.stackOut.pop();&#125;;MyQueue.prototype.peek = function () &#123;    if (this.stackOut.length === 0) &#123;        while (this.stackIn.length) &#123;            this.stackOut.push(this.stackIn.pop());        &#125;    &#125;    return this.stackOut[this.stackOut.length - 1];&#125;;MyQueue.prototype.empty = function () &#123;    return this.stackIn.length === 0 &amp;&amp; this.stackOut.length === 0;&#125;;\n\n\n\n🧠 思考拓展：\n如果反过来是“用队列实现栈”应该怎么做？👉 LeetCode 225\n队列相关拓展题：滑动窗口最大值、最小栈等\n\n","categories":["算法"],"tags":["算法"]},{"title":"Day2-View 布局流程","url":"/2025/04/24/Day2-View-%E5%B8%83%E5%B1%80%E6%B5%81%E7%A8%8B/","content":"View 布局流程详解一、布局流程总览iOS 的视图布局流程由 UIKit 管理，核心遵循「从父到子、从外向内」的递归更新方式。涉及的关键方法有：\n\nlayoutSubviews：真正进行子视图位置布局的地方\nsetNeedsLayout：标记视图为需要重新布局\nlayoutIfNeeded：立即强制布局\n\n布局流程如下：属性变化（如 frame）或手动触发↓调用 setNeedsLayout（标记需要布局）↓下一个 runloop 执行 layoutIfNeeded↓系统递归调用 layoutSubviews 进行布局\n\n二、关键方法详解1. setNeedsLayout\n作用：标记当前视图为“需要重新布局”\n调用时机：当视图状态或依赖数据变化时\n注意：不会立即执行 layoutSubviews，而是在下一个 runloop 进行布局\n\n[self.view setNeedsLayout];\n\n2. layoutIfNeeded\n作用：立即执行布局流程（如果已标记）\n常用场景：动画中强制更新 layout，确保视图状态正确  [self.view layoutIfNeeded];\n\n3. layoutSubviews\n作用：布局子视图，子类通过重写此方法来自定义布局逻辑\n调用方式：系统自动调用，或通过 layoutIfNeeded 间接触发  - (void)layoutSubviews &#123;    [super layoutSubviews];    self.label.frame = CGRectMake(10, 10, 100, 40);&#125;\n\n三、布局触发时机布局流程会在以下情况下自动触发：\n\n视图初始化完成后首次添加到视图层级中\nframe &#x2F; bounds &#x2F; center 属性改变\n调用 setNeedsLayout + layoutIfNeeded\n屏幕旋转、设备方向变化\nAuto Layout 约束变化\n\n四、Auto Layout 参与布局流程当使用 Auto Layout（自动布局）时：\n\n不推荐在 layoutSubviews 中设置 frame\n更新约束应在 updateConstraints 方法中完成\nupdateConstraints → layoutSubviews → drawRect 是完整的调用链  - (void)updateConstraints &#123;    // 更新约束    [super updateConstraints];&#125;\n\n五、UIView 与 CALayer 的关系\n每个 UIView 都有一个对应的 CALayer\nUIView.frame 实际上是操作 CALayer.frame\n布局本质上是在更新图层的属性  NSLog(@&quot;%@&quot;, NSStringFromCGRect(self.view.layer.frame));\n\n六、文字版布局流程图[视图属性变更]      ↓[setNeedsLayout] → 标记布局      ↓[下一个 runloop]      ↓[layoutIfNeeded] → 判断并触发布局      ↓[layoutSubviews] → 更新子视图 frame\n\n七、面试高频问题整理Q1：layoutSubviews 和 drawRect 有什么区别？\nlayoutSubviews：用于更新子视图的布局\ndrawRect：用于自定义视图绘图（如 Core Graphics）\n\nQ2：如何立即触发布局？[self.view setNeedsLayout];[self.view layoutIfNeeded];\n\nQ3：什么时候会调用 layoutSubviews？\n添加到父视图后\nframe 改变\nsetNeedsLayout + layoutIfNeeded\nAuto Layout 触发\n\nQ4：如何在动画中确保布局生效？[UIView animateWithDuration:0.3 animations:^&#123;    // 修改布局前置条件    [self.view layoutIfNeeded]; // 强制立即布局&#125;];\n\n八、参考资料\nApple Developer 文档：UIView Class Reference\n官方指南：View Programming Guide for iOS\n\n","categories":["基础"]},{"title":"Day3-有效的括号","url":"/2025/04/25/Day3-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","content":"🔗 LeetCode 20 - Valid Parentheses\n📌 题目描述给定一个只包括 &#39;(&#39;, &#39;)&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;[&#39;, &#39;]&#39; 的字符串 s，判断字符串是否是有效的。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n空字符串也为有效字符串。\n\n\n💡 解题思路\n使用栈结构来处理括号匹配；\n遇到左括号就入栈，遇到右括号时判断是否和栈顶配对；\n若匹配，则弹出栈顶；否则直接返回 false；\n最后栈为空，则为合法字符串。\n\n\n✅ JavaScript 实现var isValid = function (s) &#123;    const stack = [];    const map = &#123;        &#x27;)&#x27;: &#x27;(&#x27;,        &#x27;&#125;&#x27;: &#x27;&#123;&#x27;,        &#x27;]&#x27;: &#x27;[&#x27;    &#125;;    for (let char of s) &#123;        if ([&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;].includes(char)) &#123;            stack.push(char);        &#125; else &#123;            if (stack.pop() !== map[char]) &#123;                return false;            &#125;        &#125;    &#125;    return stack.length === 0;&#125;;\n\n\n🧠 思考拓展\n括号匹配是栈结构经典应用，请理解其底层思想；\nLeetCode 拓展题推荐：\n22. Generate Parentheses（括号生成）\n32. Longest Valid Parentheses（最长有效括号）\n\n\n\n","categories":["算法"]},{"title":"Day4-Block 内存管理 & 循环引用分析","url":"/2025/04/27/Day4-Block-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90/","content":"Block 内存管理 &amp; 循环引用分析1. Block 的结构体本质Block 在底层其实是一个结构体：\nstruct Block_literal &#123;    void *isa;                      // 指向 Block 类对象    int flags;                      // 标志位（是否有 copy/dispose 等）    int reserved;                   // 保留字段    void (*invoke)(void *, ...);     // 函数指针，Block 实际执行逻辑    struct Block_descriptor *descriptor;  // Block 描述信息    // captured variables...&#125;;\n\n2. 捕获外部变量时，发生了什么？\n\n\n变量类型\n捕获方式\n内存管理行为\n\n\n\n基本数据类型（int&#x2F;float）\n值拷贝\n不影响内存管理\n\n\nObjective-C 对象\n强引用（retain）\n需要注意循环引用\n\n\n__block 修饰的对象\n指针拷贝，但本身仍可能强引用\n需配合 __weak __block\n\n\n3. Block 的 copy 和 dispose 函数Block 如果捕获了对象，底层会自动生成 copy 和 dispose 函数：\n\ncopy ： retain 捕获的对象\ndispose ： release 捕获的对象\n\n简化示例：\nvoid _Block_copy(void *dst, void *src) &#123;    objc_retain(capturedObj);&#125;void _Block_dispose(void *src) &#123;    objc_release(capturedObj);&#125;\n\n4. 深层次的循环引用分析常见导致 Block 循环引用的场景：\n\nNSTimer &#x2F; CADisplayLink &#x2F; GCD\n异步任务 (dispatch_async)\n链式调用\n\n标准防循环写法：\n__weak typeof(self) weakSelf = self;self.myBlock = ^&#123;    __strong typeof(weakSelf) strongSelf = weakSelf;    if (!strongSelf) return;    [strongSelf doSomething];&#125;;\n\n\n\nBlock 高频面试问答1. Block 的类型有哪些？分别什么时候出现？答：\n\nGlobal Block：不捕获外部变量，存储在全局区。\nStack Block：捕获了外部变量，存储在栈上。\nMalloc Block：拷贝自 Stack Block，存储在堆上。\n\nARC 下只存在 Global Block 和 Malloc Block。\n\n2. Block 在 ARC 下是如何内存管理的？答：\n\nARC 会自动对 Block 执行 copy 操作，将其从栈拷贝到堆上。\n使用 __strong 指针持有 Block 时，默认是堆 Block。\n\n\n3. 如何判断一个 Block 是否造成了循环引用？答：\n\n检查 Block 内是否使用了 self。\n检查 self 是否强引用了 Block（比如 Block 是 self 的属性）。\n使用 Instruments 的 Leaks 工具分析内存泄漏。\n\n\n4. __block 修饰符在 ARC 和 MRC 下分别是什么行为？答：\n\nMRC：__block 允许修改变量，但不会自动管理引用计数。\nARC：__block 允许修改，但并不会弱化引用关系，需要自己处理弱引用。\n\n\n5. Block 为什么容易引起内存泄漏？具体有哪些场景？答：因为 Block 捕获变量是强引用，特别是对象指针，如下场景常出问题：\n\nUIViewController 的 Block 属性内部引用了 self\nNSTimer、CADisplayLink、GCD 中的 Block\n\n解决办法：\n\n使用 __weak\n定时器使用 weakProxy\nGCD 注意生命周期控制\n\n\n小结理解 Block 的内存特性、引用关系变化（stack → heap）、以及在 ARC 下的默认 copy 机制，是彻底掌握 iOS 内存管理的关键。\n","categories":["基础"]},{"title":"Day4-有效的字母异位词","url":"/2025/04/27/Day4-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","content":"🔗 LeetCode 242 - Valid Anagram\n📌 题目描述：给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。\n字母异位词的定义：如果两个字符串中的字母出现的频率相同且字符完全一致，那么这两个字符串是字母异位词。\n\n💡 解题思路：•\t将两个字符串 s 和 t 的字母出现频次统计出来，若两个字符串的字母频次完全相同，则它们是字母异位词。\n•\t通过使用哈希表或数组存储字母的频率。\n\n\n✅ JavaScript 实现：var isAnagram = function (s, t) &#123;    if (s.length !== t.length) return false;        const count = new Array(26).fill(0);        for (let i = 0; i &lt; s.length; i++) &#123;        count[s.charCodeAt(i) - &#x27;a&#x27;.charCodeAt(0)]++;        count[t.charCodeAt(i) - &#x27;a&#x27;.charCodeAt(0)]--;    &#125;        for (let i = 0; i &lt; 26; i++) &#123;        if (count[i] !== 0) return false;    &#125;        return true;&#125;;\n\n\n\n\n🧠 思考拓展：•\t字母异位词问题的优化：如何减少不必要的比较，提升算法效率？\n•\t对比其他字符串相关的题目，比如 387. First Unique Character in a String。\n\n\n","categories":["算法"]},{"title":"Day3-Block 分类、变量捕获与作用域","url":"/2025/04/25/Day3-Block-%E5%88%86%E7%B1%BB%E3%80%81%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"Block 分类、变量捕获与作用域一、Block 的分类Block 在 Objective-C 中，根据其存储位置和生命周期分为以下三类：\n\n\n\nBlock 类型\n存储位置\n特点说明\n\n\n\nGlobal Block\n全局区\n不捕获外部变量\n\n\nStack Block\n栈上\n捕获外部变量，随栈帧销毁\n\n\nHeap Block\n堆上\n捕获外部变量，Block_copy 后存在堆上\n\n\n示例：void (^block1)(void) = ^&#123;    NSLog(@&quot;Hello&quot;);&#125;;// Global Blockint a = 10;void (^block2)(void) = ^&#123;    NSLog(@&quot;a = %d&quot;, a);&#125;;// Stack Blockvoid (^block3)(void) = [block2 copy];// Heap Block\n\n\n二、变量捕获（Captured Variables）1. 默认捕获（值语义）Block 默认以值方式拷贝局部变量，不可修改。\nint a = 5;void (^block)(void) = ^&#123;    NSLog(@&quot;a is %d&quot;, a);&#125;;a = 6;block(); // 输出 a is 5\n\n2. __block 修饰（引用语义）允许在 Block 内部修改外部变量。\n__block int a = 5;void (^block)(void) = ^&#123;    a = 10;&#125;;block();NSLog(@&quot;a is %d&quot;, a); // 输出 a is 10\n\n3. 对象捕获（指针语义）对象变量以指针形式捕获，会被强引用。\nNSString *str = @&quot;Hello&quot;;void (^block)(void) = ^&#123;    NSLog(@&quot;%@&quot;, str);&#125;;// str 被 retain\n\n\n三、作用域与内存管理生命周期：\nStack Block 生命周期短，超出作用域会被销毁。\n需要异步使用时，必须将 Block copy 到堆上，变为 Heap Block。\nARC 下自动进行 copy 操作；MRC 需手动调用 Block_copy。\n\n示例（ARC 异步安全）：dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;    NSLog(@&quot;Block executed&quot;);&#125;);// ARC 自动 copy 到堆\n\n\n四、Swift 中的闭包捕获Swift 中闭包默认强引用捕获对象：\nclass MyClass &#123;    var name = &quot;Test&quot;    func doSomething() &#123;        DispatchQueue.global().async &#123; [weak self] in            print(self?.name ?? &quot;nil&quot;)        &#125;    &#125;&#125;\n\n使用 [weak self] &#x2F; [unowned self] 可避免循环引用。\n\n五、小结对比表\n\n\n分类\n是否捕获变量\n存储位置\n生命周期控制\n\n\n\nGlobal Block\n否\n全局区\n程序生命周期内常驻\n\n\nStack Block\n是\n栈上\n随栈帧销毁\n\n\nHeap Block\n是\n堆上\nBlock_copy 后存在于堆中\n\n\n","categories":["基础"]},{"title":"Day5-两数之和 II - 输入有序数组","url":"/2025/04/28/Day5-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"🔗 LeetCode 167 - Two Sum II - Input Array Is Sorted\n📌 题目描述给定一个已按升序排列的整数数组 numbers 和一个目标值 target，请你在数组中找出两个数，使得它们的和为目标值 target，并返回这两个数的下标。\n注意：  \n\n返回的答案是一个 1 索引的数组。\n假设每个输入只对应一个答案，且你不可以重复使用数组中的元素。\n\n\n💡 解题思路\n由于数组已排序，可以使用双指针法：\n\n初始化两个指针，一个指向数组的开头，一个指向数组的末尾。\n如果两指针指向的元素之和等于目标值，返回这两个指针的下标；\n如果和小于目标值，说明需要增大和，左指针右移；\n如果和大于目标值，说明需要减小和，右指针左移。\n\n\n这种方法时间复杂度是 O(n)，效率较高。\n\n\n\n✅ JavaScript 实现var twoSum = function (numbers, target) &#123;    let left = 0;    let right = numbers.length - 1;        while (left &lt; right) &#123;        const sum = numbers[left] + numbers[right];        if (sum === target) &#123;            return [left + 1, right + 1];  // 注意返回的下标是从 1 开始的        &#125; else if (sum &lt; target) &#123;            left++;        &#125; else &#123;            right--;        &#125;    &#125;&#125;;\n\n\n🧠 思考拓展\n如果数组不是有序的，如何解决这个问题？\n本题和 LeetCode 1. Two Sum 的区别是什么？它是如何利用排序优化解法的？\n\n\n","categories":["算法"]},{"title":"Day6-Runtime 实战技巧","url":"/2025/04/29/Day6-Runtime-%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/","content":"一、定义Runtime 是什么？\n\nObjective-C 的 Runtime 实际上是 C 语言的一套函数和类库，用于支持 Objective-C 编程语言的动态性，包括类的创建、方法调用、属性访问等。\n\n\n二、Runtime 实战技巧1.Method Swizzling（方法交换）1. 什么是 Method Swizzling？\n定义：在程序运行时，交换两个方法实现的过程。\n本质：修改方法对应的 IMP（指向函数实现的指针）。\n常用场景：\n给系统方法加功能\n替换系统方法行为\nAOP\n\n\n\n2. 如何实现 Swizzling？常用 API：\nMethod class_getInstanceMethod(Class cls, SEL name);void method_exchangeImplementations(Method m1, Method m2);\n\n代码示例：\n@implementation UIViewController (Swizzling)+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Method originalMethod = class_getInstanceMethod(self, @selector(viewWillAppear:));        Method swizzledMethod = class_getInstanceMethod(self, @selector(my_viewWillAppear:));        method_exchangeImplementations(originalMethod, swizzledMethod);    &#125;);&#125;- (void)my_viewWillAppear:(BOOL)animated &#123;    NSLog(@&quot;页面将要出现：%@&quot;, self);    [self my_viewWillAppear:animated];&#125;@end\n\n3. 注意事项\n+load 和 dispatch_once 保证只执行一次。\n确保方法存在，避免引起程序崩溃。\n注意继承关系和子类覆盖问题。\n\n\n2.消息转发机制1. 什么是消息转发？\n当对象收到无法响应的消息，有三次机会处理：\n动态方法解析（resolveInstanceMethod:）\n备用接收者（forwardingTargetForSelector:）\n完整消息转发（forwardInvocation:）\n\n\n\n2. 详细流程（１）动态方法解析+ (BOOL)resolveInstanceMethod:(SEL)sel\n示例：\n+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;    if (sel == @selector(run)) &#123;        class_addMethod(self, sel, (IMP)runFunction, &quot;v@:&quot;);        return YES;    &#125;    return [super resolveInstanceMethod:sel];&#125;\n\n（２）快速转发- (id)forwardingTargetForSelector:(SEL)aSelector\n示例：\n- (id)forwardingTargetForSelector:(SEL)aSelector &#123;    if (aSelector == @selector(run)) &#123;        return self.delegate;    &#125;    return [super forwardingTargetForSelector:aSelector];&#125;\n\n（３）完整消息转发- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector- (void)forwardInvocation:(NSInvocation *)anInvocation\n示例：\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;    if (aSelector == @selector(run)) &#123;        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];    &#125;    return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;    SEL sel = [anInvocation selector];    if ([self.delegate respondsToSelector:sel]) &#123;        [anInvocation invokeWithTarget:self.delegate];    &#125; else &#123;        [super forwardInvocation:anInvocation];    &#125;&#125;\n\n3. 关联对象 (Associated Objects)定义：在不改动原类的基础上，给分类、扩展类增加实体属性。\n常用 API：\n\nobjc_setAssociatedObject\nobjc_getAssociatedObject\n\n应用场景：\n\nUIButton 增加防重复点击时间间隔\n\n4. 动态生成类和方法常用 API：\n\nobjc_allocateClassPair\nclass_addMethod\n\n应用场景：\n\nKVO 内部原理（创建子类）\nORM框架自动生成对应属性\n\n5. 完全自动 NSCoding 完成思路：通过 Runtime 遍历 ivar，自动 encode&#x2F;decode，无需手写代码。\n应用场景：\n\nModel 持久化\n简化用户数据处理\n\n6. 实现安全防护（防 Crash）思路：更换 NSArray, NSDictionary, NSString 等类的方法，防止路径错误、索引越界等 crash。\n应用场景：\n\n安全性框架 SafeKit\n项目安全级别提升\n\n7. 数据模型实体化（完全自动化等）思路：通过 property 列表，根据 key-value 将 JSON 转为 Model，或反转。\n应用场景：\n\nYYModel\nMJExtension\n\n8. 方法替换 IMP应用：\n\nhook 系统方法，并加自己逻辑\n控制方法执行流程\n\n示例：\n\n在 App 进入前后台时，统一管理封装\n\n9. 高级消息转发 (NSProxy)应用：\n\n弱代理（避免循环引用、Timer 泄漏）\n多代理同步分发\n性能强化\n\n\n三、实战案例案例1：防止 UIButton 重复点击背景\n\nUIButton 连续点击容易造成接口重复请求。\n想给所有 UIButton 加防抖，不改动现有业务代码。\n\n\n思路\n用 Method Swizzling，替换 sendAction:to:forEvent: 方法，在里面加节流逻辑。\n\n代码示例\nUIButton+AntiRepeat.h\n#import &lt;UIKit/UIKit.h&gt;@interface UIButton (AntiRepeat)@property (nonatomic, assign) NSTimeInterval eventInterval; // 点击间隔@property (nonatomic, assign) NSTimeInterval lastEventTime; // 上次点击时间@end\nUIButton+AntiRepeat.m\n#import &quot;UIButton+AntiRepeat.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIButton (AntiRepeat)+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Method original = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));        Method swizzled = class_getInstanceMethod(self, @selector(my_sendAction:to:forEvent:));        method_exchangeImplementations(original, swizzled);    &#125;);&#125;// 关联对象 eventInterval- (NSTimeInterval)eventInterval &#123;    return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setEventInterval:(NSTimeInterval)eventInterval &#123;    objc_setAssociatedObject(self, @selector(eventInterval), @(eventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;// 关联对象 lastEventTime- (NSTimeInterval)lastEventTime &#123;    return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setLastEventTime:(NSTimeInterval)lastEventTime &#123;    objc_setAssociatedObject(self, @selector(lastEventTime), @(lastEventTime), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;// 新的方法- (void)my_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;    if (NSDate.date.timeIntervalSince1970 - self.lastEventTime &lt; self.eventInterval) &#123;        return; // 点击间隔太短，忽略    &#125;    self.lastEventTime = NSDate.date.timeIntervalSince1970;    [self my_sendAction:action to:target forEvent:event];&#125;@end\n\n\n\n使用\nUIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];btn.eventInterval = 1.0; // 设置 1 秒内不能重复点击\n\n讲解要点\n\nsendAction:to:forEvent: 是 UIButton 处理点击事件的入口。\n通过 Swizzling，在不改业务代码的情况下统一加了防抖。\n使用 objc_setAssociatedObject 给分类动态添加属性，记录最后一次点击时间。\n\n案例2：用 NSProxy 实现弱代理（防止 Timer 循环引用）\nNSProxy 作为中介\n弱持 target\n\n背景\n\nNSTimer 默认强引用 target，容易造成内存泄漏（循环引用）。\n\n\n思路\n使用 NSProxy 中转，让 Timer 弱引用真正的 target。\n\n代码示例\nTimerWeakProxy.h\n#import &lt;Foundation/Foundation.h&gt;@interface TimerWeakProxy : NSProxy+ (instancetype)proxyWithTarget:(id)target;@end\nTimerWeakProxy.m\n#import &quot;TimerWeakProxy.h&quot;@interface TimerWeakProxy ()@property (nonatomic, weak) id target;@end@implementation TimerWeakProxy+ (instancetype)proxyWithTarget:(id)target &#123;    TimerWeakProxy *proxy = [TimerWeakProxy alloc];    proxy.target = target;    return proxy;&#125;- (id)forwardingTargetForSelector:(SEL)selector &#123;    return self.target;&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123;    [invocation invokeWithTarget:self.target];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;    return [self.target methodSignatureForSelector:sel];&#125;@end\n\n\n使用\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0                                              target:[TimerWeakProxy proxyWithTarget:self]                                            selector:@selector(timerAction)                                            userInfo:nil                                             repeats:YES];\n\n\n讲解要点\n\nTimerWeakProxy 持有 target 的弱引用，防止循环引用。\nforwardingTargetForSelector: 提供快速消息转发，提高性能。\n\n案例3：自动 JSON -&gt; Model 映射\n利用 property 列表遍历\n高效方便，性能好\n\n案例4：安全防护套件\nNSArray、NSDictionary 进行方法替换，防止错误操作\n\n\n四、完整思维图\n\n\n技术\n作用\n具体场景\n\n\n\nMethod Swizzling\n修改系统方法\nAOP 打点\n\n\n消息转发\n动态处理未知方法\n弱代理\n\n\nAssociated Object\n扩展分类属性\nUIButton 防重点\n\n\n自动 NSCoding\n自动化存储连贯\nModel 持久化\n\n\nNSProxy\n高级转发\nTimer 弱代理\n\n\n\n五、常考问题\n说说你对 Runtime 的理解？\n\n\nRuntime 是 OC 的运行时系统，允许程序在运行时进行对象操作（如消息发送、方法交换、类创建等）。\n动态性是 Objective-C 最重要的特性之一，基于 Runtime 实现。\n\n\n\n什么是 Method Swizzling？使用时注意什么？\n\n\n定义：交换两个方法的实现。\n注意：\n使用 dispatch_once 保证只交换一次。\n确认方法存在再交换，避免崩溃。\n维护好调用链，防止死循环。\n避免过度使用，破坏封装性。\n\n\n\nMethod Swizzling 常用在哪些场景？\n\n\n统一加日志打点（比如 UIViewController 生命周期）\n替换系统方法功能（如统计点击事件）\nAOP 编程实践\n框架内部增强（如 AFNetworking 的某些 hook）\n\n\n\n消息发送流程是怎样的？\n\n\n调用方法 -&gt; 转成 objc_msgSend 发送消息。\n如果找不到方法：\n动态方法解析（resolveInstanceMethod:）\n快速转发（forwardingTargetForSelector:）\n完整消息转发（forwardInvocation:）\n最后抛出 unrecognized selector sent to instance 异常。\n\n\n\n\n\n消息转发和代理模式有什么关系？\n\n\n代理（delegate）本质就是消息转发的一种应用。\n可以通过 forwardingTargetForSelector: 把不支持的方法交给代理对象执行。\n复杂代理模式（如 NSProxy 多代理）就是用完整消息转发实现的。\n\n\n\nSwizzling 和 Hook 的区别？\n\n\nSwizzling：指“方法交换”，主要改变对象的方法实现。\nHook：更广义，指拦截并修改程序执行过程，可以是方法层面、函数层面（Fishhook）、甚至是汇编指令层面。\n\n\n\n为什么 +load 方法适合做 Swizzling？\n\n\n+load 是在类（或分类）被加载到内存时立即调用的，优先于 main()。\n保证在对象使用前就完成方法交换。\n\n补充：如果想更灵活控制，某些框架（如 Aspects）会在 +initialize 做 Swizzling，但要注意 initialize 只会在第一次发送消息前调用。\n\n\n使用 Runtime 有哪些风险？\n\n\n方法交换过多，容易导致难以维护和调试。\n消息转发链过长，可能导致性能下降。\n动态添加方法时参数类型签名不正确，可能导致运行时崩溃。\n无法被编译器静态检查，出错时很难定位。\n\n\n\nNSProxy 是什么？为什么需要它？\n\n\nNSProxy 是一个轻量级的基类，专门用于实现消息转发。\n典型场景：\n远程方法调用（RPC）\n多代理管理（如 YYTextKeyboardManager）\n相比 NSObject，NSProxy 没有实例变量，直接走完整消息转发流程。\n\n\n","categories":["基础"]},{"title":"Day5-Objective-C Runtime 基础结构","url":"/2025/04/28/Day5-Objective-C-Runtime-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/","content":"Objective-C Runtime 基础结构Objective-C 运行时系统（Runtime）是 Objective-C 语言的核心部分，它在程序运行期间负责管理类、对象、方法调用等行为。\n主要的结构体和组件包括：\n1. objc_class（类结构体）struct objc_class &#123;    Class isa;                // 指向元类    Class super_class;        // 父类    const char *name;         // 类名    long version;             // 版本信息    long info;                // 类信息标志    long instance_size;       // 类实例的大小    struct objc_ivar_list *ivars;    // 成员变量列表    struct objc_method_list **methodLists; // 方法列表（数组）    struct objc_cache *cache; // 方法缓存    struct objc_protocol_list *protocols; // 协议列表&#125;;\n\n注意：现代 Runtime 中，结构体已经变化了，上述是经典（早期）的描述，新的版本更复杂且高度封装。\n\n\n2. objc_object（对象结构体）struct objc_object &#123;    Class isa;  // 指向对象所属的类&#125;;\n\n每一个对象底层其实就是一个指针，最重要的成员就是 isa。\nisa 既可以指向 Class，也可以指向 Meta-Class（元类）。\n\n\n3. objc_method（方法结构体）struct objc_method &#123;    SEL name;      // 方法选择器（Selector）    char *types;   // 方法的参数和返回值类型编码    IMP imp;       // 方法实现的函数指针&#125;;\n\nSEL 是方法名的唯一标识。\nIMP 是函数指针，本质上就是 C 函数的地址。\n\n\n4. objc_ivar（成员变量结构体）struct objc_ivar &#123;    char *name;        // 变量名    char *typeEncoding; // 类型编码    int offset;         // 变量在对象内存中的偏移量&#125;;\n\n成员变量的信息，包括名字、类型和内存位置。\n\n\n5. objc_property（属性结构体）在现代 Runtime 里面，属性也有自己的结构：\ntypedef struct &#123;    const char *name;            // 属性名    const char *attributes;      // 属性修饰列表（例如：T@&quot;NSString&quot;,C,N,V_name）&#125; objc_property_t;\n\n属性其实是成员变量 + 一些特定特性（getter&#x2F;setter规则）。\n\n\n小总结\n\n\n组件\n作用\n\n\n\nobjc_object\n所有对象的基础\n\n\nobjc_class\n类对象描述结构\n\n\nobjc_method\n方法的定义\n\n\nobjc_ivar\n成员变量定义\n\n\nobjc_property\n属性定义\n\n\n\n进阶补充在 现代 Objective-C Runtime（如 iOS 14+），这些结构体实际上被进一步封装优化，比如：\n\n类使用 objc_class 和 objc_data_bits_t（联合体）分离了缓存、只读数据等。\nmethodList 也使用更紧凑的链表存储。\nisa 指针通过 isa 指针优化（ISA指针打包） 包含了更多信息，比如引用计数、是否有C++析构函数等。\n\n\n现代 Objective-C Runtime 的优化\n\nobjc_class 和 objc_data_bits_t 的分离\n\n早期（传统）的结构：\n在早期的 Objective-C Runtime 中，类对象（objc_class）包含了所有关于类的描述信息，包括：\n\nisa 指针（指向元类）\nsuper_class（父类指针）\n成员变量、方法列表、属性等\n\n这种结构虽然简单，但随着 iOS 设备性能的提高，运行时系统也需要对这些数据结构进行优化。\n现代优化：\n在 iOS 14 及之后的版本中，Objective-C Runtime 通过 分离 类的各个组成部分，提高了性能和内存效率。\nobjc_class 现在主要包含 元类的引用，而其它数据（如方法列表、属性、成员变量等）被移到了 objc_data_bits_t 结构中。这种方式的好处是：\n\n缓存友好：类的元数据可以被存储在内存的紧凑区域，提高了缓存命中率。\n分离存储：类数据和方法数据分开存储，避免了冗余的内存占用。\n增强的灵活性：可以在不同的硬件架构下对这些数据进行不同的布局，以便更好地适配不同的内存和处理器特性。\n\n例子：\nobjc_class 结构变得非常简洁：\nstruct objc_class &#123;    Class isa;                // 指向元类    Class super_class;        // 父类    const char *name;         // 类名    ...    objc_data_bits_t data;    // 类的其它元数据，如方法、属性、缓存等&#125;;\n\n而 objc_data_bits_t 则包含了实际的数据部分：\nunion objc_data_bits_t &#123;    struct &#123;        method_list_t *methodList;   // 方法列表        ivar_list_t *ivarList;       // 成员变量列表        property_list_t *propertyList; // 属性列表        cache_t cache;               // 方法缓存    &#125;;    uintptr_t raw; // 原始内存表示&#125;;\n\n\n\n\nmethodList 存储的优化\n\n早期存储：\n传统的 methodList 是基于链表（Linked List）存储的。这种方式虽然简单，但查找方法时效率较低，尤其是在类层级很深或者方法很多的情况下。\n现代优化：\n在现代的 Runtime 系统中，methodList 不再是单纯的链表。它现在采用了一种 紧凑的链表结构，并且结合了 哈希表（Hash Table） 或者 二叉搜索树（Binary Search Tree），大大提高了方法查找的效率。\n\n哈希表：通过哈希值来存储方法，查找操作时间复杂度为 O(1)。\n二叉搜索树：如果方法列表较大，可能使用树结构来提高查找性能（特别是方法名排序后）。\n\n这种优化使得对于频繁调用的方法，能够以更高的效率进行查找。\n优化的好处：\n\n方法查找速度更快。\n降低了内存占用，尤其在方法很多的类中表现尤为突出。\n\n\nisa 指针优化（ISA指针打包）\n\n早期 isa 指针：\n早期的 isa 指针实际上是一个单纯的指针，它指向当前对象所属的类。当我们需要判断一个对象的类型时，必须通过这个指针进行查找。这个过程虽然有效，但随着内存和处理器架构的变化，其效率并没有得到最优的利用。\n现代优化：\niOS 14 及之后的版本引入了 ISA 指针打包（ISA pointer packing） 的概念，使得 isa 指针变得更加高效。具体来说：\n\n压缩指针：isa 不仅仅是一个指针，它包含了更多的信息，包括：\n引用计数：可以通过 isa 字段直接获取对象的引用计数（而不需要额外的字段）。\nC++ 析构函数支持：对于 C++ 对象，isa 可以包含一个标记，表明该对象是否有 C++ 析构函数需要调用。\n指针压缩：针对 64 位设备，指针已经被压缩，节省了内存空间。\n指针布局：通过优化指针的布局，可以减少内存访问的延迟。例如，将常用的标记和信息放在 isa 中，减少了缓存缺失的概率。\n\n结构变化：\nstruct objc_object &#123;    Class isa;   // 压缩后的 isa 指针，包含更多信息&#125;;\n\n这种优化使得：\t•\t内存使用：减少了内存占用。\t•\t效率提升：访问对象所属类时的效率大幅提高。\n\n总结\n在现代 Objective-C Runtime 中，结构体的优化和指针的打包大大提升了系统的性能，尤其是在内存占用和方法查找速度上。重点优化如下：\t•\tobjc_class 和 objc_data_bits_t 的分离：提高了内存布局的紧凑性和效率。\t•\tmethodList 的优化：结合哈希表和二叉搜索树，提高了方法查找的效率。\t•\tisa 指针优化：通过指针打包，减少了内存占用，并加速了对象的类型查找和引用计数管理。\n这些改进的核心目的是：提升性能、减少内存占用，特别是在 iOS 设备上，确保运行时系统能够在有限的硬件资源上高效运行。\n\n","categories":["基础"]},{"title":"Day7-Runtime&Block","url":"/2025/04/30/Day7-Runtime&Block/","content":"RuntimeiOS Runtime，通常称为Objective-C Runtime，是iOS开发中一个至关重要的组件。它是一套底层的C语言API，为Objective-C的动态特性提供了强大的支持。本文将对iOS Runtime进行深入的解析，从基本概念到主要功能，再到实际应用和注意事项，全方位地展示这一技术的魅力。\n一、Runtime基本概念Runtime，即运行时，指的是程序在运行过程中进行的一系列操作。在Objective-C中，Runtime系统允许我们在程序运行时动态地操作类和对象，执行诸如检查和改变对象、交换方法实现、动态添加方法或属性等操作。这种动态性为开发者带来了极大的灵活性。\nObjective-C作为一门动态语言，与C语言等静态语言在编译和运行时有着显著的区别。静态语言在编译阶段就确定了所有的方法调用和对象类型，而动态语言则在运行时才确定这些操作。Objective-C通过Runtime系统实现了这一动态性，使得我们可以在运行时动态地创建类和对象、进行消息传递和转发。\n二、Runtime数据结构在深入Runtime的功能之前，我们需要先了解其底层的数据结构。iOS Runtime的核心数据结构包括objc_class、objc_object等。\n\nobjc_object：这是所有Objective-C对象的基类结构体，其中包含一个isa指针，指向该对象所属的类。\n\nobjc_class：这是类的结构体，它继承自objc_object。objc_class中包含了类的各种信息，如父类指针、方法列表、方法缓存、属性列表、协议列表等。\n\nisa：指向该类的元类（meta-class），元类中存储了类的类方法。\nsuper_class：指向该类的父类。\nname：类的名称。\nversion：类的版本信息。\ninfo：类的详细信息。\ninstance_size：该类实例对象的大小。\nmethodLists：指向该类的实例方法列表的指针的指针，可以动态修改。\ncache：方法缓存，用于存储被频繁调用的方法，以提高查找效率。\nprotocols：指向该类的协议列表。\n\n\n\n三、Runtime主要功能iOS Runtime提供了许多强大的功能，这些功能使得Objective-C成为一门极具动态性的编程语言。\n\n动态添加类和方法：\nRuntime允许我们在运行时动态地创建新的类，并向已有的类中添加新的方法或实例变量。这种动态性使得我们可以在不修改原有代码的情况下，为类添加新的功能。例如，通过objc_allocateClassPair和objc_registerClassPair函数可以动态创建和注册一个新的类；通过class_addMethod函数可以向已有的类中添加新的方法。\n\n消息传递和消息转发：\nObjective-C中的方法调用实际上是一种消息传递机制。当我们向一个对象发送消息时，Runtime系统会根据消息的名称（即选择器SEL）在对象的类及其父类中查找对应的方法实现。如果找到了匹配的方法，就调用该方法；如果没有找到，则进入消息转发机制。消息转发机制允许我们在运行时动态地处理未实现的方法调用，而不是直接崩溃。例如，通过实现forwardingTargetForSelector:方法，我们可以将未实现的消息转发给其他对象来处理。\n\n关联对象：\nRuntime允许我们给现有的类动态地关联新的属性。这种关联属性不会改变原有类的结构，也不会影响其他类的使用。这在某些情况下可以避免子类化，从而简化代码结构。例如，通过objc_setAssociatedObject和objc_getAssociatedObject函数可以为对象关联和获取新的属性。\n\n获取类信息：\nRuntime提供了一系列函数来获取类的信息，包括类名、父类、实例变量、方法列表、协议列表等。这些信息对于调试和反射等高级操作非常有用。例如，通过class_getName函数可以获取类的名称；通过class_copyMethodList函数可以获取类的方法列表。\n\n方法交换：\nRuntime允许我们在运行时交换两个方法的实现。这种功能在某些情况下可以用来实现方法的替换或调试。例如，通过method_exchangeImplementations函数可以交换两个方法的实现。\n\n\n四、Runtime实际应用iOS Runtime在开发中有着广泛的应用，以下是一些常见的用例和示例：\n\n给系统类添加属性或方法：\n通过Runtime，我们可以为系统类（如NSString、UIButton等）添加新的属性或方法。这种操作通常用于扩展系统类的功能，而无需创建子类。例如，我们可以为NSString类添加一个计算字符串哈希值的方法。\n\n方法交换：\n方法交换是Runtime的一个强大功能，它允许我们在运行时交换两个方法的实现。这种操作通常用于调试或实现某些特定的功能。例如，我们可以通过交换UIViewController的viewDidLoad和viewWillAppear:方法的实现来观察这两个方法在不同时机下的行为。\n\nKVO（Key-Value Observing）和KVC（Key-Value Coding）：\nKVO和KVC是Objective-C中的两种高级特性，它们分别用于观察对象属性的变化和通过键值对来访问对象的属性。这两种特性都依赖于Runtime系统来实现。例如，KVO通过Runtime在对象的属性被修改时触发相应的通知；KVC则通过Runtime在运行时动态地访问和修改对象的属性。\n\n字典转模型：\n在iOS开发中，我们经常需要将JSON字典转换为模型对象。通过Runtime，我们可以实现一个通用的字典转模型的工具类，该工具类可以自动地将JSON字典中的键值对映射到模型对象的属性上。这种操作大大提高了代码的可重用性和可维护性。\n\n消息转发机制：\n当对象接收到一个未实现的消息时，可以通过消息转发机制来动态地处理这个消息。这种机制允许我们在不改变原有代码的情况下，为对象添加新的功能或处理错误情况。例如，当对象接收到一个未实现的方法调用时，我们可以通过实现forwardingTargetForSelector:或forwardInvocation:方法来处理这个消息。\n\n\n五、注意事项虽然iOS Runtime提供了许多强大的功能，但在使用时也需要注意以下几点：\n\n稳定性：\n动态地修改类的结构和行为可能会破坏代码的稳定性。因此，在使用Runtime功能时需要谨慎考虑其对系统稳定性的影响。\n\n可维护性：\n过度使用Runtime功能可能会降低代码的可读性和可维护性。因此，在开发过程中需要权衡利弊，合理地使用Runtime功能。\n\n性能：\n虽然Runtime系统提供了许多高效的数据结构和算法来优化性能，但在某些情况下（如频繁地动态添加或删除方法），仍然可能会对性能产生一定的影响。因此，在使用Runtime功能时需要关注其对性能的影响。\n\n\n六、总结iOS Runtime是Objective-C语言动态特性的基石，它提供了一系列强大的功能来支持动态性和灵活性。通过深入了解Runtime的基本概念、数据结构、主要功能和实际应用，我们可以更好地利用这一技术来开发高效、灵活和可维护的iOS应用程序。同时，也需要注意在使用Runtime功能时保持代码的稳定性和可读性。\nBlockBlock是苹果公司在OSX10.6和iOS4.0中引入的一项功能，它极大地丰富了C语言的特性，并提供了类似其他语言中闭包（closure）的功能。Block本质上是一个带有自动变量（局部变量）的匿名函数，其底层实现包含isa指针，因此也可以被看作是块对象。本文将深入解析iOS中的Block，包括其概念、声明与定义、捕获变量的机制、内存管理以及使用场景等方面。\n一、Block的基础概念Block又称为块或块对象，是苹果在改进C&#x2F;OC&#x2F;C++&#x2F;OC++等语言的编译处理时的重要成果。它的出现旨在替代指针函数，使得代码更加简洁和易用。Block的语法结构包括返回类型、变量名（可省略）、参数列表以及实现体，使用脱字符“^”和花括号“{}”来表示。\n二、Block的声明与定义Block的声明语法相对独特，格式为“返回值类型(^block变量名)(参数列表)”。例如，“int(^personBlock)(NSString ,int)”声明了一个名为personBlock的Block变量，它接收两个参数（一个NSString类型和一个int类型），并返回一个int类型的值。\nBlock的定义则是在声明的基础上，使用“&#x3D;”符号和“^”符号来引入实现体。例如：\nNSString* (^personBlock)(NSString*,int) = ^(NSString* name, int age)&#123;    NSLog(@&quot;年龄==%d&quot;, age);    return name;&#125;;\n\n这段代码定义了一个名为personBlock的Block，它接收一个NSString*类型的name和一个int类型的age作为参数，打印年龄并返回name。\n三、Block捕获变量的机制Block可以捕获其声明范围内的所有变量，但捕获的自动变量默认是不可修改的。如果需要修改，则需要在变量前加上__block修饰符。__block修饰符告诉编译器，该变量可能会在Block中被修改，因此需要在Block的实现体中保留一个指向该变量的指针。\n此外，Block总能修改实例变量、静态变量、全局变量和全局静态变量，无需加__block修饰符。\n四、Block的内存管理在iOS中，Block的内存管理是一个重要的考虑因素。Block有三种存储位置：栈（_NSConcreteStackBlock）、堆（_NSConcreteMallocBlock）和全局（_NSConcreteGlobalBlock）。\n\n栈上的Block：当Block在方法内部声明且没有引用外部变量时，它通常被分配在栈上。栈上的Block在方法返回时会被销毁。\n堆上的Block：当Block引用外部变量或作为属性存储时，它会被复制到堆上。堆上的Block在引用计数为0时才会被销毁。\n全局的Block：不访问任何外部变量的Block可以被视为全局Block，它们通常被分配在全局数据区。\n\n在ARC（自动引用计数）环境下，系统通常会自动将Block从栈复制到堆上，以避免栈上的Block被销毁。然而，在MRC（手动引用计数）环境下，开发者需要手动管理Block的内存。\n五、Block的使用场景Block在iOS开发中有广泛的应用场景，包括但不限于：\n\n作为参数传递：Block可以作为函数的参数传递，这使得函数能够接收一段代码作为参数，并在需要时执行这段代码。这种特性使得Block在回调函数、动画处理等方面非常有用。\n闭包：Block的闭包特性使得它能够捕获并保留其声明范围内的变量，即使这些变量在Block外部已经被销毁。这使得Block能够在异步操作、定时器回调等场景中保持对外部变量的访问。\n适配器模式：Block可以用作适配器模式中的“转换函数”，将一种接口转换为另一种接口。这在处理不同数据源或不同格式的数据时非常有用。\n解决循环引用：在使用Block时，需要注意循环引用的问题。特别是当Block作为对象的属性存储时，如果对象也持有Block的引用，就会形成循环引用。为了避免这种情况，可以使用__weak关键字来声明对对象的弱引用，从而在Block中避免循环引用。\n\n六、Block使用注意点及常见问题\nBlock作为类变量属性时用copy修饰：\n\n原因：Block作为类属性时，用copy修饰符可以将Block从栈拷贝到堆中，防止Block在方法返回后被销毁。\n注意：赋值给一个weak变量时，Block不会被copy到堆上。\n\n\n不能修改外部自动变量问题：\n\n解决方案：使用__block修饰符来修饰需要修改的外部自动变量。\n\n\n循环引用问题：\n\n解决方案：使用__weak关键字来声明对对象的弱引用，从而避免循环引用。在需要访问self属性时，可以在Block内部使用[weak self]和[strong self]的技巧来确保self在Block执行期间不会被释放。\n\n\n\n七、总结Block是iOS开发中一项非常强大的功能，它提供了简洁且易用的接口来封装代码块，并允许捕获和保留外部变量。然而，在使用Block时，也需要注意其内存管理和循环引用等问题。通过深入理解Block的底层实现和使用场景，开发者可以更加高效地利用这一功能来编写出更加优雅和健壮的代码。\n","categories":["基础"]},{"title":"Day6-删除有序数组中的重复项","url":"/2025/04/29/Day6-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","content":"🔗 LeetCode 26 - Remove Duplicates from Sorted Array\n📌 题目描述给你一个 升序排列 的数组 nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 O(1) 额外空间的条件下原地修改输入数组。\n示例：\n输入: nums = [1,1,2]输出: 2, nums = [1,2,_]\n\n\n💡 解题思路\n使用 双指针：\n\nslow 指针表示当前处理的唯一元素下标；\nfast 指针遍历数组，当遇到一个与 nums[slow] 不同的元素时，将其赋值给 nums[slow + 1]，然后 slow 前进一步。\n\n\n遍历结束后，slow + 1 就是新数组的长度。\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n\n✅ JavaScript 实现var removeDuplicates = function(nums) &#123;    if (nums.length === 0) return 0;        let slow = 0;        for (let fast = 1; fast &lt; nums.length; fast++) &#123;        if (nums[fast] !== nums[slow]) &#123;            slow++;            nums[slow] = nums[fast];        &#125;    &#125;        return slow + 1;&#125;;\n\n\n🧠 思考拓展\n如果要求每个元素最多出现两次怎么办？（参考 LeetCode 80）\n这道题为什么必须是原地修改？有什么实际应用场景？\n\n\n","categories":["算法"]},{"title":"Day7-合并两个有序链表","url":"/2025/04/30/Day7-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","content":"🔗 LeetCode 21 - Merge Two Sorted Lists\n📌 题目描述将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n示例：\n输入: l1 = [1,2,4], l2 = [1,3,4]输出: [1,1,2,3,4,4]\n\n\n💡 解题思路\n使用 递归 或 迭代 方法逐步将两个链表中较小的节点连接起来；\n\n递归写法简洁优雅，但迭代写法更容易控制空间复杂度。\n\n时间复杂度：O(n + m)，其中 n 和 m 分别是两个链表的长度；\n\n空间复杂度：\n\n递归：O(n + m)，因为递归栈；\n迭代：O(1)\n\n\n\n\n✅ JavaScript 实现（迭代）var mergeTwoLists = function(l1, l2) &#123;    let dummy = new ListNode(-1);    let current = dummy;    while (l1 !== null &amp;&amp; l2 !== null) &#123;        if (l1.val &lt;= l2.val) &#123;            current.next = l1;            l1 = l1.next;        &#125; else &#123;            current.next = l2;            l2 = l2.next;        &#125;        current = current.next;    &#125;    current.next = l1 !== null ? l1 : l2;    return dummy.next;&#125;;\n\n\n✅ JavaScript 实现（递归）var mergeTwoLists = function(l1, l2) &#123;    if (l1 === null) return l2;    if (l2 === null) return l1;    if (l1.val &lt;= l2.val) &#123;        l1.next = mergeTwoLists(l1.next, l2);        return l1;    &#125; else &#123;        l2.next = mergeTwoLists(l1, l2.next);        return l2;    &#125;&#125;;\n\n\n🧠 思考拓展\n如何在不创建新链表节点的情况下合并？\n如果链表不是升序而是无序，如何合并后排序？\n\n\n","categories":["算法"]},{"title":"Day8-验证回文串","url":"/2025/05/06/Day8-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"🔗 LeetCode 125 - Valid Palindrome\n📌 题目描述给定一个字符串，判断它是否是回文，只考虑字母和数字字符，可以忽略字母的大小写。\n示例：\n输入: &quot;A man, a plan, a canal: Panama&quot;输出: true输入: &quot;race a car&quot;输出: false\n\n\n💡 解题思路\n使用双指针法；\n\n从头尾两端遍历，只保留字母和数字，统一转成小写后比较；\n\n忽略其他符号。\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n\n✅ JavaScript 实现var isPalindrome = function(s) &#123;    let left = 0, right = s.length - 1;    while (left &lt; right) &#123;        while (left &lt; right &amp;&amp; !isAlphaNum(s[left])) left++;        while (left &lt; right &amp;&amp; !isAlphaNum(s[right])) right--;        if (s[left].toLowerCase() !== s[right].toLowerCase()) return false;        left++;        right--;    &#125;    return true;&#125;;function isAlphaNum(c) &#123;    return /^[a-zA-Z0-9]$/.test(c);&#125;\n\n\n🧠 思考拓展\n如何处理 Unicode 字符（如中文、Emoji）？\n如果需要考虑回文子串，如何优化？\n\n\n","categories":["算法"]},{"title":"Day8-RunLoop 构成与线程保活","url":"/2025/05/06/Day8-RunLoop-%E6%9E%84%E6%88%90%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB/","content":"一、RunLoop 的构成RunLoop 是基于 CFRunLoopRef（Core Foundation 层）构建的，NSRunLoop 是其 Foundation 层的封装。核心组成如下：\n1. RunLoop 对象\n每条线程都有唯一的一个 RunLoop 对象（主线程默认创建，子线程需手动创建）。\n\n2. RunLoopMode\nRunLoop 在任一时刻只能运行在一种模式下。\n常见模式：\nNSDefaultRunLoopMode\nUITrackingRunLoopMode\nNSRunLoopCommonModes\n\n\n\n3. Source（事件源）\nSource0：非基于 Port 的，如 performSelector:onThread:\nSource1：基于 Port 的，如 GCD 主线程通信\n\n4. Timer\nNSTimer 和 CADisplayLink 都依赖 RunLoop\n\n5. Observer（观察者）\n监听 RunLoop 状态变化，如将要进入、即将处理事件、即将休眠等\n\n6. Port\n线程通信载体，配合 Source1 使用\n\n\n二、RunLoop 与线程保活1. 子线程默认行为任务执行完即退出，因为没有 RunLoop。\n2. 线程保活方式- (void)startThread &#123;    NSThread *thread = [[NSThread alloc] initWithBlock:^&#123;        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];        [[NSRunLoop currentRunLoop] run];    &#125;];    [thread start];&#125;\n\n3. 注意事项\nrun 会阻塞线程。\nRunLoop 需要至少一个 Input Source 否则会立刻退出。\n\n\n三、RunLoop 的实际应用（含示例）1. 保持线程不退出后台日志收集&#x2F;解码任务中使用 RunLoop 保活线程。\n2. 事件响应机制如 Touch、Button 点击，通过 Source1 分发给主线程 RunLoop。\n3. 定时器NSTimer&#x2F;CADisplayLink 依赖 RunLoop 触发。\n4. GCD 主队列回调延迟主线程卡顿时延迟执行，原因是 GCD 回调依赖 Source1。\n5. UI 滚动与事件隔离滚动 UIScrollView 时切换 Mode，暂停定时器触发。\n6. AutoreleasePool 管理RunLoop 每次循环自动创建&#x2F;释放 pool，防止泄露。\n7. 线程间通信基于 Port 的消息传递，结合 Source1 实现。\n\n四、RunLoop 实现原理RunLoop 本质是一个基于事件循环的结构：\nwhile (!stop) &#123;    __CFRunLoopDoObservers(kCFRunLoopEntry);    __CFRunLoopDoTimers();    __CFRunLoopDoSources0();    mach_msg(); // 等待消息唤醒    __CFRunLoopDoSources1();    __CFRunLoopDoObservers(kCFRunLoopExit);&#125;\n\n核心机制：\n\n\n模块\n说明\n\n\n\nmach_port\n底层通信机制\n\n\nSource0\n自定义事件\n\n\nSource1\n系统事件（如 GCD）\n\n\nTimer\n定时任务\n\n\nObserver\n状态监听\n\n\nMode\n事件隔离与切换模式\n\n\nMode 与 Input Source 关系结构：RunLoop ├── ModeA │    ├── Source0 │    ├── Source1 │    ├── Timer │    └── Observer └── ModeB      ├── Source0      └── ...\n\n\n五、总结\n\n\n分类\n应用\n\n\n\nUI交互\n事件响应、触摸分发、主队列 GCD\n\n\n多线程\n线程保活、线程通信\n\n\n性能优化\n滚动时暂停动画\n\n\n内存管理\n自动释放池管理\n\n\n动画处理\nCADisplayLink 刷新帧率\n\n\n","categories":["基础"]},{"title":"Day9-有效的括号","url":"/2025/05/07/Day9-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","content":"🔗 LeetCode 20 - Valid Parentheses\n📌 题目描述给定一个只包括 (、)、&#123;、&#125;、[、] 的字符串，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n\n示例：\n输入: &quot;()[]&#123;&#125;&quot;输出: true输入: &quot;(]&quot;输出: false\n\n\n💡 解题思路\n使用栈（stack）数据结构；\n\n遍历字符串，遇到左括号入栈；\n\n遇到右括号时弹出栈顶元素进行匹配；\n\n如果最后栈为空，则是有效的括号序列。\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n\n\n✅ JavaScript 实现var isValid = function(s) &#123;    const stack = [];    const map = &#123;        &#x27;)&#x27;: &#x27;(&#x27;,        &#x27;]&#x27;: &#x27;[&#x27;,        &#x27;&#125;&#x27;: &#x27;&#123;&#x27;    &#125;;    for (let c of s) &#123;        if ([&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;].includes(c)) &#123;            stack.push(c);        &#125; else &#123;            if (stack.pop() !== map[c]) return false;        &#125;    &#125;    return stack.length === 0;&#125;;\n\n\n🧠 思考拓展\n如果加入字符串中的其他字符要如何处理？\n如果括号嵌套层数非常深，有优化空间吗？\n\n\n","categories":["算法"]},{"title":"Day9-RunLoop 卡顿优化与监控实现","url":"/2025/05/07/Day9-RunLoop-%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%AE%9E%E7%8E%B0/","content":"iOS RunLoop 卡顿优化指南一、理解 RunLoop 卡顿的本质1. RunLoop 基本机制RunLoop 本质上是一个事件循环机制，主要用于线程的任务调度。在主线程中，RunLoop 负责处理：\n\n触摸事件\n定时器事件（NSTimer、CADisplayLink）\nUI 渲染\nGCD 主队列任务\n系统事件（比如键盘弹出）\n\n2. 卡顿现象原因主线程卡顿的本质是 RunLoop 长时间没有返回到空闲状态，常见原因：\n\n同步耗时任务阻塞主线程（如文件 IO、网络请求、复杂计算）\nUI 渲染过慢（大量绘制、图片解码）\n高频次定时器任务\n死锁或线程抢占资源\n\n二、RunLoop 卡顿监控1. 使用 RunLoop Observer 检测卡顿CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(NULL, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;    // 记录进入和退出时间，判断耗时&#125;);CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n\n2. 常用工具\nFPS 监控工具\nTime Profiler（定位卡顿调用栈）\nInstruments 的 Core Animation（检测 UI 绘制）\n自行实现卡顿监控（可设定阈值，如超过 200ms）\n\n三、RunLoop 卡顿优化策略1. 减少主线程压力\n耗时操作异步处理：如网络、数据库、压缩、解码\n使用 GCD 或 NSOperation 将任务放在子线程\n\nDispatchQueue.global().async &#123;    // 耗时操作    DispatchQueue.main.async &#123;        // 回主线程更新 UI    &#125;&#125;\n\n2. 延迟或分批执行任务\n使用 RunLoop idle 时机处理任务\n利用 CADisplayLink 拆分任务（典型如 tableView cell 异步绘制）\n\nCADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(step)];[link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];\n\n3. 图像加载优化\n图片解码、压缩处理放到子线程\n使用异步图片加载框架（如 SDWebImage、Kingfisher）\n\n4. 优化 UI 绘制\n减少不必要的视图层级\n合理使用 rasterization, shouldRasterize，避免频繁重绘\n尽量使用 CALayer 做动画或绘制\n\n5. 优化定时器\n避免使用过多高频率的 NSTimer\n用 CADisplayLink 或 DispatchSourceTimer 精确控制\n注意释放定时器，防止循环引用或内存泄漏\n\n四、进阶建议使用 RunLoop 模型实现任务调度（如 YYKit 的 AsyncLayer）核心思想：\n\n主线程每帧空闲阶段处理少量任务（每帧分批）\n避免阻塞主线程\n\n利用信号量&#x2F; watchdog 检测严重卡顿可用 dispatch_semaphore 配合子线程检测主线程长时间不响应，进行卡顿上报。\n五、总结\n\n\n优化手段\n是否推荐\n场景说明\n\n\n\n耗时任务异步化\n✅\n网络、图片、计算等\n\n\nUI 绘制优化\n✅\n多图页面、复杂视图\n\n\nRunLoop 空闲任务调度\n✅\n批量任务，降低瞬时压力\n\n\n卡顿监控工具接入\n✅\n提前发现问题\n\n\n自定义 RunLoop 调度\n✅\n高阶优化，如任务优先级\n\n\n\niOS 主线程卡顿监控实现方案🔧 方案核心思路\n利用 CFRunLoopObserver 监听 RunLoop 各阶段；\n在子线程中开启定时器，检查主线程是否长时间停留在某个阶段；\n超过阈值（如 200ms）即判定为卡顿，并记录堆栈。\n\n✅ 示例代码（Objective-C）@interface MainThreadMonitor : NSObject@end@implementation MainThreadMonitor &#123;    CFRunLoopObserverRef observer;    dispatch_semaphore_t semaphore;    CFRunLoopActivity activity;    BOOL isMonitoring;&#125;- (instancetype)init &#123;    if (self = [super init]) &#123;        semaphore = dispatch_semaphore_create(0);    &#125;    return self;&#125;- (void)startMonitoring &#123;    if (isMonitoring) return;    isMonitoring = YES;    // 1. 设置 RunLoop 观察者    CFRunLoopObserverContext context = &#123;0, (__bridge void *)self, NULL, NULL, NULL&#125;;    observer = CFRunLoopObserverCreate(NULL, kCFRunLoopAllActivities, YES, 0, &amp;runLoopCallback, &amp;context);    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);        // 2. 在子线程中检测主线程卡顿    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;        while (self-&gt;isMonitoring) &#123;            long result = dispatch_semaphore_wait(self-&gt;semaphore, dispatch_time(DISPATCH_TIME_NOW, 200 * NSEC_PER_MSEC));            if (result != 0) &#123;                if (self-&gt;activity == kCFRunLoopBeforeSources || self-&gt;activity == kCFRunLoopAfterWaiting) &#123;                    NSLog(@&quot;⚠️ 发现卡顿&quot;);                    [self logMainThreadStack];                &#125;            &#125;        &#125;    &#125;);&#125;// RunLoop 回调static void runLoopCallback(CFRunLoopObserverRef observer, CFRunLoopActivity act, void *info) &#123;    MainThreadMonitor *monitor = (__bridge MainThreadMonitor *)info;    monitor-&gt;activity = act;    dispatch_semaphore_signal(monitor-&gt;semaphore);&#125;// 打印主线程堆栈- (void)logMainThreadStack &#123;    thread_act_t thread = mach_thread_self();    NSString *stack = [self getStackForThread:mach_thread_self()];    NSLog(@&quot;卡顿堆栈：%@&quot;, stack);&#125;// 获取堆栈（可用 PLCrashReporter 或自己解析）- (NSString *)getStackForThread:(thread_t)thread &#123;    void *callstack[128];    int frames = backtrace(callstack, 128);    char **strs = backtrace_symbols(callstack, frames);    NSMutableString *stack = [NSMutableString string];    for (int i = 0; i &lt; frames; i++) &#123;        [stack appendFormat:@&quot;%s&quot;, strs[i]];    &#125;    free(strs);    return stack;&#125;- (void)stopMonitoring &#123;    if (!isMonitoring) return;    isMonitoring = NO;    if (observer) &#123;        CFRunLoopRemoveObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);        CFRelease(observer);        observer = NULL;    &#125;&#125;@end\n\n📌 使用方式MainThreadMonitor *monitor = [[MainThreadMonitor alloc] init];[monitor startMonitoring];\n\n🚀 补充优化建议\n上传卡顿信息 到服务端分析（包括时间戳、堆栈、设备信息等）；\n使用 PLCrashReporter 捕获完整堆栈；\n避免误报（可设定 N 次连续卡顿后才触发上报）；\n添加 FPS 监控作为辅助参考。\n\niOS 完整堆栈捕获实现原理🔍 栈帧捕获的原理概述1. 栈帧结构（以 x86_64 为例）每次函数调用时，系统会在栈中保存：\n\n返回地址（return address）\n上一个函数的栈帧指针（frame pointer）\n函数参数和局部变量\n\n因此，通过 当前帧的 frame pointer（rbp），可以回溯前一个函数的帧，形成调用链。\n当前栈帧：| return address || previous RBP   |  &lt;---- 当前 RBP 指向这里| arguments      || local vars     |\n\n不断遍历 RBP，就可以得到一连串的调用路径。\n\n2. backtrace() 与 backtrace_symbols()苹果系统提供了 glibc 的接口，能获取当前线程的调用栈信息：\nvoid *callstack[128];int frames = backtrace(callstack, 128);  // 获得 return address 数组char **strs = backtrace_symbols(callstack, frames); // 转为符号化字符串\n\n\nbacktrace()：返回指针数组，每个指针是一个返回地址（PC 值）\nbacktrace_symbols()：将地址解析为函数名（带符号信息）\n\n\n✅ 适用于当前线程❌ 无法捕获其他线程的堆栈\n\n\n🧠 捕获其他线程堆栈的高级做法1. 使用 Mach 线程 API 获取上下文macOS 和 iOS 的线程由 Mach 线程驱动，可使用如下方式获取任意线程的状态：\nthread_act_t thread = mach_thread_self(); // 或主线程 mach_port_ARM_THREAD_STATE64 state;mach_msg_type_number_t count = _ARM_THREAD_STATE64_COUNT;thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&amp;state, &amp;count);\n\n\n可拿到寄存器信息（如 pc, lr, fp）\n从 fp（frame pointer）开始，手动解析内存获取调用链\n\n2. 使用第三方库封装（推荐）\nPLCrashReporter\nKSCrash\n\n它们在崩溃或卡顿时：\n\n挂起线程\n读取线程上下文寄存器（如 pc、sp、fp）\n手动回溯调用栈\n进行符号化输出\n\n\n⚠️ 注意事项\n手动读取线程寄存器有风险（需挂起线程，防止栈变化）\n对于优化或内联函数，可能无法获取完整信息\n系统函数符号化依赖 dSYM 或符号表\n\n\n✅ 各方案对比\n\n\n方法\n优势\n局限\n\n\n\nbacktrace\n简单易用，当前线程调用栈\n仅当前线程，信息不完整\n\n\nMach API + 寄存器解析\n可捕获任意线程堆栈\n实现复杂，需挂起线程\n\n\nPLCrashReporter\n稳定封装，支持崩溃&#x2F;卡顿&#x2F;符号化\n增加依赖包，大小略大\n\n\n\n📌 推荐实践\n异常或卡顿发生时暂停主线程 → 获取寄存器状态 → 回溯调用链\n使用第三方库如 PLCrashReporter 进行安全封装\n搭配符号表（.dSYM）进行符号化，以便远程分析\n\n","categories":["基础"]},{"title":"学习计划","url":"/2025/04/23/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","content":"每日节奏建议：\n📖 技术知识学习：1.5h\n🧱 项目回顾 &amp; 系统设计：1h\n🧠 算法训练：1h\n🎤 面试题演练：1h\n📓 总结记录：0.5h\n\n\n🗓️ 第 1 周：UIKit、Block、Runtime\n\n\n星期\n学习内容\n\n\n\n周一\nUIKit 事件传递机制 &amp; Responder Chain\n\n\n周二\nView 布局流程（layoutSubviews 等）\n\n\n周三\nBlock 分类、变量捕获与作用域\n\n\n周四\nBlock 内存管理 &amp; 循环引用分析\n\n\n周五\nObjective-C Runtime 基础结构\n\n\n周六\nRuntime 实战技巧（Swizzling、消息转发）\n\n\n周日\n复盘总结 + 输出笔记（Runtime&#x2F;Block&#x2F;UI）\n\n\n\n🗓️ 第 2 周：RunLoop、线程、内存管理\n\n\n星期\n学习内容\n\n\n\n周一\nRunLoop 构成与线程保活\n\n\n周二\nRunLoop 卡顿优化场景实战\n\n\n周三\nGCD 进阶：barrier&#x2F;group&#x2F;target queue\n\n\n周四\nGCD vs NSOperation 框架对比\n\n\n周五\nARC 本质、Weak 实现、循环引用处理\n\n\n周六\n内存泄漏排查、僵尸对象与 MRC 回顾\n\n\n周日\n总结脑图：RunLoop + 多线程 + 内存管理\n\n\n\n🗓️ 第 3 周：项目复盘 + 网络 &amp; 缓存\n\n\n星期\n学习内容\n\n\n\n周一\n主项目架构梳理 + 架构图初稿\n\n\n周二\nNSURLSession 断点续传 + 网络封装\n\n\n周三\n网络库底层：AFNetworking、Alamofire\n\n\n周四\n缓存策略 + URLProtocol 拦截\n\n\n周五\n数据持久化方案（CoreData&#x2F;SQLite）\n\n\n周六\n离线缓存架构图 + 实际场景总结\n\n\n周日\n输出：项目亮点 bullet list（10 条）\n\n\n\n🗓️ 第 4 周：架构模式 &amp; 动态化技术\n\n\n星期\n学习内容\n\n\n\n周一\nMVC&#x2F;MVVM&#x2F;VIPER&#x2F;Redux 模式总结\n\n\n周二\n模块化设计 + 路由机制实践\n\n\n周三\n跨组件通信方案（Router &#x2F; URLScheme）\n\n\n周四\n热更新方案（JSPatch &#x2F; Flutter &#x2F; RN）\n\n\n周五\n字节跳动高频架构类面试题整理\n\n\n周六\n项目架构演讲模拟\n\n\n周日\n架构图最终版 + 项目复盘文档整理\n\n\n\n🗓️ 第 5 周：系统设计 &amp; 算法进阶\n\n\n星期\n学习内容\n\n\n\n周一\n系统设计题：视频播放 App 设计\n\n\n周二\n视频缓存、异常处理模块\n\n\n周三\n图片加载优化（LRU&#x2F;异步解码）\n\n\n周四\n多线程数据一致性场景题\n\n\n周五\n启动优化 &amp; 白屏优化场景\n\n\n周六\n算法专题：滑动窗口 + 搜索类\n\n\n周日\n输出系统设计答题稿（附图+要点）\n\n\n\n🗓️ 第 6 周：真题精练 + 模拟面试\n\n\n星期\n学习内容\n\n\n\n周一\n字节跳动 iOS 面经模拟一轮\n\n\n周二\n算法 + 项目 + 系统设计自测\n\n\n周三\n面经高频题口头回答训练\n\n\n周四\n系统设计 + 框架类问题演练\n\n\n周五\n算法面试题：手写经典题\n\n\n周六\n模拟面试（可找朋友&#x2F;AI 演练）\n\n\n周日\n总结错题、面试表现复盘笔记\n\n\n\n🗓️ 第 7 周：简历打磨 + 高频回顾\n\n\n星期\n学习内容\n\n\n\n周一\n简历优化 + STAR 法项目精炼\n\n\n周二\n高频 iOS 面试题 Top20 梳理\n\n\n周三\n项目深挖回答演练\n\n\n周四\n算法每日三题（链表&#x2F;DP&#x2F;字符串）\n\n\n周五\n突破知识短板模块\n\n\n周六\n录制项目讲解 or 技术讲演视频\n\n\n周日\n总结答题话术文档 &amp; PPT 资料\n\n\n\n🗓️ 第 8 周：冲刺 &amp; 模拟演练\n\n\n星期\n学习内容\n\n\n\n周一\n快速过一遍面试 50 问\n\n\n周二\n模拟完整项目答辩演讲\n\n\n周三\n高频算法刷题（6 题冲刺）\n\n\n周四\n模拟完整面试（全流程）\n\n\n周五\n总结所有笔记 + 精选答题卡\n\n\n周六\n心态调整 &amp; 准备环境\n\n\n周日\n正式面试 day 🚀（或休息备战）\n\n\n\n"},{"title":"Hello World","url":"/2025/04/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"避免视图绘制掉帧","url":"/2025/05/07/%E9%81%BF%E5%85%8D%E8%A7%86%E5%9B%BE%E7%BB%98%E5%88%B6%E6%8E%89%E5%B8%A7/","content":"图像显示原理iOS 图像显示的原理涉及多个层次，从底层的硬件加速到上层的框架实现。UIKit 提供了高层次的 API，用于管理应用的用户界面元素，包括视图、控件和图像显示。UIImageView 是 UIKit 中用于显示图像的主要类。Core Graphics (也称为 Quartz) 是 iOS 的 2D 绘图引擎。它直接与硬件交互，负责图形的绘制和处理。UIKit 的许多绘图操作最终都通过 Core Graphics 实现。Core Animation 是 iOS 用来处理动画和图像渲染的框架。每个 UIView 都有一个关联的 CALayer，用于处理图像和内容的渲染。Core Animation 负责将这些图层的内容提交到屏幕上，并处理图层之间的动画。\niOS 使用 OpenGL ES 或 Metal 作为底层图形渲染管线。UIKit 和 Core Animation 会将图像、视图和动画转换为 GPU 可理解的命令，并通过 OpenGL ES 或 Metal 渲染到屏幕上。\n当你使用 UIImageView 来显示图像时，以下步骤会发生：\n\n加载图像：UIImage 类用于加载图像资源。你可以从文件系统、网络、或资源包中加载图像。\n设置图像：将 UIImage 对象分配给 UIImageView 的 image 属性。\n图层显示：UIImageView 是一个 UIView 子类，因此它有一个关联的 CALayer。UIImageView 会将图像设置为其图层的 contents。\n渲染图像：Core Animation 将负责将 CALayer 的内容提交到 GPU 进行渲染，最后显示在屏幕上。以下是一个简单的示例，展示如何在 iOS 中使用 UIImageView 来显示图像。\n\nimport UIKitclass ViewController: UIViewController &#123;    override func viewDidLoad() &#123;        super.viewDidLoad()                // 创建 UIImage 对象        if let image = UIImage(named: &quot;example.jpg&quot;) &#123;                        // 创建 UIImageView 对象            let imageView = UIImageView(image: image)                        // 设置 UIImageView 的大小和位置            imageView.frame = CGRect(x: 50, y: 100, width: 200, height: 200)                        // 设置内容模式            imageView.contentMode = .scaleAspectFill                        // 将 UIImageView 添加到视图中            self.view.addSubview(imageView)        &#125;    &#125;&#125;\niOS 会自动缓存 UIImage 对象，以提高性能并减少内存消耗。UIImageView 使用的图像可以通过系统的图像缓存机制优化。\n对于大图像，最好使用分块加载或缩略图显示以减少内存占用。可以使用 CGImageSource 来逐步加载图像。\n举个例子：\nimport SwiftUIstruct ThumbnailImageView: View &#123;    let thumbnailImage: UIImage    let fullSizeImageURL: URL        @State private var fullSizeImage: UIImage? = nil    var body: some View &#123;        ZStack &#123;            if let fullSizeImage = fullSizeImage &#123;                Image(uiImage: fullSizeImage)                    .resizable()                    .scaledToFit()            &#125; else &#123;                Image(uiImage: thumbnailImage)                    .resizable()                    .scaledToFit()                    .onAppear(perform: loadFullSizeImage)            &#125;        &#125;    &#125;    private func loadFullSizeImage() &#123;        DispatchQueue.global().async &#123;            if let data = try? Data(contentsOf: fullSizeImageURL),               let image = UIImage(data: data) &#123;                DispatchQueue.main.async &#123;                    self.fullSizeImage = image                &#125;            &#125;        &#125;    &#125;&#125;\n在加载大图时使用 CGImageSource 逐步解码图片，在低分辨率时减少内存占用。\nimport UIKitfunc loadImageWithLowMemoryUsage(url: URL) -&gt; UIImage? &#123;    guard let source = CGImageSourceCreateWithURL(url as CFURL, nil) else &#123;        return nil    &#125;        let options: [NSString: Any] = [        kCGImageSourceShouldCache: false, // 避免直接缓存到内存        kCGImageSourceShouldAllowFloat: true    ]        return CGImageSourceCreateImageAtIndex(source, 0, options as CFDictionary).flatMap &#123;        UIImage(cgImage: $0)    &#125;&#125;\n如果图像需要从网络加载，建议使用异步加载来避免阻塞主线程。可以结合使用 URLSession 或第三方库如 SDWebImage 来实现。\n如果你需要自定义图像显示或进行复杂的图形处理，可以直接使用 Core Graphics。以下是一个使用 Core Graphics 绘制图像的例子：\nimport UIKitclass CustomView: UIView &#123;    override func draw(_ rect: CGRect) &#123;        guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;        // 设置填充颜色        context.setFillColor(UIColor.red.cgColor)        context.fill(rect)                // 加载图片        if let image = UIImage(named: &quot;example.jpg&quot;)?.cgImage &#123;            context.draw(image, in: rect)        &#125;    &#125;&#125;class ViewController: UIViewController &#123;    override func viewDidLoad() &#123;        super.viewDidLoad()                let customView = CustomView(frame: self.view.bounds)        self.view.addSubview(customView)    &#125;&#125;\nCPU 和 GPU 分别做了什么CPU 做的事情：\n\n视图层次结构的计算（View Hierarchy Calculation）： CPU 负责计算视图的层次结构，包括视图的位置、尺寸、透明度和其他属性。每当视图的这些属性发生变化时，CPU 会重新计算这些信息。\n布局（Layout）： 当使用 Auto Layout 或手动布局时，CPU 会计算所有视图的位置和尺寸。比如调用 layoutSubviews() 方法时，CPU 会参与布局计算。\n文本绘制（Text Rendering）： 如果你在视图中绘制文本，比如使用 UILabel 或 CATextLayer，CPU 会负责对文本进行排版和绘制。\n图像解码（Image Decoding）： 从网络或磁盘加载的图像通常是经过压缩的格式（如 PNG、JPEG）。CPU 负责将这些图像解码为可供 GPU 使用的原始位图格式。\nCore Graphics 绘制（Core Graphics Drawing）： 使用 CGContext 进行的所有绘制操作（如绘制路径、填充颜色等）都是在 CPU 上执行的。\n\n代码示例\nclass CustomView: UIView &#123;    override func layoutSubviews() &#123;        super.layoutSubviews()        // CPU 负责布局计算        let subview = UIView(frame: CGRect(x: 10, y: 10, width: 100, height: 50))        addSubview(subview)    &#125;    override func draw(_ rect: CGRect) &#123;        super.draw(rect)        // CPU 负责文本绘制        let text = &quot;Hello, World!&quot;        let attributes: [NSAttributedString.Key: Any] = [            .font: UIFont.systemFont(ofSize: 16),            .foregroundColor: UIColor.black        ]        text.draw(in: rect, withAttributes: attributes)    &#125;&#125;\nGPU 做的事情：\n\n图层合成（Layer Composition）： GPU 负责将各个图层（如 UIView 或 CALayer）进行合成和渲染。每个视图或图层都会被转换为一个纹理，GPU 会将这些纹理组合到最终的帧缓冲区中。\n图像渲染（Image Rendering）： GPU 负责渲染已经由 CPU 解码的图像位图。它还负责处理各种图像特效，如模糊、阴影、透明度等。\n动画处理（Animations Handling）： iOS 中的大多数动画（如 UIView 动画和 Core Animation）都是在 GPU 上执行的。GPU 负责处理动画的中间帧渲染。\nOpenGL&#x2F;Metal 绘制： 当使用 OpenGL ES 或 Metal 直接进行图形绘制时，GPU 会负责执行这些绘制命令。\n\nUIView.animate(withDuration: 1.0) &#123;    self.view.alpha = 0.5    // 这段代码的动画渲染由 GPU 处理&#125;\n通常，CPU 负责准备数据，GPU 负责渲染这些数据。为了优化性能，我们应该尽量减少 CPU 的负担，减少复杂的布局计算、避免频繁的视图层次变更，以及尽量延迟图像解码等操作。\n优化建议：\n\n尽量简化视图层次结构： 过多的子视图会增加 CPU 的计算负担。\n减少过度的重绘： 尽量避免频繁调用 setNeedsDisplay 或 layoutSubviews。\n使用异步图像加载和解码： 避免在主线程上进行图像解码，以减轻 CPU 的负担。\n合理使用图像缓存： 尽量使用适合尺寸的图片，避免 GPU 处理过大图像带来的额外开销。\n\nUIView 的绘制原理UIView 是所有用户界面元素的基础。每个 UIView 对象都负责显示内容，并响应用户输入。UIView 的绘制过程涉及多个步骤，从层级视图系统到 Core Graphics 和 Core Animation。\nUIView 是基于层次结构的，每个 UIView 都可以有多个子视图 (subviews)。所有的视图都由一个根视图 (root view) 管理，通常是 UIViewController 的 view 属性。\n绘制流程：\n\n当需要更新界面时（如屏幕首次渲染、视图内容更新、视图大小变化等），系统会触发视图的绘制过程。\n系统调用视图的 setNeedsDisplay 或 setNeedsLayout 方法标记视图为“需要更新”状态。\n系统在下一个运行循环中调用 drawRect: 方法绘制视图。\n\nUIView 的绘制是通过 Core Graphics 来完成的。Core Graphics 是一个 2D 绘图引擎，可以进行图形绘制、图像处理等。Core Animation 负责将 UIView 的内容显示在屏幕上。它将所有的绘制操作作为动画图层 (CALayer&#96;) 的更新并进行合成，最后呈现给用户。\nUIView 绘制流程的关键步骤：\n\nsetNeedsDisplay 和 setNeedsLayout：\nsetNeedsDisplay：标记视图为需要重绘，会在下一次屏幕刷新时调用 drawRect: 方法。\nsetNeedsLayout：标记视图需要重新布局，会在下一次布局周期调用 layoutSubviews 方法。\n\n\ndrawRect:：\ndrawRect: 方法是 UIView 自定义绘制的入口。在这里，可以使用 Core Graphics 进行图形绘制。\n\n\n\n以下是一个自定义 UIView 的示例，它在屏幕上绘制一个简单的矩形：\nimport UIKitclass CustomView: UIView &#123;        // 仅在初始化时调用一次    override init(frame: CGRect) &#123;        super.init(frame: frame)        // 设置视图的一些属性，例如背景颜色        self.backgroundColor = UIColor.white    &#125;        required init?(coder: NSCoder) &#123;        super.init(coder: coder)    &#125;        // 重写 drawRect: 方法来执行自定义绘制。使用 Core Graphics API 来绘制一个蓝色的矩形。    override func draw(_ rect: CGRect) &#123;        super.draw(rect)                // 获取当前的绘图上下文，这是一个 Core Graphics 的 `CGContext` 对象，它代表着一个绘制环境。        guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;                // 设置填充颜色        context.setFillColor(UIColor.blue.cgColor)                // 创建一个矩形        let rectangle = CGRect(x: 50, y: 50, width: 200, height: 100)                // 在上下文中绘制矩形        context.addRect(rectangle)        context.drawPath(using: .fill)    &#125;&#125;// 使用自定义视图class ViewController: UIViewController &#123;        override func viewDidLoad() &#123;        super.viewDidLoad()                // 创建并添加自定义视图        let customView = CustomView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))        self.view.addSubview(customView)    &#125;&#125;\nUIView 的绘制原理核心是基于 Core Graphics 和 Core Animation，通过 drawRect: 方法进行自定义绘制。这个过程涉及到多个步骤，包括视图层次结构、绘制流程、上下文获取，以及最终的内容合成并呈现给用户。在实际开发中，自定义绘制的 UIView 往往用于实现特殊的图形效果或自定义 UI 控件。\n异步绘制异步绘制主要指的是在后台线程中处理绘制操作，以避免阻塞主线程。Core Graphics 和 UIKit 提供了支持异步绘制的功能。\n使用 Core Graphics 的异步绘制。使用 UIGraphicsBeginImageContextWithOptions 函数在后台线程中创建一个 CGContext。使用 GCD 或 NSOperationQueue 来在后台线程中进行绘制操作。完成绘制后，将结果返回主线程以更新 UI。下面是一个异步绘制的示例代码：\nimport UIKitclass AsyncDrawingView: UIView &#123;        private var asyncImage: UIImage?        override func draw(_ rect: CGRect) &#123;        super.draw(rect)                // 如果有异步绘制的图片，直接绘制它        asyncImage?.draw(in: rect)    &#125;        func drawAsync() &#123;        Task &#123;            // 创建图形上下文            let size = self.bounds.size            UIGraphicsBeginImageContextWithOptions(size, false, 0.0)            guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;                        // 进行绘制操作            context.setFillColor(UIColor.blue.cgColor)            context.fill(CGRect(x: 0, y: 0, width: size.width, height: size.height))                        // 获取绘制结果            let image = UIGraphicsGetImageFromCurrentImageContext()            UIGraphicsEndImageContext()                        // 更新 UI，回到主线程            await MainActor.run &#123;                self.asyncImage = image                self.setNeedsDisplay() // 触发 draw(_:) 方法重新绘制            &#125;        &#125;    &#125;&#125;\n使用 UIKit 的异步绘制\n对于复杂的异步绘制，特别是涉及 UIView 的情况下，可以考虑这两个方法。首先是自定义 CALayer 并实现其 draw(in:) 方法来进行异步绘制。其次是使用 UIView 的 draw(:) 方法，在子类中重写 draw(:) 方法，并结合异步操作来更新绘制内容。\nimport UIKitclass AsyncDrawingLayer: CALayer &#123;        override func draw(in ctx: CGContext) &#123;        super.draw(in: ctx)                Task &#123;            // 在子线程中执行绘制操作            await withCheckedContinuation &#123; continuation in                Task.detached &#123;                    // 执行绘制操作                    ctx.setFillColor(UIColor.red.cgColor)                    ctx.fill(self.bounds)                                        // 完成绘制操作后继续                    continuation.resume()                &#125;            &#125;                        // 回到主线程更新 UI            await MainActor.run &#123;                self.setNeedsDisplay() // 触发 draw(in:) 重新绘制            &#125;        &#125;    &#125;&#125;\n离屏渲染离屏渲染（Offscreen Rendering）在 iOS 中是指在显示器显示内容之前，先在内存中完成渲染。这种方式的主要代价体现在以下几个方面：\n\n内存消耗：离屏渲染会占用额外的内存，因为每次渲染都会创建一个新的图像缓冲区（即离屏缓存）。这些缓存可能会迅速消耗大量内存，特别是对于复杂的视图或高分辨率的图像。\n处理时间：进行离屏渲染时，CPU 和 GPU 需要额外的时间来处理渲染操作。这可能会导致渲染时间增加，影响到应用的流畅性。\n上下文切换：离屏渲染需要将渲染操作从主线程转移到后台线程或额外的图形上下文，这增加了上下文切换的开销。\n绘制次数：每次需要重新绘制时（例如视图的内容更新），都需要执行离屏渲染，这可能导致频繁的渲染操作，从而影响性能。\n\n产生离屏渲染的常见原因有：\n\n圆角（Corner Radius）：如果在视图或图层上应用圆角效果，iOS 需要在离屏缓存中完成这些操作，尤其是当圆角半径较大时。\n阴影（Shadow）：阴影效果通常需要离屏渲染，因为阴影需要在原始视图之外的区域进行处理。\n透明度（Opacity）：对于半透明的视图或图层，iOS 需要进行离屏渲染以正确处理混合效果。\n复杂的图形操作：比如路径（UIBezierPath）的复杂绘制，也可能导致离屏渲染。\n\n避免离屏渲染的优化。如果视图的内容不会频繁变化，可以将视图渲染到 layer.contents 中，从而避免每次绘制时的离屏渲染开销。尽量避免复杂的圆角、阴影效果，或者使用更简单的图形操作。如可能，减少对 layer 的属性设置，尤其是那些可能引起离屏渲染的属性。\n","categories":["性能优化"],"tags":["性能优化","卡顿监控"]},{"title":"Swift 语法","url":"/2025/05/07/Swift-%E8%AF%AD%E6%B3%95/","content":"语法基础变量变量是可变的，使用 var 修饰，常量是不可变的，使用 let 修饰。类、结构体和枚举里的变量是属性。\nvar v1:String = &quot;hi&quot; // 标注类型var v2 = &quot;类型推导&quot;let l1 = &quot;标题&quot; // 常量class a &#123;    let p1 = 3    var p2: Int &#123;        p1 * 3    &#125;&#125;\n属性没有 set 可以省略 get，如果有 set 需加 get。变量设置前通过 willSet 访问到，变量设置后通过 didSet 访问。\n打印控制台打印值\nprint(&quot;hi&quot;)let i = 14print(i)print(&quot;9月\\(i)是小柠檬的生日&quot;)for i in 1...3&#123;    print(i)&#125;// output:// 1// 2// 3// 使用terminator使循环打印更整洁for i in 1...3 &#123;    print(&quot;\\(i) &quot;, terminator: &quot;&quot;)&#125;// output:// 1 2 3\n注释// 单行注释/*多行注释第一行。多行注释第二行。*/ // MARK: 会在 minimap 上展示// TODO: 待做// FIXME: 待修复\n!?可选可能会是 nil 的变量就是可选变量。当变量为 nil 通过??操作符可以提供一个默认值。\nvar o: Int? = nillet i = o ?? 0\nSE-0345 if let shorthand for shadowing an existing optional variable 引入的新语法，用于 unwrapping optinal。\nlet s1: String? = &quot;hey&quot;let s2: String? = &quot;u&quot;if let s1 &#123;    print(s1)&#125;guard let s1, let s2 else &#123; return &#125;print(s1 + &quot; &quot; + s2)\n闭包闭包也可以叫做 lambda，是匿名函数，对应 OC 的 block。\nlet a1 = [1,3,2].sorted(by: &#123; (l: Int, r: Int) -&gt; Bool in    return l &lt; r&#125;)// 如果闭包是唯一的参数并在表达式最后可以使用结尾闭包语法，写法简化为let a2 = [1,3,2].sorted &#123; (l: Int, r: Int) -&gt; Bool in    return l &lt; r&#125;// 已知类型可以省略let a3 = [1,3,2].sorted &#123; l, r in    return l &lt; r&#125;// 通过位置来使用闭包的参数，最后简化如下：let a4 = [1,3,2].sorted &#123; $0 &lt; $1 &#125;\n函数也是闭包的一种，函数的参数也可以是闭包。@escaping 表示逃逸闭包，逃逸闭包是可以在函数返回之后继续调用的。@autoclosure 表示自动闭包，可以用来省略花括号。\nSE-0326 提高了 Swift 对闭包使用参数和类型推断的能力。如下代码：\nlet a = [1,2,3]let r = a.map &#123; i in    if i &gt;= 2 &#123;        return &quot;\\(i) 大于等于2&quot;    &#125; else &#123;        return &quot;\\(i) 小于2&quot;    &#125;&#125;print(r)\n函数函数可以作为另一个函数的参数，也可以作为另一个函数的返回。函数是特殊的闭包，在类、结构体和枚举中是方法。\n// 为参数设置默认值func f1(p: String = &quot;p&quot;) -&gt; String &#123;    &quot;p is \\(p)&quot;&#125;// 函数作为参数func f2(fn: (String) -&gt; String, p: String) -&gt; String &#123;    return fn(p)&#125;print(f2(fn:f1, p: &quot;d&quot;)) // p is d// 函数作为返回值func f3(p: String) -&gt; (String) -&gt; String &#123;    return f1&#125;print(f3(p: &quot;yes&quot;)(&quot;no&quot;)) // p is no\n函数可以返回多个值，函数是可以嵌套的，也就是函数里内可以定义函数，函数内定义的函数可以访问自己作用域外函数内的变量。inout 表示的是输入输出参数，函数可以在函数内改变输入输出参数。defer 标识的代码块会在函数返回之前执行。\n函数在 Swift 5.4 时开始有了使用多个变量参数的能力，使用方法如下：\nfunc f4(s: String..., i: Int...) &#123;    print(s)    print(i)&#125;f4(s: &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, i: 1, 2, 3)/// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]/// [1, 2, 3]\n嵌套函数可以重载，嵌套函数可以在声明函数之前调用他。\nfunc f5() &#123;    nf5()    func nf5() &#123;        print(&quot;this is nested function&quot;)    &#125;&#125;f5() // this is nested function\n访问控制在 Xcode 里的 target 就是模块，使用 import 可导入模块。模块内包含源文件，每个源文件里可以有多个类、结构体、枚举和函数等多种类型。访问级别可以通过一些关键字描述，分为如下几种：\n\nopen：在模块外可以调用和继承。\npublic：在模块外可调用不可继承，open 只适用类和类成员。\ninternal：默认级别，模块内可跨源文件调用，模块外不可调用。\nfileprivate：只能在源文件内访问。\nprivate：只能在所在的作用域内访问。\n\n重写继承类的成员，可以设置成员比父类的这个成员更高的访问级别。Setter 的级别可以低于对应的 Getter 的级别，比如设置 Setter 访问级别为 private，可以在属性使用 private(set) 来修饰。\nRegex标准库多了个 Regex 类型，Regex 语法与 Perl、Python、Ruby、Java、NSRegularExpression 和许多其他语言兼容。可以用 let regex &#x3D; try! Regex(“a[bc]+”) 或 let regex &#x3D; &#x2F;a[bc]+&#x2F; 写法来使用。SE-0350 Regex Type and Overview 引入 Regex 类型。SE-0351 Regex builder DSL 使用 result builder 来构建正则表达式的 DSL。SE-0354 Regex Literals 简化的正则表达式。SE-0357 Regex-powered string processing algorithms 提案里有基于正则表达式的新字符串处理算法。\nRegexBuilder 文档\nsession Meet Swift Regex 、Swift Regex: Beyond the basics\nRegex 示例代码如下：\nlet s1 = &quot;I am not a good painter&quot;print(s1.ranges(of: /good/))do &#123;    let regGood = try Regex(&quot;[a-z]ood&quot;)    print(s1.replacing(regGood, with: &quot;bad&quot;))&#125; catch &#123;    print(error)&#125;print(s1.trimmingPrefix(/i am /.ignoresCase()))let reg1 = /(.+?) read (\\d+) books./let reg2 = /(?&lt;name&gt;.+?) read (?&lt;books&gt;\\d+) books./let s2 = &quot;Jack read 3 books.&quot;do &#123;    if let r1 = try reg1.wholeMatch(in: s2) &#123;        print(r1.1)        print(r1.2)    &#125;    if let r2 = try reg2.wholeMatch(in: s2) &#123;        print(&quot;name:&quot; + r2.name)        print(&quot;books:&quot; + r2.books)    &#125;&#125; catch &#123;    print(error)&#125;\n使用 regex builders 的官方示例：\n// Text to parse:// CREDIT  03/02/2022  Payroll from employer     $200.23// CREDIT  03/03/2022  Suspect A           $2,000,000.00// DEBIT   03/03/2022  Ted&#x27;s Pet Rock Sanctuary    $2,000,000.00// DEBIT   03/05/2022  Doug&#x27;s Dugout Dogs      $33.27import RegexBuilderlet fieldSeparator = /\\s&#123;2,&#125;|\\t/let transactionMatcher = Regex &#123;  /CREDIT|DEBIT/  fieldSeparator  One(.date(.numeric, locale: Locale(identifier: &quot;en_US&quot;), timeZone: .gmt)) // 👈🏻 we define which data locale/timezone we want to use  fieldSeparator  OneOrMore &#123;    NegativeLookahead &#123; fieldSeparator &#125; // 👈🏻 we stop as soon as we see one field separator    CharacterClass.any  &#125;  fieldSeparator  One(.localizedCurrency(code: &quot;USD&quot;).locale(Locale(identifier: &quot;en_US&quot;)))&#125;\n在正则表达式中捕获数据，使用 Capture：\nlet fieldSeparator = /\\s&#123;2,&#125;|\\t/let transactionMatcher = Regex &#123;  Capture &#123; /CREDIT|DEBIT/ &#125; // 👈🏻  fieldSeparator  Capture &#123; One(.date(.numeric, locale: Locale(identifier: &quot;en_US&quot;), timeZone: .gmt)) &#125; // 👈🏻  fieldSeparator  Capture &#123; // 👈🏻    OneOrMore &#123;      NegativeLookahead &#123; fieldSeparator &#125;      CharacterClass.any    &#125;  &#125;  fieldSeparator  Capture &#123; One(.localizedCurrency(code: &quot;USD&quot;).locale(Locale(identifier: &quot;en_US&quot;))) &#125; // 👈🏻&#125;// transactionMatcher: Regex&lt;(Substring, Substring, Date, Substring, Decimal)&gt;\n基础类型数字数字的类型有 Int、Float 和 Double\n// Intlet i1 = 100let i2 = 22print(i1 / i2) // 向下取整得 4// Floatlet f1: Float = 100.0let f2: Float = 22.0print(f1 / f2) // 4.5454545let f3: Float16 = 5.0 // macOS 还不能用let f4: Float32 = 5.0let f5: Float64 = 5.0let f6: Float80 = 5.0print(f4, f5, f6) // 5.0 5.0 5.0// Doublelet d1: Double = 100.0let d2: Double = 22.0print(d1 / d2) // 4.545454545454546// 字面量print(Int(0b10101)) // 0b 开头是二进制 print(Int(0x00afff)) // 0x 开头是十六进制print(2.5e4) // 2.5x10^4 十进制用 eprint(0xAp2) // 10*2^2  十六进制用 pprint(2_000_000) // 2000000// isMultiple(of:) 方法检查一个数字是否是另一个数字的倍数let i3 = 36print(i3.isMultiple(of: 9)) // true\n处理数字有 floor、ceil、round。floor 是向下取整，只取整数部分；cell 是向上取整，只要有不为零的小数，整数就加1;round 是四舍五入。\n布尔数布尔数有 true 和 false 两种值，还有一个能够切换这两个值的 toggle 方法。\nvar b = falseb.toggle() // trueb.toggle() // false\n字符串let s1 = &quot;Hi! This is a string. Cool?&quot;/// 转义符 \\n 表示换行。/// 其它转义字符有 \\0 空字符)、\\t 水平制表符 、\\n 换行符、\\r 回车符let s2 = &quot;Hi!\\nThis is a string. Cool?&quot;// 多行let s3 = &quot;&quot;&quot;Hi!This is a string.Cool?&quot;&quot;&quot;// 长度print(s3.count)print(s3.isEmpty)// 拼接print(s3 + &quot;\\nSure!&quot;)// 字符串中插入变量let i = 1print(&quot;Today is good day, double \\(i)\\(i)!&quot;)/// 遍历字符串/// 输出：/// o/// n/// efor c in &quot;one&quot; &#123;    print(c)&#125;// 查找print(s3.lowercased().contains(&quot;cool&quot;)) // true// 替换let s4 = &quot;one is two&quot;let newS4 = s4.replacingOccurrences(of: &quot;two&quot;, with: &quot;one&quot;)print(newS4)// 删除空格和换行let s5 = &quot; Simple line. \\n\\n  &quot;print(s5.trimmingCharacters(in: .whitespacesAndNewlines))// 切割成数组let s6 = &quot;one/two/three&quot;let a1 = s6.components(separatedBy: &quot;/&quot;) // 继承自 NSString 的接口print(a1) // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]let a2 = s6.split(separator: &quot;/&quot;)print(a2) // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] 属于切片，性能较 components 更好// 判断是否是某种类型let c1: Character = &quot;🤔&quot;print(c1.isASCII) // falseprint(c1.isSymbol) // trueprint(c1.isLetter) // falseprint(c1.isNumber) // falseprint(c1.isUppercase) // false// 字符串和 Data 互转let data = Data(&quot;hi&quot;.utf8)let s7 = String(decoding: data, as: UTF8.self)print(s7) // hi// 字符串可以当作集合来用。let revered = s7.reversed()print(String(revered))\nUnicode、Character 和 SubString 等内容参见官方字符串文档：Strings and Characters — The Swift Programming Language (Swift 5.1)\n字符串字面符号可以参看《String literals in Swift》。\n原始字符串\n// 原始字符串在字符串前加上一个或多个#符号。里面的双引号和转义符号将不再起作用了，如果想让转义符起作用，需要在转义符后面加上#符号。let s8 = #&quot;\\(s7)\\#(s7) &quot;one&quot; and &quot;two&quot;\\n. \\#nThe second line.&quot;#print(s8)/// \\(s7)hi &quot;one&quot; and &quot;two&quot;\\n./// The second line.// 原始字符串在正则使用效果更佳，反斜杠更少了。let s9 = &quot;\\\\\\\\[A-Z]+[A-Za-z]+\\\\.[a-z]+&quot;let s10 = #&quot;\\\\[A-Z]+[A-Za-z]+\\.[a-z]+&quot;#print(s9) // \\\\[A-Z]+[A-Za-z]+\\.[a-z]+print(s10) // \\\\[A-Z]+[A-Za-z]+\\.[a-z]+\nSwift5.7 String Index 大升级 String Index Overhaul\n枚举Swift的枚举有类的一些特性，比如计算属性、实例方法、扩展、遵循协议等等。\nenum E1:String, CaseIterable &#123;    case e1, e2 = &quot;12&quot;&#125;// 关联值enum E2 &#123;    case e1([String])    case e2(Int)&#125;let e1 = E2.e1([&quot;one&quot;,&quot;two&quot;])let e2 = E2.e2(3)switch e1 &#123;case .e1(let array):    print(array)case .e2(let int):    print(int)&#125;print(e2)// 原始值print(E1.e1.rawValue)// 遵循 CaseIterable 协议可迭代for ie in E1.allCases &#123;    print(&quot;show \\(ie)&quot;)&#125;// 递归枚举enum RE &#123;    case v(String)    indirect case node(l:RE, r:RE)&#125;let lNode = RE.v(&quot;left&quot;)let rNode = RE.v(&quot;right&quot;)let pNode = RE.node(l: lNode, r: rNode)switch pNode &#123;case .v(let string):    print(string)case .node(let l, let r):    print(l,r)    switch l &#123;    case .v(let string):        print(string)    case .node(let l, let r):        print(l, r)    &#125;    switch r &#123;    case .v(let string):        print(string)    case .node(let l, let r):        print(l, r)    &#125;&#125;\n@unknown 用来区分固定的枚举和可能改变的枚举的能力。@unknown 用于防止未来新增枚举属性会进行提醒提示完善每个 case 的处理。\n// @unknownenum E3 &#123;    case e1, e2, e3&#125;func fe1(e: E3) &#123;    switch e &#123;    case .e1:        print(&quot;e1 ok&quot;)    case .e2:        print(&quot;e2 ok&quot;)    case .e3:        print(&quot;e3 ok&quot;)    @unknown default:        print(&quot;not ok&quot;)    &#125;&#125;\n符合 Comparable 协议的枚举可以进行比较。\n// Comparable 枚举比较enum E4: Comparable &#123;    case e1, e2    case e3(i: Int)    case e4&#125;let e3 = E4.e4let e4 = E4.e3(i: 3)let e5 = E4.e3(i: 2)let e6 = E4.e1print(e3 &gt; e4) // truelet a1 = [e3, e4, e5, e6]let a2 = a1.sorted()for i in a2 &#123;    print(i.self)&#125;/// e1/// e3(i: 2)/// e3(i: 3)/// e4\n元组元组里的值类型可以是不同的。元组可以看成是匿名的结构体。\nlet t1 = (p1: 1, p2: &quot;two&quot;, p3: [1,2,3])print(t1.p1)print(t1.p3)// 类型推导let t2 = (1, &quot;two&quot;, [1,2,3])// 通过下标访问print(t2.1) // two// 分解元组let (dp1, dp2, _) = t2print(dp1)print(dp2)\n泛型和协议泛型可以减少重复代码，是一种抽象的表达方式。where 关键字可以对泛型做约束。\nfunc fn&lt;T&gt;(p: T) -&gt; [T] &#123;    var r = [T]()    r.append(p)    return r&#125;print(fn(p: &quot;one&quot;))// 结构体struct S1&lt;T&gt; &#123;    var arr = [T]()    mutating func add(_ p: T) &#123;        arr.append(p)    &#125;&#125;var s1 = S1(arr: [&quot;zero&quot;])s1.add(&quot;one&quot;)s1.add(&quot;two&quot;)print(s1.arr) // [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]\n关联类型\nprotocol pc &#123;    associatedtype T    mutating func add(_ p: T)&#125;struct S2: pc &#123;    typealias T = String // 类型推导，可省略    var strs = [String]()    mutating func add(_ p: String) &#123;        strs.append(p)    &#125;&#125;\n泛型适用于嵌套类型\nstruct S3&lt;T&gt; &#123;    struct S4 &#123;        var p: T    &#125;        var p1: T    var p2: S4&#125;let s2 = S3(p1: 1, p2: S3.S4(p: 3))let s3 = S3(p1: &quot;one&quot;, p2: S3.S4(p: &quot;three&quot;))print(s2,s3)\nsession Embrace Swift generics 、Design protocol interfaces in Swift\nswift 5.6 和之前编写泛型接口如下：\nfunc feed&lt;A&gt;(_ animal: A) where A: Animal// 👆🏻👇🏻 Equivalentsfunc feed&lt;A: Animal&gt;(_ animal: A)\nswift 5.7 可以这样写：\nfunc feed(_ animal: some Animal)\nsome 关键字可以用于参数和结构类型。some 会保证类型关系，而 any 会持有任意具体类型，删除类型关系。\nSE-0347 Type inference from default expressions 扩展 Swift 泛型参数类型的默认值能力。如下代码示例：\nfunc suffledArray&lt;T: Sequence&gt;(from options: T = 1...100) -&gt; [T.Element] &#123;    Array(options.shuffled())&#125;print(suffledArray())print(suffledArray(from: [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]))\nSE-0341 Opaque Parameter Declarations 使用 some 参数简化泛型参数声明。SE-0328 Structural opaque result types 扩大不透明结果返回类型可以使用的范围。SE-0360 Opaque result types with limited availability 可用性有限的不透明结果类型，比如 if #available(macOS 13.0, *) {} 就可以根据系统不同版本返回不同类型，新版本出现新类型的 View 就可以和以前的 View 类型区别开。\nSE-0309 Unlock existentials for all protocols 改进了 existentials 和 泛型的交互。这样就可以更方便的检查 Any 类型的两个值是否相等\nany 关键字充当的是类型擦除的助手，是通过告知编译器你使用 existential 作为类型，此语法可兼容以前系统。\nSE-0346 Lightweight same-type requirements for primary associated types 引入一种新语法，用于符合泛型参数并通过相同类型要求约束关联类型。SE-0358 Primary Associated Types in the Standard Library 引入主要关联类型概念，并将其带入了标准库。这些关联类型很像泛型，允许开发者将给定关联类型的类型指定为通用约束。\nSE-0353 Constrained Existential Types 基于 SE-0309 和 SE-0346 提案，在 existential 类型的上下文中重用轻量关联类型的约束。\nSE-0352 Implicitly Opened Existentials 允许 Swift 在很多情况下使用协议调用泛型函数。\nSwift 论坛上一个对 any 和 some 关键字语法使用场景的讨论，Do any and some help with “Protocol Oriented Testing” at all? 。\n不透明类型不透明类型会隐藏类型，让使用者更关注功能。不透明类型和协议很类似，不同的是不透明比协议限定的要多，协议能够对应更多类型。\nprotocol P &#123;    func f() -&gt; String&#125;struct S1: P &#123;    func f() -&gt; String &#123;        return &quot;one\\n&quot;    &#125;&#125;struct S2&lt;T: P&gt;: P &#123;    var p: T    func f() -&gt; String &#123;        return p.f() + &quot;two\\n&quot;    &#125;&#125;struct S3&lt;T1: P, T2: P&gt;: P &#123;    var p1: T1    var p2: T2    func f() -&gt; String &#123;        return p1.f() + p2.f() + &quot;three\\n&quot;    &#125;&#125;func someP() -&gt; some P &#123;    return S3(p1: S1(), p2: S2(p: S1()))&#125;let r = someP()print(r.f())\n函数调用者决定返回什么类型是泛型，函数自身决定返回什么类型使用不透明返回类型。\nResultResult 类型用来处理错误，特别适用异步接口的错误处理。\nextension URLSession &#123;    func dataTaskWithResult(        with url: URL,        handler: @escaping (Result&lt;Data, Error&gt;) -&gt; Void    ) -&gt; URLSessionDataTask &#123;        dataTask(with: url) &#123; data, _, err in            if let err = err &#123;                handler(.failure(err))            &#125; else &#123;                handler(.success(data ?? Data()))            &#125;        &#125;    &#125;&#125;let url = URL(string: &quot;https://ming1016.github.io/&quot;)!// 以前网络请求let t1 = URLSession.shared.dataTask(with: url) &#123;    data, _, error in    if let err = error &#123;        print(err)    &#125; else if let data = data &#123;        print(String(decoding: data, as: UTF8.self))    &#125;&#125;t1.resume()// 使用 Result 网络请求let t2 = URLSession.shared.dataTaskWithResult(with: url) &#123; result in    switch result &#123;    case .success(let data):        print(String(decoding: data, as: UTF8.self))    case .failure(let err):        print(err)    &#125;&#125;t2.resume()\n类型转换使用 is 关键字进行类型判断， 使用as 关键字来转换成子类。\nclass S0 &#123;&#125;class S1: S0 &#123;&#125;class S2: S0 &#123;&#125;var a = [S0]()a.append(S1())a.append(S2())for e in a &#123;    // 类型判断    if e is S1 &#123;        print(&quot;Type is S1&quot;)    &#125; else if e is S2 &#123;        print(&quot;Type is S2&quot;)    &#125;    // 使用 as 关键字转换成子类    if let s1 = e as? S1 &#123;        print(&quot;As S1 \\(s1)&quot;)    &#125; else if let s2 = e as? S2 &#123;        print(&quot;As S2 \\(s2)&quot;)    &#125;&#125;\n类和结构体类类可以定义属性、方法、构造器、下标操作。类使用扩展来扩展功能，遵循协议。类还以继承，运行时检查实例类型。\nclass C &#123;    var p: String    init(_ p: String) &#123;        self.p = p    &#125;        // 下标操作    subscript(s: String) -&gt; String &#123;        get &#123;            return p + s        &#125;        set &#123;            p = s + newValue        &#125;    &#125;&#125;let c = C(&quot;hi&quot;)print(c.p)print(c[&quot; ming&quot;])c[&quot;k&quot;] = &quot;v&quot;print(c.p)\n结构体 结构体是值类型，可以定义属性、方法、构造器、下标操作。结构体使用扩展来扩展功能，遵循协议。\nstruct S &#123;    var p1: String = &quot;&quot;    var p2: Int&#125;extension S &#123;    func f() -&gt; String &#123;        return p1 + String(p2)    &#125;&#125;var s = S(p2: 1)s.p1 = &quot;1&quot;print(s.f()) // 11\n属性类、结构体或枚举里的变量常量就是他们的属性。\nstruct S &#123;    static let sp = &quot;类型属性&quot; // 类型属性通过类型本身访问，非实例访问    var p1: String = &quot;&quot;    var p2: Int = 1    // cp 是计算属性    var cp: Int &#123;        get &#123;            return p2 * 2        &#125;        set &#123;            p2 = newValue + 2        &#125;    &#125;    // 只有 getter 的是只读计算属性    var rcp: Int &#123;        p2 * 4    &#125;&#125;print(S.sp)print(S().cp) // 2var s = S()s.cp = 3print(s.p2) // 5print(S().rcp) // 4\nwillSet 和 didSet 是属性观察器，可以在属性值设置前后插入自己的逻辑处理。\n键路径表达式作为函数\nstruct S2 &#123;    let p1: String    let p2: Int&#125;let s2 = S2(p1: &quot;one&quot;, p2: 1)let s3 = S2(p1: &quot;two&quot;, p2: 2)let a1 = [s2, s3]let a2 = a1.map(\\.p1)print(a2) // [&quot;one&quot;, &quot;two&quot;]\n方法enum E: String &#123;    case one, two, three    func showRawValue() &#123;        print(rawValue)    &#125;&#125;let e = E.threee.showRawValue() // three// 可变的实例方法，使用 mutating 标记struct S &#123;    var p: String    mutating func addFullStopForP() &#123;        p += &quot;.&quot;    &#125;&#125;var s = S(p: &quot;hi&quot;)s.addFullStopForP()print(s.p)// 类方法class C &#123;    class func cf() &#123;        print(&quot;类方法&quot;)    &#125;&#125;\nstatic和class关键字修饰的方法类似 OC 的类方法。static 可以修饰存储属性，而 class 不能；class 修饰的方法可以继承，而 static 不能。在协议中需用 static 来修饰。\n静态下标方法\n// 静态下标struct S2 &#123;    static var sp = [String: Int]()        static subscript(_ s: String, d: Int = 10) -&gt; Int &#123;        get &#123;            return sp[s] ?? d        &#125;        set &#123;            sp[s] = newValue        &#125;    &#125;&#125;S2[&quot;key1&quot;] = 1S2[&quot;key2&quot;] = 2print(S2[&quot;key2&quot;]) // 2print(S2[&quot;key3&quot;]) // 10\n自定义类型中实现了 callAsFunction() 的话，该类型的值就可以直接调用。\n// callAsFunction()struct S3 &#123;    var p1: String        func callAsFunction() -&gt; String &#123;        return &quot;show \\(p1)&quot;    &#125;&#125;let s2 = S3(p1: &quot;hi&quot;)print(s2()) // show hi\n继承类能继承另一个类，继承它的方法、属性等。\n// 类继承class C1 &#123;    var p1: String    var cp1: String &#123;        get &#123;            return p1 + &quot; like ATM&quot;        &#125;        set &#123;            p1 = p1 + newValue        &#125;    &#125;    init(p1: String) &#123;        self.p1 = p1    &#125;    func sayHi() &#123;        print(&quot;Hi! \\(p1)&quot;)    &#125;&#125;class C2: C1 &#123;    var p2: String    init(p2: String) &#123;        self.p2 = p2        super.init(p1: p2 + &quot;&#x27;s father&quot;)    &#125;&#125;C2(p2: &quot;Lemon&quot;).sayHi() // Hi! Lemon&#x27;s father// 重写父类方法class C3: C2 &#123;    override func sayHi() &#123;        print(&quot;Hi! \\(p2)&quot;)    &#125;&#125;C3(p2: &quot;Lemon&quot;).sayHi() // Hi! Lemon// 重写计算属性class C4: C1 &#123;    override var cp1: String &#123;        get &#123;            return p1 + &quot; like Out of the blade&quot;        &#125;        set &#123;            p1 = p1 + newValue        &#125;    &#125;&#125;print(C1(p1: &quot;Lemon&quot;).cp1) // Lemon like ATMprint(C4(p1: &quot;Lemon&quot;).cp1) // Lemon like Out of the blade\n通过 final 关键字可以防止类被继承，final 还可以用于属性和方法。使用 super 关键字指代父类。\n函数式mapmap 可以依次处理数组中元素，并返回一个处理后的新数组。\nlet a1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]let a2 = a1.map &#123;    &quot;\\($0)2&quot;&#125;print(a2) // [&quot;a2&quot;, &quot;b2&quot;, &quot;c2&quot;]\n使用 compactMap 可以过滤 nil 的元素。flatMap 会将多个数组合成一个数组返回。\nfilter根据指定条件返回\nlet a1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;call my name&quot;]let a2 = a1.filter &#123;    $0.prefix(1) == &quot;c&quot;&#125;print(a2) // [&quot;c&quot;, &quot;call my name&quot;]\nreducereduce 可以将迭代中返回的结果用于下个迭代中，并，还能让你设个初始值。\nlet a1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;call my name.&quot;, &quot;get it?&quot;]let a2 = a1.reduce(&quot;Hey u,&quot;, &#123; partialResult, s in    // partialResult 是前面返回的值，s 是遍历到当前的值    partialResult + &quot; \\(s)&quot;&#125;)print(a2) // Hey u, a b c call my name. get it?\nsorted排序\n// 类型遵循 Comparablelet a1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;call my name.&quot;, &quot;get it?&quot;]let a2 = a1.sorted()let a3 = a1.sorted(by: &gt;)let a4 = a1.sorted(by: &lt;)print(a2) // Hey u, a b c call my name. get it?print(a3) // [&quot;get it?&quot;, &quot;call my name.&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]print(a4) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;call my name.&quot;, &quot;get it?&quot;]// 类型不遵循 Comparablestruct S &#123;    var s: String    var i: Int&#125;let a5 = [S(s: &quot;a&quot;, i: 0), S(s: &quot;b&quot;, i: 1), S(s: &quot;c&quot;, i: 2)]let a6 = a5    .sorted &#123; l, r in        l.i &gt; r.i    &#125;    .map &#123;        $0.i    &#125;print(a6) // [2, 1, 0]\n控制流If// iflet s = &quot;hi&quot;if s.isEmpty &#123;    print(&quot;String is Empty&quot;)&#125; else &#123;    print(&quot;String is \\(s)&quot;)&#125;// 三元条件s.isEmpty ? print(&quot;String is Empty again&quot;) : print(&quot;String is \\(s) again&quot;)// if let-elsefunc f(s: String?) &#123;    if let s1 = s &#123;        print(&quot;s1 is \\(s1)&quot;)    &#125; else &#123;        print(&quot;s1 is nothing&quot;)    &#125;    // nil-coalescing    let s2 = s ?? &quot;nothing&quot;    print(&quot;s2 is \\(s2)&quot;)&#125;f(s: &quot;something&quot;)f(s: nil)// if case letenum E &#123;    case c1(String)    case c2([String])        func des() &#123;        switch self &#123;        case .c1(let string):            print(string)        case .c2(let array):            print(array)        &#125;    &#125;&#125;E.c1(&quot;enum c1&quot;).des()E.c2([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]).des()\nGuard更好地处理异常情况\n// guardfunc f1(p: String) -&gt; String &#123;    guard p.isEmpty != true else &#123;        return &quot;Empty string.&quot;    &#125;    return &quot;String \\(p) is not empty.&quot;&#125;print(f1(p: &quot;&quot;)) // Empty string.print(f1(p: &quot;lemon&quot;)) // String lemon is not empty.// guard letfunc f2(p1: String?) -&gt; String &#123;    guard let p2 = p1 else &#123;        return &quot;Nil.&quot;    &#125;    return &quot;String \\(p2) is not nil.&quot;&#125;print(f2(p1: nil)) // Nil.print(f2(p1: &quot;lemon&quot;)) // String lemon is not nil.\n遍历let a = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]for str in a &#123;    print(str)&#125;a.forEach &#123; str in    print(str)&#125;// 使用下标范围for i in 0..&lt;10 &#123;    print(i)&#125;for i in 0...9 &#123;     print(i) &#125;// 使用 enumerated，i 是下标，str 是元素for (i, str) in a.enumerated() &#123;    print(&quot;第\\(i + 1)个是:\\(str)&quot;)&#125;// for in wherefor str in a where str.prefix(1) == &quot;t&quot; &#123;    print(str)&#125;// 字典 for in，遍历是无序的let dic = [    &quot;one&quot;: 1,    &quot;two&quot;: 2,    &quot;three&quot;: 3]for (k, v) in dic &#123;    print(&quot;key is \\(k), value is \\(v)&quot;)&#125;dic.forEach &#123; (k, v) in    print(&quot;key is \\(k), value is \\(v)&quot;)&#125;// stridefor i in stride(from: 10, through: 0, by: -2) &#123;    print(i)&#125;/* 10 8 6 4 2 0 */ // 在循环中使用 continue 和 breakfor i in 0..&lt;10 &#123;    if i % 2 == 0 &#123;        continue    &#125;    print(i)&#125;// 在循环中使用 wherefor i in 0..&lt;10 where i % 2 == 0 &#123;    print(i)&#125;\nWhile// whilevar i1 = 10while i1 &gt; 0 &#123;    print(&quot;positive even number \\(i1)&quot;)    i1 -= 2&#125;// repeat whilevar i2 = 10repeat &#123;    print(&quot;positive even number \\(i2)&quot;)    i2 -= 2&#125; while i2 &gt; 0\n使用 break 结束遍历，使用 continue 跳过当前作用域，继续下个循环\nSwitchfunc f1(pa: String, t:(String, Int)) &#123;    var p1 = 0    var p2 = 10    switch pa &#123;    case &quot;one&quot;:        p1 = 1    case &quot;two&quot;:        p1 = 2        fallthrough // 继续到下个 case 中    default:        p2 = 0    &#125;    print(&quot;p1 is \\(p1)&quot;)    print(&quot;p2 is \\(p2)&quot;)        // 元组    switch t &#123;    case (&quot;0&quot;, 0):        print(&quot;zero&quot;)    case (&quot;1&quot;, 1):        print(&quot;one&quot;)    default:        print(&quot;no&quot;)    &#125;&#125;f1(pa: &quot;two&quot;, t:(&quot;1&quot;, 1))/* p1 is 2 p2 is 0 one */// 枚举enum E &#123;    case one, two, three, unknown(String)&#125;func f2(pa: E) &#123;    var p: String    switch pa &#123;    case .one:        p = &quot;1&quot;    case .two:        p = &quot;2&quot;    case .three:        p = &quot;3&quot;    case let .unknown(u) where Int(u) ?? 0 &gt; 0 : // 枚举关联值，使用 where 增加条件        p = u    case .unknown(_):        p = &quot;negative number&quot;    &#125;    print(p)&#125;f2(pa: E.one) // 1f2(pa: E.unknown(&quot;10&quot;)) // 10f2(pa: E.unknown(&quot;-10&quot;)) // negative number\n集合数组数组是有序集合\nvar a0: [Int] = [1, 10]a0.append(2)a0.remove(at: 0)print(a0) // [10, 2]let a1 = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]let a2 = [&quot;three&quot;, &quot;four&quot;]// 找两个集合的不同let dif = a1.difference(from: a2) // swift的 diffing 算法在这 http://www.xmailserver.org/diff2.pdf swift实现在  swift/stdlib/public/core/Diffing.swiftfor c in dif &#123;    switch c &#123;    case .remove(let o, let e, let a):        print(&quot;offset:\\(o), element:\\(e), associatedWith:\\(String(describing: a))&quot;)    case .insert(let o, let e, let a):        print(&quot;offset:\\(o), element:\\(e), associatedWith:\\(String(describing: a))&quot;)    &#125;&#125;/* remove offset:1, element:four, associatedWith:nil insert offset:0, element:one, associatedWith:nil insert offset:1, element:two, associatedWith:nil */let a3 = a2.applying(dif) ?? [] // 可以用于添加删除动画print(a3) // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]\ndif 有第三个 case 值 .insert(let offset, let element, let associatedWith) 可以跟踪成对的变化，用于高级动画。\n从数组中随机取一个元素\nprint(a0.randomElement() ?? 0)\n数组排序\n// 排序struct S1 &#123;    let n: Int    var b = true&#125;let a4 = [    S1(n: 1),    S1(n: 10),    S1(n: 3),    S1(n: 2)]let a5 = a4.sorted &#123; i1, i2 in    i1.n &lt; i2.n&#125;for n in a5 &#123;    print(n)&#125;/// S1(n: 1)/// S1(n: 2)/// S1(n: 3)/// S1(n: 10)let a6 = [1,10,4,7,2]print(a6.sorted(by: &gt;)) // [10, 7, 4, 2, 1]\n可以加到数组扩展中，通过扩展约束能够指定特定元素类型的排序，代码如下：\nextension Array where Element == Int &#123;    // 升序    func intSortedASC() -&gt; [Int] &#123;        return self.sorted(by: &lt;)    &#125;    // 降序    func intSortedDESC() -&gt; [Int] &#123;        return self.sorted(by: &lt;)    &#125;&#125;print(a6.intSortedASC()) // 使用扩展增加自定义排序能力\n在数组中检索满足条件的元素，代码如下：\n// 第一个满足条件了就返回let a7 = a4.first &#123;    $0.n == 10&#125;print(a7?.n ?? 0)// 是否都满足了条件print(a4.allSatisfy &#123; $0.n == 1 &#125;) // falseprint(a4.allSatisfy(\\.b)) // true// 找出最大的那个print(a4.max(by: &#123; e1, e2 in    e1.n &lt; e2.n&#125;) ?? S1(n: 0))// S1(n: 10, b: true)// 看看是否包含某个元素print(a4.contains(where: &#123;    $0.n == 7&#125;))// false\n一些切割数组的方法。\n// 切片// 取前3个，并不是直接复制，对于大的数组有性能优势。print(a6[..&lt;3]) // [1, 10, 4] 需要做越界检查print(a6.prefix(30)) // [1, 10, 4, 7, 2] 不需要做越界检查，也是切片，性能一样// 去掉前3个print(a6.dropFirst(3)) // [7, 2]\nprefix(while:) 和 drop(while:) 方法，顺序遍历执行闭包里的逻辑判断，满足条件就返回，遇到不匹配就会停止遍历。prefix 返回满足条件的元素集合，drop 返回停止遍历之后那些元素集合。\nlet a8 = [8, 9, 20, 1, 35, 3]let a9 = a8.prefix &#123;    $0 &lt; 30&#125;print(a9) // [8, 9, 20, 1]let a10 = a8.drop &#123;    $0 &lt; 30&#125;print(a10) // [35, 3]\n比 filter 更高效的删除元素的方法 removeAll\n// 删除所有不满足条件的元素var a11 = [1, 3, 5, 12, 25]a11.removeAll &#123; $0 &lt; 10 &#125;print(a11) // [12, 25]// 创建未初始化的数组let a12 = (0...4).map &#123; _ in    Int.random(in: 0...5)&#125;print(a12) // [0, 3, 3, 2, 5] 随机\n#if 用于后缀表达式\n// #if 用于后缀表达式let a13 = a11#if os(iOS)    .count#else    .reduce(0, +)#endifprint(a13) //37\nSetsSet 是无序集合，元素唯一\nlet s0: Set&lt;Int&gt; = [2, 4]let s1: Set = [2, 10, 6, 4, 8]let s2: Set = [7, 3, 5, 1, 9, 10]let s3 = s1.union(s2) // 合集let s4 = s1.intersection(s2) // 交集let s5 = s1.subtracting(s2) // 非交集部分let s6 = s1.symmetricDifference(s2) // 非交集的合集print(s3) // [4, 2, 1, 7, 3, 10, 8, 9, 6, 5]print(s4) // [10]print(s5) // [8, 4, 2, 6]print(s6) // [9, 1, 3, 4, 5, 2, 6, 8, 7]// s0 是否被 s1 包含print(s0.isSubset(of: s1)) // true// s1 是否包含了 s0print(s1.isSuperset(of: s0)) // truelet s7: Set = [3, 5]// s0 和 s7 是否有交集print(s0.isDisjoint(with: s7)) // true// 可变 Setvar s8: Set = [&quot;one&quot;, &quot;two&quot;]s8.insert(&quot;three&quot;)s8.remove(&quot;one&quot;)print(s8) // [&quot;two&quot;, &quot;three&quot;]\n字典字典是无序集合，键值对应。\nvar d1 = [    &quot;k1&quot;: &quot;v1&quot;,    &quot;k2&quot;: &quot;v2&quot;]d1[&quot;k3&quot;] = &quot;v3&quot;d1[&quot;k4&quot;] = nilprint(d1) // [&quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: &quot;v3&quot;, &quot;k1&quot;: &quot;v1&quot;]for (k, v) in d1 &#123;    print(&quot;key is \\(k), value is \\(v)&quot;)&#125;/* key is k1, value is v1 key is k2, value is v2 key is k3, value is v3 */ if d1.isEmpty == false &#123;    print(d1.count) // 3&#125;// mapValueslet d2 = d1.mapValues &#123;    $0 + &quot;_new&quot;&#125;print(d2) // [&quot;k2&quot;: &quot;v2_new&quot;, &quot;k3&quot;: &quot;v3_new&quot;, &quot;k1&quot;: &quot;v1_new&quot;]// 对字典的值或键进行分组let d3 = Dictionary(grouping: d1.values) &#123;    $0.count&#125;print(d3) // [2: [&quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;]]// 从字典中取值，如果键对应无值，则使用通过 default 指定的默认值d1[&quot;k5&quot;, default: &quot;whatever&quot;] += &quot;.&quot;print(d1[&quot;k5&quot;] ?? &quot;&quot;) // whatever.let v1 = d1[&quot;k3&quot;, default: &quot;whatever&quot;]print(v1) // v3// compactMapValues() 对字典值进行转换和解包。可以解可选类型，并去掉 nil 值let d4 = [    &quot;k1&quot;: 1,    &quot;k2&quot;: 2,    &quot;k3&quot;: nil]let d5 = d4.mapValues &#123; $0 &#125;let d6 = d4.compactMapValues&#123; $0 &#125;print(d5)// [&quot;k3&quot;: nil, &quot;k1&quot;: Optional(1), &quot;k2&quot;: Optional(2)]print(d6)// [&quot;k1&quot;: 1, &quot;k2&quot;: 2]\n操作符赋值let i1 = 1var i2 = i1i2 = 2print(i2) // 2i2 += 1print(i2) // 3i2 -= 2print(i2) // 1i2 *= 10print(i2) // 10i2 /= 2print(i2) // 5\n计算符let i1 = 1let i2 = i1print((i1 + i2 - 1) * 10 / 2 % 3) // 2print(&quot;i&quot; + &quot;1&quot;) // i1// 一元运算符print(-i1) // -1\n比较运算符遵循 Equatable 协议可以使用 &#x3D;&#x3D; 和 !&#x3D; 来判断是否相等\nprint(1 &gt; 2) // falsestruct S: Equatable &#123;    var p1: String    var p2: Int&#125;let s1 = S(p1: &quot;one&quot;, p2: 1)let s2 = S(p1: &quot;two&quot;, p2: 2)let s3 = S(p1: &quot;one&quot;, p2: 2)let s4 = S(p1: &quot;one&quot;, p2: 1)print(s1 == s2) // falseprint(s1 == s3) // falseprint(s1 == s4) // true\n类需要实现 &#x3D;&#x3D; 函数\nclass C: Equatable &#123;    var p1: String    var p2: Int    init(p1: String, p2: Int) &#123;        self.p1 = p1        self.p2 = p2    &#125;        static func == (l: C, r: C) -&gt; Bool &#123;        return l.p1 == r.p1 &amp;&amp; l.p2 == r.p2    &#125;&#125;let c1 = C(p1: &quot;one&quot;, p2: 1)let c2 = C(p1: &quot;one&quot;, p2: 1)print(c1 == c2)// 元组比较// 会先比较第一个数，第一个无法比较才会比较第二个数// 字符串比较和字母大小还有长度有关。先比较字母大小，在比较长度(&quot;apple&quot;, 1) &lt; (&quot;apple&quot;, 2) // true(&quot;applf&quot;, 1) &lt; (&quot;apple&quot;, 2) // false(&quot;appl&quot;, 2) &lt; (&quot;apple&quot;, 1) // true(&quot;appm&quot;, 2) &lt; (&quot;apple&quot;, 1) // false\n三元简化 if else 写法\n// if elsefunc f1(p: Int) &#123;    if p &gt; 0 &#123;        print(&quot;positive number&quot;)    &#125; else &#123;        print(&quot;negative number&quot;)    &#125;&#125;// 三元func f2(p: Int) &#123;    p &gt; 0 ? print(&quot;positive number&quot;) : print(&quot;negative number&quot;)&#125;f1(p: 1)f2(p: 1)\ncoalescing简化 if let else 写法\n// if elsefunc f1(p: Int?) &#123;    if let i = p &#123;        print(&quot;p have value is \\(i)&quot;)    &#125; else &#123;        print(&quot;p is nil, use defalut value&quot;)    &#125;&#125;// 使用 ??func f2(p: Int?) &#123;    let i = p ?? 0    print(&quot;p is \\(i)&quot;)&#125;\n范围简化的值范围表达方式。\n// 封闭范围for i in 0...10 &#123;    print(i)&#125;// 半开范围for i in 0..&lt;10 &#123;    print(i)&#125;\n// 单侧区间let nums = [5,6,7,8]print(nums[2...]) // 7 8\n逻辑let i1 = -1let i2 = 2if i1 != i2 &amp;&amp; (i1 &lt; 0 || i2 &lt; 0) &#123;    print(&quot;i1 and i2 not equal, and one of them is negative number.&quot;)&#125;\n恒等恒等返回是否引用了相同实例。\nclass C &#123;    var p: String    init(p: String) &#123;        self.p = p    &#125;&#125;let c1 = C(p: &quot;one&quot;)let c2 = C(p: &quot;one&quot;)let c3 = c1print(c1 === c2) // falseprint(c1 === c3) // trueprint(c1 !== c2) // true\n运算符位运算符\nlet i1: UInt8 = 0b00001111let i2 = ~i1 // Bitwise NOT Operator（按位取反运算符），取反let i3: UInt8 = 0b00111111let i4 = i1 &amp; i3 // Bitwise AND Operator（按位与运算符），都为1才是1let i5 = i1 | i3 // Bitwise OR Operator（按位或运算符），有一个1就是1let i6 = i1 ^ i3 // Bitwise XOR Operator（按位异或运算符），不同为1，相同为0print(i1,i2,i3,i4,i5,i6)// &lt;&lt; 按位左移，&gt;&gt; 按位右移let i7 = i1 &lt;&lt; 1let i8 = i1 &gt;&gt; 2print(i7,i8)\n溢出运算符，有 &amp;+、&amp;- 和 &amp;*\nvar i1 = Int.maxprint(i1) // 9223372036854775807i1 = i1 &amp;+ 1print(i1) // -9223372036854775808i1 = i1 &amp;+ 10print(i1) // -9223372036854775798var i2 = UInt.maxi2 = i2 &amp;+ 1print(i2) // 0\n运算符函数包括前缀运算符、后缀运算符、复合赋值运算符以及等价运算符。另，还可以自定义运算符，新的运算符要用 operator 关键字进行定义，同时要指定 prefix、infix 或者 postfix 修饰符。\nSwift规范参考：\n\nSwift Style Guide\n\n多用静态特性。swift 在编译期间所做的优化比 OC 要多，这是由于他的静态派发、泛型特化、写时复制这些静态特性决定的。另外通过 final 和 private 这样的表示可将动态特性转化为静态方式，编译开启 WMO 可以自动推导出哪些动态派发可转化为静态派发。\n如何避免崩溃？\n\n字典：用结构体替代\nAny：可用泛型或关联关联类型替代\nas? ：少用 AnyObject，多用泛型或不透明类型\n!：要少用\n\n好的实践？\n\n少用继承，多用 protocol\n多用 extension 对自己代码进行管理\n\nSwift书单\n《Thinking in SwiftUI》\n《Swift 进阶》\n《函数式Swift》\n《深入解析Mac OS X &amp; iOS操作系统》\n《LLVM Techniques, Tips, and Best Practices Clang and Middle-End Libraries》\n《Learn LLVM 12》\n《Crafting Interpreters》\n《TCP&#x2F;IP Illustrated》\n《松本行弘的程序世界》\n《现代操作系统》\n《深入理解计算机系统》\n《程序员的自我修养》\n《Head First 设计模式》\n\n"},{"title":"Day10-GCD 进阶","url":"/2025/05/08/Day10-GCD-%E8%BF%9B%E9%98%B6/","content":"一、GCD 队列底层原理1.1 队列类型\n串行队列：一次只执行一个任务。\n并发队列：可以并发执行多个任务。\n主队列：主线程的串行队列，用于更新 UI。\n\n1.2 队列背后的线程\nGCD 使用 线程池 管理线程，具体由 libdispatch + pthread 实现。\n并发队列任务实际是串行调度、并发执行（由系统根据线程池和资源自动调度）。\n\n二、常见 GCD 高级用法2.1 dispatch_barrier（栅栏函数）dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.queue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123;    // 任务1&#125;);dispatch_barrier_async(queue, ^&#123;    // 栅栏任务：写操作&#125;);dispatch_async(queue, ^&#123;    // 任务2&#125;);\n\n2.2 dispatch_group（任务组）dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_group_async(group, queue, ^&#123;    // 任务1&#125;);dispatch_group_async(group, queue, ^&#123;    // 任务2&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;    // 所有任务完成后执行&#125;);\n\n2.3 dispatch_semaphore（信号量）dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);dispatch_async(queue, ^&#123;    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);    // 临界区    dispatch_semaphore_signal(semaphore);&#125;);\n\n三、避免死锁与优雅使用3.1 死锁示例（主队列同步调用）dispatch_sync(dispatch_get_main_queue(), ^&#123;    // 死锁：当前已经在主线程，又等主队列执行&#125;);\n\n3.2 dispatch_once（线程安全的单例初始化）static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;    // 初始化逻辑&#125;);\n\n四、GCD 优化技巧与实践4.1 控制最大并发数（结合 semaphore）dispatch_semaphore_t sema = dispatch_semaphore_create(3);for (int i = 0; i &lt; 10; i++) &#123;    dispatch_async(queue, ^&#123;        dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);        // 下载任务        dispatch_semaphore_signal(sema);    &#125;);&#125;\n\n4.2 使用 QoS（服务质量）dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_USER_INITIATED, 0);dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.qosqueue&quot;, attr);\n\n五、和 NSOperation 比较\n\n\n特性\nGCD\nNSOperation\n\n\n\n简洁性\n✅\n❌（更复杂）\n\n\n依赖管理\n❌\n✅（operation.addDependency）\n\n\n取消任务\n❌\n✅（operation.cancel）\n\n\n重用性&#x2F;扩展性\n❌\n✅（子类化）\n\n\n并发控制（数量）\n借助 semaphore\n✅（maxConcurrentOperationCount）\n\n\nGCD 的底层实现原理Grand Central Dispatch（GCD）是苹果提供的一个多线程并发编程框架，其底层实现原理可以从几个关键的技术点来理解，包括：\n\n一、核心结构与实现基础1. GCD 基于 libdispatch 实现GCD 的底层是开源的 libdispatch 库，核心用 C 和 C++ 编写，运行在系统内核之上，封装了线程调度、任务分发、队列管理等功能。\n\n二、任务与队列模型1. 任务：Block 形式的封装代码（实质是闭包）每个任务是一个 dispatch_block_t，本质是封装在结构体中的函数指针和上下文数据。\n2. 队列：串行 or 并发\n串行队列：任务一个个顺序执行。\n并发队列：任务可同时执行，具体是否并行取决于系统资源。\n\n底层由结构体 dispatch_queue_s 表示，内部包含：\n\n队列名称\n优先级（QoS）\nTarget Queue（用于继承行为）\n队列状态（是否正在执行任务）\n队列类型（串行&#x2F;并发）\n\n\n三、线程调度原理1. 线程池机制GCD 不直接创建线程，而是复用一个系统管理的线程池（Managed Thread Pool）：\n\nApple 使用内核的 pthread 和 kqueue 机制动态创建和调度线程。\n调用 dispatch_async 等方法时任务进入队列，等待调度器（libdispatch）判断是否需要从线程池中取线程执行。\n\n2. 结合内核的调度器\n使用 XNU 内核提供的 workloop（基于 kqueue）来监视队列变化。\n利用信号量、原子操作、互斥锁控制任务同步。\n\n\n四、队列的调度机制1. dispatch_async &#x2F; dispatch_sync 的区别\n\n\n方法\n调度行为\n是否阻塞线程\n\n\n\ndispatch_async\n异步入队\n否\n\n\ndispatch_sync\n同步执行，当前线程等待任务完成\n是\n\n\n底层通过：\n\ndispatch_async：创建任务对象 -&gt; 放入目标队列 -&gt; 唤醒线程池中的线程处理\ndispatch_sync：直接调用任务，并使用 semaphore 阻塞当前线程，直到任务执行完\n\n\n五、QoS（服务质量）控制GCD 支持 QoS（Quality of Service）等级，例如：\n\nuserInteractive（最高）\nuserInitiated\ndefault\nutility\nbackground（最低）\n\n这些优先级通过底层设置线程调度属性，在内核中会影响线程抢占和执行顺序。\n\n六、关键数据结构（源码角度）1. dispatch_queue_s（队列结构体）包含：\nstruct dispatch_queue_s &#123;    ...    dispatch_object_t _head;    // 队列头部    dispatch_object_t _tail;    // 队列尾部    pthread_priority_t _priority; // 优先级    ...&#125;;\n\n2. dispatch_continuation_s（封装 block 的任务结构体）struct dispatch_continuation_s &#123;    void *dc_func;     // block 函数指针    void *dc_ctxt;     // block 上下文    ...&#125;;\n\n\n七、并发控制：信号量、栅栏、组\ndispatch_semaphore：底层基于 semaphore_t（Mach 信号量）\ndispatch_barrier：写操作时阻塞其他任务，底层使用任务依赖和标记机制实现\ndispatch_group：通过计数器追踪任务组状态，配合信号量实现通知\n\n\n总结GCD 是基于 libdispatch 构建的线程池 + 队列调度框架，其核心优势包括：\n\n高效的线程复用\n简洁的 API 封装（block）\n动态优先级管理（QoS）\n底层结合内核机制（如 kqueue 和 pthread）\n\n","categories":["基础"]},{"title":"Day10-合并两个有序链表","url":"/2025/05/08/Day10-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","content":"🔗 LeetCode 21 - Merge Two Sorted Lists\n📌 题目描述将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接两个给定链表的所有节点组成的。\n示例：\n输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]\n\n💡 解题思路\n使用递归或迭代方法；\n比较两个链表当前节点值，较小者接入新链表；\n依次向后合并直到一个链表为空。\n时间复杂度：O(n + m)\n空间复杂度：O(n + m)（递归栈）或 O(1)（迭代）\n\n\n✅ JavaScript 实现（迭代）var mergeTwoLists = function(l1, l2) &#123;    const dummy = new ListNode(-1);    let curr = dummy;    while (l1 &amp;&amp; l2) &#123;        if (l1.val &lt; l2.val) &#123;            curr.next = l1;            l1 = l1.next;        &#125; else &#123;            curr.next = l2;            l2 = l2.next;        &#125;        curr = curr.next;    &#125;    curr.next = l1 || l2;    return dummy.next;&#125;;\n\n\n🧠 思考拓展\n如果链表是降序的怎么办？\n如何使用递归方式实现？\n能否拓展为合并 k 个有序链表？\n\n","categories":["算法"]}]