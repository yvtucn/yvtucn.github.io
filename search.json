[{"title":"Day1-UIKit事件传递机制 & Responder Chain","url":"/2025/04/23/Day1-UIKit%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6-Responder-Chain/","content":"UIKit 事件传递机制 &amp; Responder Chain一、事件类型UIKit 中主要的事件类型包括：\n\n触摸事件（Touch Events）：如 tap、swipe、pinch 等。\n运动事件（Motion Events）：如摇动设备。\n远程控制事件（Remote-Control Events）：如耳机控制、CarPlay。\n按键事件（Press Events）（仅限 tvOS 或支持硬件键盘时的 iOS）。\n\n\n二、事件传递流程\n事件产生：\n\n事件由硬件（屏幕、传感器等）检测后交给系统。\niOS 将事件加入到主线程的 UIApplication 对象中进行分发。\n\n\n事件分发路径：\n\nUIApplication → UIWindow → UIView\n\n\n命中测试（Hit-Testing）：\n\n从根视图（window 的 rootView）开始递归查找目标视图。\n使用两个方法：\npoint(inside:with:)\nhitTest(_:with:)\n\n\n最终找到最合适的视图接收触摸事件。\n\n\n\n\n三、Responder Chain（响应者链）1. 什么是 Responder Chain？Responder Chain 是一条事件响应链，用来处理视图无法响应的事件。\n2. Responder Chain 构成一个 UIResponder 对象（如 UIView、UIViewController）可以传递事件给其上层响应者：UIView → UIViewController → UIWindow → UIApplication → AppDelegate\n如果某个对象无法处理事件，它会把事件传递给下一个响应者。\n3. UIResponder 方法\n\n\n方法名\n说明\n\n\n\ntouchesBegan(_:with:)\n开始触摸\n\n\ntouchesMoved(_:with:)\n触摸移动\n\n\ntouchesEnded(_:with:)\n触摸结束\n\n\ntouchesCancelled(_:with:)\n触摸被取消\n\n\n还可以通过 canBecomeFirstResponder 和 becomeFirstResponder() 控制焦点。\n\n四、自定义事件传递（常见场景）1. UIView 不响应事件可能是因为以下原因：\n\nisUserInteractionEnabled = false\nalpha &lt; 0.01\nhidden = true\n\n2. 自定义控件事件传递可重写以下方法：\n\nhitTest(_:with:)：决定谁是事件的最终响应者。\npoint(inside:with:)：判断点是否在当前视图内。\n\n\n五、Responder Chain 应用场景\n控件事件传递：如 UIButton 点击事件向上传递。\n菜单处理：如复制粘贴菜单响应。\n键盘响应管理。\n自定义事件路由（target-action 无法处理时）。\n\n\n六、调试技巧\n使用 View Debugger 检查视图层级。\n打断点调试 hitTest 和 touchesBegan。\n查看 next 属性追踪 Responder Chain。\n\n\n七、总结\nUIKit 事件从 UIApplication 开始，经过 UIWindow 最终传递给具体的 UIView。\nResponder Chain 是事件冒泡机制的实现，支持事件的多级处理。\n通过合理利用 hitTest: 和 Responder Chain，可以实现复杂交互需求。\n\n","categories":["基础"]},{"title":"Day1-两数之和","url":"/2025/04/23/Day1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"🧠 算法题：两数之和（Two Sum）\n🎯 题目描述：\n给定一个整数数组 nums 和一个目标值 target，请你在数组中找出两个加起来等于目标值的数字，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但数组中同一个元素不能使用两遍。\n\n💡 示例：\n输入: nums = [2, 7, 11, 15], target = 9输出: [0, 1] 解释: 因为 nums[0] + nums[1] == 9\n\n✅ 解题要求：\t•\t时间复杂度尽量做到 O(n)\t•\t返回一组下标即可，无需考虑顺序\t•\t提供 Swift 或 Objective-C 实现\n\n✨ 提示：\n你可以用哈希表记录访问过的数字及其下标，在遍历时直接判断 target - 当前值 是否存在于 map 中。\n\n🚀 拓展思考（建议尝试）：\t1.\t如果要求返回所有可能的两数组合（即可能有多个答案），你会怎么做？\t2.\t如果输入是一个有序数组，你是否可以用双指针优化？\n\n🔧 模板（Swift 示例）：\nfunc twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123;    var map = [Int: Int]()  // 记录数字和对应的下标    for (index, num) in nums.enumerated() &#123;        let complement = target - num        if let otherIndex = map[complement] &#123;            return [otherIndex, index]        &#125;        map[num] = index    &#125;    return []&#125;\n\nJS版本：\n/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123;    let map = new Map();    for (let i = 0; i &lt; nums.length; i++) &#123;        let diff = target - nums[i];        if (map.has(diff)) &#123;            return [map.get(diff), i];        &#125;        map.set(nums[i], i);    &#125;&#125;;\n\n👉 LeetCode 1. 两数之和\n","categories":["算法"],"tags":["算法"]},{"title":"Day2-View 布局流程","url":"/2025/04/24/Day2-View-%E5%B8%83%E5%B1%80%E6%B5%81%E7%A8%8B/","content":"View 布局流程详解一、布局流程总览iOS 的视图布局流程由 UIKit 管理，核心遵循「从父到子、从外向内」的递归更新方式。涉及的关键方法有：\n\nlayoutSubviews：真正进行子视图位置布局的地方\nsetNeedsLayout：标记视图为需要重新布局\nlayoutIfNeeded：立即强制布局\n\n布局流程如下：属性变化（如 frame）或手动触发↓调用 setNeedsLayout（标记需要布局）↓下一个 runloop 执行 layoutIfNeeded↓系统递归调用 layoutSubviews 进行布局\n\n二、关键方法详解1. setNeedsLayout\n作用：标记当前视图为“需要重新布局”\n调用时机：当视图状态或依赖数据变化时\n注意：不会立即执行 layoutSubviews，而是在下一个 runloop 进行布局\n\n[self.view setNeedsLayout];\n\n2. layoutIfNeeded\n作用：立即执行布局流程（如果已标记）\n常用场景：动画中强制更新 layout，确保视图状态正确  [self.view layoutIfNeeded];\n\n3. layoutSubviews\n作用：布局子视图，子类通过重写此方法来自定义布局逻辑\n调用方式：系统自动调用，或通过 layoutIfNeeded 间接触发  - (void)layoutSubviews &#123;    [super layoutSubviews];    self.label.frame = CGRectMake(10, 10, 100, 40);&#125;\n\n三、布局触发时机布局流程会在以下情况下自动触发：\n\n视图初始化完成后首次添加到视图层级中\nframe &#x2F; bounds &#x2F; center 属性改变\n调用 setNeedsLayout + layoutIfNeeded\n屏幕旋转、设备方向变化\nAuto Layout 约束变化\n\n四、Auto Layout 参与布局流程当使用 Auto Layout（自动布局）时：\n\n不推荐在 layoutSubviews 中设置 frame\n更新约束应在 updateConstraints 方法中完成\nupdateConstraints → layoutSubviews → drawRect 是完整的调用链  - (void)updateConstraints &#123;    // 更新约束    [super updateConstraints];&#125;\n\n五、UIView 与 CALayer 的关系\n每个 UIView 都有一个对应的 CALayer\nUIView.frame 实际上是操作 CALayer.frame\n布局本质上是在更新图层的属性  NSLog(@&quot;%@&quot;, NSStringFromCGRect(self.view.layer.frame));\n\n六、文字版布局流程图[视图属性变更]      ↓[setNeedsLayout] → 标记布局      ↓[下一个 runloop]      ↓[layoutIfNeeded] → 判断并触发布局      ↓[layoutSubviews] → 更新子视图 frame\n\n七、面试高频问题整理Q1：layoutSubviews 和 drawRect 有什么区别？\nlayoutSubviews：用于更新子视图的布局\ndrawRect：用于自定义视图绘图（如 Core Graphics）\n\nQ2：如何立即触发布局？[self.view setNeedsLayout];[self.view layoutIfNeeded];\n\nQ3：什么时候会调用 layoutSubviews？\n添加到父视图后\nframe 改变\nsetNeedsLayout + layoutIfNeeded\nAuto Layout 触发\n\nQ4：如何在动画中确保布局生效？[UIView animateWithDuration:0.3 animations:^&#123;    // 修改布局前置条件    [self.view layoutIfNeeded]; // 强制立即布局&#125;];\n\n八、参考资料\nApple Developer 文档：UIView Class Reference\n官方指南：View Programming Guide for iOS\n\n","categories":["基础"]},{"title":"Day2-用栈实现队列","url":"/2025/04/24/Day2-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","content":"🔗 LeetCode 232 - Implement Queue using Stacks\n📌 题目描述：使用两个栈 stackIn 和 stackOut 实现一个队列，支持以下操作：\n\npush(x)：将元素 x 推到队列的末尾\npop()：移除队列开头的元素并返回\npeek()：返回队列开头的元素\nempty()：返回队列是否为空\n\n要求：只能使用栈的标准操作（push, pop, peek, empty）\n\n💡 解题思路：\n入队操作（push）直接往 stackIn 中加元素；\n出队操作（pop 或 peek）时，如果 stackOut 为空，则将 stackIn 中的所有元素倒序转移到 stackOut；\n保证先进先出（FIFO）的顺序。\n\n\n✅ JavaScript 实现：var MyQueue = function () &#123;    this.stackIn = [];    this.stackOut = [];&#125;;MyQueue.prototype.push = function (x) &#123;    this.stackIn.push(x);&#125;;MyQueue.prototype.pop = function () &#123;    if (this.stackOut.length === 0) &#123;        while (this.stackIn.length) &#123;            this.stackOut.push(this.stackIn.pop());        &#125;    &#125;    return this.stackOut.pop();&#125;;MyQueue.prototype.peek = function () &#123;    if (this.stackOut.length === 0) &#123;        while (this.stackIn.length) &#123;            this.stackOut.push(this.stackIn.pop());        &#125;    &#125;    return this.stackOut[this.stackOut.length - 1];&#125;;MyQueue.prototype.empty = function () &#123;    return this.stackIn.length === 0 &amp;&amp; this.stackOut.length === 0;&#125;;\n\n\n\n🧠 思考拓展：\n如果反过来是“用队列实现栈”应该怎么做？👉 LeetCode 225\n队列相关拓展题：滑动窗口最大值、最小栈等\n\n","categories":["算法"],"tags":["算法"]},{"title":"Day3-有效的括号","url":"/2025/04/25/Day3-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","content":"🔗 LeetCode 20 - Valid Parentheses\n📌 题目描述给定一个只包括 &#39;(&#39;, &#39;)&#39;, &#39;&#123;&#39;, &#39;&#125;&#39;, &#39;[&#39;, &#39;]&#39; 的字符串 s，判断字符串是否是有效的。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n空字符串也为有效字符串。\n\n\n💡 解题思路\n使用栈结构来处理括号匹配；\n遇到左括号就入栈，遇到右括号时判断是否和栈顶配对；\n若匹配，则弹出栈顶；否则直接返回 false；\n最后栈为空，则为合法字符串。\n\n\n✅ JavaScript 实现var isValid = function (s) &#123;    const stack = [];    const map = &#123;        &#x27;)&#x27;: &#x27;(&#x27;,        &#x27;&#125;&#x27;: &#x27;&#123;&#x27;,        &#x27;]&#x27;: &#x27;[&#x27;    &#125;;    for (let char of s) &#123;        if ([&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;].includes(char)) &#123;            stack.push(char);        &#125; else &#123;            if (stack.pop() !== map[char]) &#123;                return false;            &#125;        &#125;    &#125;    return stack.length === 0;&#125;;\n\n\n🧠 思考拓展\n括号匹配是栈结构经典应用，请理解其底层思想；\nLeetCode 拓展题推荐：\n22. Generate Parentheses（括号生成）\n32. Longest Valid Parentheses（最长有效括号）\n\n\n\n","categories":["算法"]},{"title":"Day4-有效的字母异位词","url":"/2025/04/27/Day4-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","content":"🔗 LeetCode 242 - Valid Anagram\n📌 题目描述：给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。\n字母异位词的定义：如果两个字符串中的字母出现的频率相同且字符完全一致，那么这两个字符串是字母异位词。\n\n💡 解题思路：•\t将两个字符串 s 和 t 的字母出现频次统计出来，若两个字符串的字母频次完全相同，则它们是字母异位词。\n•\t通过使用哈希表或数组存储字母的频率。\n\n\n✅ JavaScript 实现：var isAnagram = function (s, t) &#123;    if (s.length !== t.length) return false;        const count = new Array(26).fill(0);        for (let i = 0; i &lt; s.length; i++) &#123;        count[s.charCodeAt(i) - &#x27;a&#x27;.charCodeAt(0)]++;        count[t.charCodeAt(i) - &#x27;a&#x27;.charCodeAt(0)]--;    &#125;        for (let i = 0; i &lt; 26; i++) &#123;        if (count[i] !== 0) return false;    &#125;        return true;&#125;;\n\n\n\n\n🧠 思考拓展：•\t字母异位词问题的优化：如何减少不必要的比较，提升算法效率？\n•\t对比其他字符串相关的题目，比如 387. First Unique Character in a String。\n\n\n","categories":["算法"]},{"title":"Day3-Block 分类、变量捕获与作用域","url":"/2025/04/25/Day3-Block-%E5%88%86%E7%B1%BB%E3%80%81%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"Block 分类、变量捕获与作用域一、Block 的分类Block 在 Objective-C 中，根据其存储位置和生命周期分为以下三类：\n\n\n\nBlock 类型\n存储位置\n特点说明\n\n\n\nGlobal Block\n全局区\n不捕获外部变量\n\n\nStack Block\n栈上\n捕获外部变量，随栈帧销毁\n\n\nHeap Block\n堆上\n捕获外部变量，Block_copy 后存在堆上\n\n\n示例：void (^block1)(void) = ^&#123;    NSLog(@&quot;Hello&quot;);&#125;;// Global Blockint a = 10;void (^block2)(void) = ^&#123;    NSLog(@&quot;a = %d&quot;, a);&#125;;// Stack Blockvoid (^block3)(void) = [block2 copy];// Heap Block\n\n\n二、变量捕获（Captured Variables）1. 默认捕获（值语义）Block 默认以值方式拷贝局部变量，不可修改。\nint a = 5;void (^block)(void) = ^&#123;    NSLog(@&quot;a is %d&quot;, a);&#125;;a = 6;block(); // 输出 a is 5\n\n2. __block 修饰（引用语义）允许在 Block 内部修改外部变量。\n__block int a = 5;void (^block)(void) = ^&#123;    a = 10;&#125;;block();NSLog(@&quot;a is %d&quot;, a); // 输出 a is 10\n\n3. 对象捕获（指针语义）对象变量以指针形式捕获，会被强引用。\nNSString *str = @&quot;Hello&quot;;void (^block)(void) = ^&#123;    NSLog(@&quot;%@&quot;, str);&#125;;// str 被 retain\n\n\n三、作用域与内存管理生命周期：\nStack Block 生命周期短，超出作用域会被销毁。\n需要异步使用时，必须将 Block copy 到堆上，变为 Heap Block。\nARC 下自动进行 copy 操作；MRC 需手动调用 Block_copy。\n\n示例（ARC 异步安全）：dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;    NSLog(@&quot;Block executed&quot;);&#125;);// ARC 自动 copy 到堆\n\n\n四、Swift 中的闭包捕获Swift 中闭包默认强引用捕获对象：\nclass MyClass &#123;    var name = &quot;Test&quot;    func doSomething() &#123;        DispatchQueue.global().async &#123; [weak self] in            print(self?.name ?? &quot;nil&quot;)        &#125;    &#125;&#125;\n\n使用 [weak self] &#x2F; [unowned self] 可避免循环引用。\n\n五、小结对比表\n\n\n分类\n是否捕获变量\n存储位置\n生命周期控制\n\n\n\nGlobal Block\n否\n全局区\n程序生命周期内常驻\n\n\nStack Block\n是\n栈上\n随栈帧销毁\n\n\nHeap Block\n是\n堆上\nBlock_copy 后存在于堆中\n\n\n","categories":["基础"]},{"title":"Day5-Objective-C Runtime 基础结构","url":"/2025/04/28/Day5-Objective-C-Runtime-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/","content":"Objective-C Runtime 基础结构Objective-C 运行时系统（Runtime）是 Objective-C 语言的核心部分，它在程序运行期间负责管理类、对象、方法调用等行为。\n主要的结构体和组件包括：\n1. objc_class（类结构体）struct objc_class &#123;    Class isa;                // 指向元类    Class super_class;        // 父类    const char *name;         // 类名    long version;             // 版本信息    long info;                // 类信息标志    long instance_size;       // 类实例的大小    struct objc_ivar_list *ivars;    // 成员变量列表    struct objc_method_list **methodLists; // 方法列表（数组）    struct objc_cache *cache; // 方法缓存    struct objc_protocol_list *protocols; // 协议列表&#125;;\n\n注意：现代 Runtime 中，结构体已经变化了，上述是经典（早期）的描述，新的版本更复杂且高度封装。\n\n\n2. objc_object（对象结构体）struct objc_object &#123;    Class isa;  // 指向对象所属的类&#125;;\n\n每一个对象底层其实就是一个指针，最重要的成员就是 isa。\nisa 既可以指向 Class，也可以指向 Meta-Class（元类）。\n\n\n3. objc_method（方法结构体）struct objc_method &#123;    SEL name;      // 方法选择器（Selector）    char *types;   // 方法的参数和返回值类型编码    IMP imp;       // 方法实现的函数指针&#125;;\n\nSEL 是方法名的唯一标识。\nIMP 是函数指针，本质上就是 C 函数的地址。\n\n\n4. objc_ivar（成员变量结构体）struct objc_ivar &#123;    char *name;        // 变量名    char *typeEncoding; // 类型编码    int offset;         // 变量在对象内存中的偏移量&#125;;\n\n成员变量的信息，包括名字、类型和内存位置。\n\n\n5. objc_property（属性结构体）在现代 Runtime 里面，属性也有自己的结构：\ntypedef struct &#123;    const char *name;            // 属性名    const char *attributes;      // 属性修饰列表（例如：T@&quot;NSString&quot;,C,N,V_name）&#125; objc_property_t;\n\n属性其实是成员变量 + 一些特定特性（getter&#x2F;setter规则）。\n\n\n小总结\n\n\n组件\n作用\n\n\n\nobjc_object\n所有对象的基础\n\n\nobjc_class\n类对象描述结构\n\n\nobjc_method\n方法的定义\n\n\nobjc_ivar\n成员变量定义\n\n\nobjc_property\n属性定义\n\n\n\n进阶补充在 现代 Objective-C Runtime（如 iOS 14+），这些结构体实际上被进一步封装优化，比如：\n\n类使用 objc_class 和 objc_data_bits_t（联合体）分离了缓存、只读数据等。\nmethodList 也使用更紧凑的链表存储。\nisa 指针通过 isa 指针优化（ISA指针打包） 包含了更多信息，比如引用计数、是否有C++析构函数等。\n\n\n现代 Objective-C Runtime 的优化\n\nobjc_class 和 objc_data_bits_t 的分离\n\n早期（传统）的结构：\n在早期的 Objective-C Runtime 中，类对象（objc_class）包含了所有关于类的描述信息，包括：\n\nisa 指针（指向元类）\nsuper_class（父类指针）\n成员变量、方法列表、属性等\n\n这种结构虽然简单，但随着 iOS 设备性能的提高，运行时系统也需要对这些数据结构进行优化。\n现代优化：\n在 iOS 14 及之后的版本中，Objective-C Runtime 通过 分离 类的各个组成部分，提高了性能和内存效率。\nobjc_class 现在主要包含 元类的引用，而其它数据（如方法列表、属性、成员变量等）被移到了 objc_data_bits_t 结构中。这种方式的好处是：\n\n缓存友好：类的元数据可以被存储在内存的紧凑区域，提高了缓存命中率。\n分离存储：类数据和方法数据分开存储，避免了冗余的内存占用。\n增强的灵活性：可以在不同的硬件架构下对这些数据进行不同的布局，以便更好地适配不同的内存和处理器特性。\n\n例子：\nobjc_class 结构变得非常简洁：\nstruct objc_class &#123;    Class isa;                // 指向元类    Class super_class;        // 父类    const char *name;         // 类名    ...    objc_data_bits_t data;    // 类的其它元数据，如方法、属性、缓存等&#125;;\n\n而 objc_data_bits_t 则包含了实际的数据部分：\nunion objc_data_bits_t &#123;    struct &#123;        method_list_t *methodList;   // 方法列表        ivar_list_t *ivarList;       // 成员变量列表        property_list_t *propertyList; // 属性列表        cache_t cache;               // 方法缓存    &#125;;    uintptr_t raw; // 原始内存表示&#125;;\n\n\n\n\nmethodList 存储的优化\n\n早期存储：\n传统的 methodList 是基于链表（Linked List）存储的。这种方式虽然简单，但查找方法时效率较低，尤其是在类层级很深或者方法很多的情况下。\n现代优化：\n在现代的 Runtime 系统中，methodList 不再是单纯的链表。它现在采用了一种 紧凑的链表结构，并且结合了 哈希表（Hash Table） 或者 二叉搜索树（Binary Search Tree），大大提高了方法查找的效率。\n\n哈希表：通过哈希值来存储方法，查找操作时间复杂度为 O(1)。\n二叉搜索树：如果方法列表较大，可能使用树结构来提高查找性能（特别是方法名排序后）。\n\n这种优化使得对于频繁调用的方法，能够以更高的效率进行查找。\n优化的好处：\n\n方法查找速度更快。\n降低了内存占用，尤其在方法很多的类中表现尤为突出。\n\n\nisa 指针优化（ISA指针打包）\n\n早期 isa 指针：\n早期的 isa 指针实际上是一个单纯的指针，它指向当前对象所属的类。当我们需要判断一个对象的类型时，必须通过这个指针进行查找。这个过程虽然有效，但随着内存和处理器架构的变化，其效率并没有得到最优的利用。\n现代优化：\niOS 14 及之后的版本引入了 ISA 指针打包（ISA pointer packing） 的概念，使得 isa 指针变得更加高效。具体来说：\n\n压缩指针：isa 不仅仅是一个指针，它包含了更多的信息，包括：\n引用计数：可以通过 isa 字段直接获取对象的引用计数（而不需要额外的字段）。\nC++ 析构函数支持：对于 C++ 对象，isa 可以包含一个标记，表明该对象是否有 C++ 析构函数需要调用。\n指针压缩：针对 64 位设备，指针已经被压缩，节省了内存空间。\n指针布局：通过优化指针的布局，可以减少内存访问的延迟。例如，将常用的标记和信息放在 isa 中，减少了缓存缺失的概率。\n\n结构变化：\nstruct objc_object &#123;    Class isa;   // 压缩后的 isa 指针，包含更多信息&#125;;\n\n这种优化使得：\t•\t内存使用：减少了内存占用。\t•\t效率提升：访问对象所属类时的效率大幅提高。\n\n总结\n在现代 Objective-C Runtime 中，结构体的优化和指针的打包大大提升了系统的性能，尤其是在内存占用和方法查找速度上。重点优化如下：\t•\tobjc_class 和 objc_data_bits_t 的分离：提高了内存布局的紧凑性和效率。\t•\tmethodList 的优化：结合哈希表和二叉搜索树，提高了方法查找的效率。\t•\tisa 指针优化：通过指针打包，减少了内存占用，并加速了对象的类型查找和引用计数管理。\n这些改进的核心目的是：提升性能、减少内存占用，特别是在 iOS 设备上，确保运行时系统能够在有限的硬件资源上高效运行。\n\n","categories":["基础"]},{"title":"Day4-Block 内存管理 & 循环引用分析","url":"/2025/04/27/Day4-Block-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90/","content":"Block 内存管理 &amp; 循环引用分析1. Block 的结构体本质Block 在底层其实是一个结构体：\nstruct Block_literal &#123;    void *isa;                      // 指向 Block 类对象    int flags;                      // 标志位（是否有 copy/dispose 等）    int reserved;                   // 保留字段    void (*invoke)(void *, ...);     // 函数指针，Block 实际执行逻辑    struct Block_descriptor *descriptor;  // Block 描述信息    // captured variables...&#125;;\n\n2. 捕获外部变量时，发生了什么？\n\n\n变量类型\n捕获方式\n内存管理行为\n\n\n\n基本数据类型（int&#x2F;float）\n值拷贝\n不影响内存管理\n\n\nObjective-C 对象\n强引用（retain）\n需要注意循环引用\n\n\n__block 修饰的对象\n指针拷贝，但本身仍可能强引用\n需配合 __weak __block\n\n\n3. Block 的 copy 和 dispose 函数Block 如果捕获了对象，底层会自动生成 copy 和 dispose 函数：\n\ncopy ： retain 捕获的对象\ndispose ： release 捕获的对象\n\n简化示例：\nvoid _Block_copy(void *dst, void *src) &#123;    objc_retain(capturedObj);&#125;void _Block_dispose(void *src) &#123;    objc_release(capturedObj);&#125;\n\n4. 深层次的循环引用分析常见导致 Block 循环引用的场景：\n\nNSTimer &#x2F; CADisplayLink &#x2F; GCD\n异步任务 (dispatch_async)\n链式调用\n\n标准防循环写法：\n__weak typeof(self) weakSelf = self;self.myBlock = ^&#123;    __strong typeof(weakSelf) strongSelf = weakSelf;    if (!strongSelf) return;    [strongSelf doSomething];&#125;;\n\n\n\nBlock 高频面试问答1. Block 的类型有哪些？分别什么时候出现？答：\n\nGlobal Block：不捕获外部变量，存储在全局区。\nStack Block：捕获了外部变量，存储在栈上。\nMalloc Block：拷贝自 Stack Block，存储在堆上。\n\nARC 下只存在 Global Block 和 Malloc Block。\n\n2. Block 在 ARC 下是如何内存管理的？答：\n\nARC 会自动对 Block 执行 copy 操作，将其从栈拷贝到堆上。\n使用 __strong 指针持有 Block 时，默认是堆 Block。\n\n\n3. 如何判断一个 Block 是否造成了循环引用？答：\n\n检查 Block 内是否使用了 self。\n检查 self 是否强引用了 Block（比如 Block 是 self 的属性）。\n使用 Instruments 的 Leaks 工具分析内存泄漏。\n\n\n4. __block 修饰符在 ARC 和 MRC 下分别是什么行为？答：\n\nMRC：__block 允许修改变量，但不会自动管理引用计数。\nARC：__block 允许修改，但并不会弱化引用关系，需要自己处理弱引用。\n\n\n5. Block 为什么容易引起内存泄漏？具体有哪些场景？答：因为 Block 捕获变量是强引用，特别是对象指针，如下场景常出问题：\n\nUIViewController 的 Block 属性内部引用了 self\nNSTimer、CADisplayLink、GCD 中的 Block\n\n解决办法：\n\n使用 __weak\n定时器使用 weakProxy\nGCD 注意生命周期控制\n\n\n小结理解 Block 的内存特性、引用关系变化（stack → heap）、以及在 ARC 下的默认 copy 机制，是彻底掌握 iOS 内存管理的关键。\n","categories":["基础"]},{"title":"Day5-两数之和 II - 输入有序数组","url":"/2025/04/28/Day5-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"🔗 LeetCode 167 - Two Sum II - Input Array Is Sorted\n📌 题目描述给定一个已按升序排列的整数数组 numbers 和一个目标值 target，请你在数组中找出两个数，使得它们的和为目标值 target，并返回这两个数的下标。\n注意：  \n\n返回的答案是一个 1 索引的数组。\n假设每个输入只对应一个答案，且你不可以重复使用数组中的元素。\n\n\n💡 解题思路\n由于数组已排序，可以使用双指针法：\n\n初始化两个指针，一个指向数组的开头，一个指向数组的末尾。\n如果两指针指向的元素之和等于目标值，返回这两个指针的下标；\n如果和小于目标值，说明需要增大和，左指针右移；\n如果和大于目标值，说明需要减小和，右指针左移。\n\n\n这种方法时间复杂度是 O(n)，效率较高。\n\n\n\n✅ JavaScript 实现var twoSum = function (numbers, target) &#123;    let left = 0;    let right = numbers.length - 1;        while (left &lt; right) &#123;        const sum = numbers[left] + numbers[right];        if (sum === target) &#123;            return [left + 1, right + 1];  // 注意返回的下标是从 1 开始的        &#125; else if (sum &lt; target) &#123;            left++;        &#125; else &#123;            right--;        &#125;    &#125;&#125;;\n\n\n🧠 思考拓展\n如果数组不是有序的，如何解决这个问题？\n本题和 LeetCode 1. Two Sum 的区别是什么？它是如何利用排序优化解法的？\n\n\n","categories":["算法"]},{"title":"Day6-Runtime 实战技巧","url":"/2025/04/29/Day6-Runtime-%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/","content":"一、定义Runtime 是什么？\n\nObjective-C 的 Runtime 实际上是 C 语言的一套函数和类库，用于支持 Objective-C 编程语言的动态性，包括类的创建、方法调用、属性访问等。\n\n\n二、Runtime 实战技巧1.Method Swizzling（方法交换）1. 什么是 Method Swizzling？\n定义：在程序运行时，交换两个方法实现的过程。\n本质：修改方法对应的 IMP（指向函数实现的指针）。\n常用场景：\n给系统方法加功能\n替换系统方法行为\nAOP\n\n\n\n2. 如何实现 Swizzling？常用 API：\nMethod class_getInstanceMethod(Class cls, SEL name);void method_exchangeImplementations(Method m1, Method m2);\n\n代码示例：\n@implementation UIViewController (Swizzling)+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Method originalMethod = class_getInstanceMethod(self, @selector(viewWillAppear:));        Method swizzledMethod = class_getInstanceMethod(self, @selector(my_viewWillAppear:));        method_exchangeImplementations(originalMethod, swizzledMethod);    &#125;);&#125;- (void)my_viewWillAppear:(BOOL)animated &#123;    NSLog(@&quot;页面将要出现：%@&quot;, self);    [self my_viewWillAppear:animated];&#125;@end\n\n3. 注意事项\n+load 和 dispatch_once 保证只执行一次。\n确保方法存在，避免引起程序崩溃。\n注意继承关系和子类覆盖问题。\n\n\n2.消息转发机制1. 什么是消息转发？\n当对象收到无法响应的消息，有三次机会处理：\n动态方法解析（resolveInstanceMethod:）\n备用接收者（forwardingTargetForSelector:）\n完整消息转发（forwardInvocation:）\n\n\n\n2. 详细流程（１）动态方法解析+ (BOOL)resolveInstanceMethod:(SEL)sel\n示例：\n+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;    if (sel == @selector(run)) &#123;        class_addMethod(self, sel, (IMP)runFunction, &quot;v@:&quot;);        return YES;    &#125;    return [super resolveInstanceMethod:sel];&#125;\n\n（２）快速转发- (id)forwardingTargetForSelector:(SEL)aSelector\n示例：\n- (id)forwardingTargetForSelector:(SEL)aSelector &#123;    if (aSelector == @selector(run)) &#123;        return self.delegate;    &#125;    return [super forwardingTargetForSelector:aSelector];&#125;\n\n（３）完整消息转发- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector- (void)forwardInvocation:(NSInvocation *)anInvocation\n示例：\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;    if (aSelector == @selector(run)) &#123;        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];    &#125;    return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;    SEL sel = [anInvocation selector];    if ([self.delegate respondsToSelector:sel]) &#123;        [anInvocation invokeWithTarget:self.delegate];    &#125; else &#123;        [super forwardInvocation:anInvocation];    &#125;&#125;\n\n3. 关联对象 (Associated Objects)定义：在不改动原类的基础上，给分类、扩展类增加实体属性。\n常用 API：\n\nobjc_setAssociatedObject\nobjc_getAssociatedObject\n\n应用场景：\n\nUIButton 增加防重复点击时间间隔\n\n4. 动态生成类和方法常用 API：\n\nobjc_allocateClassPair\nclass_addMethod\n\n应用场景：\n\nKVO 内部原理（创建子类）\nORM框架自动生成对应属性\n\n5. 完全自动 NSCoding 完成思路：通过 Runtime 遍历 ivar，自动 encode&#x2F;decode，无需手写代码。\n应用场景：\n\nModel 持久化\n简化用户数据处理\n\n6. 实现安全防护（防 Crash）思路：更换 NSArray, NSDictionary, NSString 等类的方法，防止路径错误、索引越界等 crash。\n应用场景：\n\n安全性框架 SafeKit\n项目安全级别提升\n\n7. 数据模型实体化（完全自动化等）思路：通过 property 列表，根据 key-value 将 JSON 转为 Model，或反转。\n应用场景：\n\nYYModel\nMJExtension\n\n8. 方法替换 IMP应用：\n\nhook 系统方法，并加自己逻辑\n控制方法执行流程\n\n示例：\n\n在 App 进入前后台时，统一管理封装\n\n9. 高级消息转发 (NSProxy)应用：\n\n弱代理（避免循环引用、Timer 泄漏）\n多代理同步分发\n性能强化\n\n\n三、实战案例案例1：防止 UIButton 重复点击背景\n\nUIButton 连续点击容易造成接口重复请求。\n想给所有 UIButton 加防抖，不改动现有业务代码。\n\n\n思路\n用 Method Swizzling，替换 sendAction:to:forEvent: 方法，在里面加节流逻辑。\n\n代码示例\nUIButton+AntiRepeat.h\n#import &lt;UIKit/UIKit.h&gt;@interface UIButton (AntiRepeat)@property (nonatomic, assign) NSTimeInterval eventInterval; // 点击间隔@property (nonatomic, assign) NSTimeInterval lastEventTime; // 上次点击时间@end\nUIButton+AntiRepeat.m\n#import &quot;UIButton+AntiRepeat.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIButton (AntiRepeat)+ (void)load &#123;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^&#123;        Method original = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));        Method swizzled = class_getInstanceMethod(self, @selector(my_sendAction:to:forEvent:));        method_exchangeImplementations(original, swizzled);    &#125;);&#125;// 关联对象 eventInterval- (NSTimeInterval)eventInterval &#123;    return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setEventInterval:(NSTimeInterval)eventInterval &#123;    objc_setAssociatedObject(self, @selector(eventInterval), @(eventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;// 关联对象 lastEventTime- (NSTimeInterval)lastEventTime &#123;    return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setLastEventTime:(NSTimeInterval)lastEventTime &#123;    objc_setAssociatedObject(self, @selector(lastEventTime), @(lastEventTime), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;// 新的方法- (void)my_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;    if (NSDate.date.timeIntervalSince1970 - self.lastEventTime &lt; self.eventInterval) &#123;        return; // 点击间隔太短，忽略    &#125;    self.lastEventTime = NSDate.date.timeIntervalSince1970;    [self my_sendAction:action to:target forEvent:event];&#125;@end\n\n\n\n使用\nUIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem];btn.eventInterval = 1.0; // 设置 1 秒内不能重复点击\n\n讲解要点\n\nsendAction:to:forEvent: 是 UIButton 处理点击事件的入口。\n通过 Swizzling，在不改业务代码的情况下统一加了防抖。\n使用 objc_setAssociatedObject 给分类动态添加属性，记录最后一次点击时间。\n\n案例2：用 NSProxy 实现弱代理（防止 Timer 循环引用）\nNSProxy 作为中介\n弱持 target\n\n背景\n\nNSTimer 默认强引用 target，容易造成内存泄漏（循环引用）。\n\n\n思路\n使用 NSProxy 中转，让 Timer 弱引用真正的 target。\n\n代码示例\nTimerWeakProxy.h\n#import &lt;Foundation/Foundation.h&gt;@interface TimerWeakProxy : NSProxy+ (instancetype)proxyWithTarget:(id)target;@end\nTimerWeakProxy.m\n#import &quot;TimerWeakProxy.h&quot;@interface TimerWeakProxy ()@property (nonatomic, weak) id target;@end@implementation TimerWeakProxy+ (instancetype)proxyWithTarget:(id)target &#123;    TimerWeakProxy *proxy = [TimerWeakProxy alloc];    proxy.target = target;    return proxy;&#125;- (id)forwardingTargetForSelector:(SEL)selector &#123;    return self.target;&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123;    [invocation invokeWithTarget:self.target];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;    return [self.target methodSignatureForSelector:sel];&#125;@end\n\n\n使用\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0                                              target:[TimerWeakProxy proxyWithTarget:self]                                            selector:@selector(timerAction)                                            userInfo:nil                                             repeats:YES];\n\n\n讲解要点\n\nTimerWeakProxy 持有 target 的弱引用，防止循环引用。\nforwardingTargetForSelector: 提供快速消息转发，提高性能。\n\n案例3：自动 JSON -&gt; Model 映射\n利用 property 列表遍历\n高效方便，性能好\n\n案例4：安全防护套件\nNSArray、NSDictionary 进行方法替换，防止错误操作\n\n\n四、完整思维图\n\n\n技术\n作用\n具体场景\n\n\n\nMethod Swizzling\n修改系统方法\nAOP 打点\n\n\n消息转发\n动态处理未知方法\n弱代理\n\n\nAssociated Object\n扩展分类属性\nUIButton 防重点\n\n\n自动 NSCoding\n自动化存储连贯\nModel 持久化\n\n\nNSProxy\n高级转发\nTimer 弱代理\n\n\n\n五、常考问题\n说说你对 Runtime 的理解？\n\n\nRuntime 是 OC 的运行时系统，允许程序在运行时进行对象操作（如消息发送、方法交换、类创建等）。\n动态性是 Objective-C 最重要的特性之一，基于 Runtime 实现。\n\n\n\n什么是 Method Swizzling？使用时注意什么？\n\n\n定义：交换两个方法的实现。\n注意：\n使用 dispatch_once 保证只交换一次。\n确认方法存在再交换，避免崩溃。\n维护好调用链，防止死循环。\n避免过度使用，破坏封装性。\n\n\n\nMethod Swizzling 常用在哪些场景？\n\n\n统一加日志打点（比如 UIViewController 生命周期）\n替换系统方法功能（如统计点击事件）\nAOP 编程实践\n框架内部增强（如 AFNetworking 的某些 hook）\n\n\n\n消息发送流程是怎样的？\n\n\n调用方法 -&gt; 转成 objc_msgSend 发送消息。\n如果找不到方法：\n动态方法解析（resolveInstanceMethod:）\n快速转发（forwardingTargetForSelector:）\n完整消息转发（forwardInvocation:）\n最后抛出 unrecognized selector sent to instance 异常。\n\n\n\n\n\n消息转发和代理模式有什么关系？\n\n\n代理（delegate）本质就是消息转发的一种应用。\n可以通过 forwardingTargetForSelector: 把不支持的方法交给代理对象执行。\n复杂代理模式（如 NSProxy 多代理）就是用完整消息转发实现的。\n\n\n\nSwizzling 和 Hook 的区别？\n\n\nSwizzling：指“方法交换”，主要改变对象的方法实现。\nHook：更广义，指拦截并修改程序执行过程，可以是方法层面、函数层面（Fishhook）、甚至是汇编指令层面。\n\n\n\n为什么 +load 方法适合做 Swizzling？\n\n\n+load 是在类（或分类）被加载到内存时立即调用的，优先于 main()。\n保证在对象使用前就完成方法交换。\n\n补充：如果想更灵活控制，某些框架（如 Aspects）会在 +initialize 做 Swizzling，但要注意 initialize 只会在第一次发送消息前调用。\n\n\n使用 Runtime 有哪些风险？\n\n\n方法交换过多，容易导致难以维护和调试。\n消息转发链过长，可能导致性能下降。\n动态添加方法时参数类型签名不正确，可能导致运行时崩溃。\n无法被编译器静态检查，出错时很难定位。\n\n\n\nNSProxy 是什么？为什么需要它？\n\n\nNSProxy 是一个轻量级的基类，专门用于实现消息转发。\n典型场景：\n远程方法调用（RPC）\n多代理管理（如 YYTextKeyboardManager）\n相比 NSObject，NSProxy 没有实例变量，直接走完整消息转发流程。\n\n\n","categories":["基础"]},{"title":"Day6-删除有序数组中的重复项","url":"/2025/04/29/Day6-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","content":"🔗 LeetCode 26 - Remove Duplicates from Sorted Array\n📌 题目描述给你一个 升序排列 的数组 nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 O(1) 额外空间的条件下原地修改输入数组。\n示例：\n输入: nums = [1,1,2]输出: 2, nums = [1,2,_]\n\n\n💡 解题思路\n使用 双指针：\n\nslow 指针表示当前处理的唯一元素下标；\nfast 指针遍历数组，当遇到一个与 nums[slow] 不同的元素时，将其赋值给 nums[slow + 1]，然后 slow 前进一步。\n\n\n遍历结束后，slow + 1 就是新数组的长度。\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n\n✅ JavaScript 实现var removeDuplicates = function(nums) &#123;    if (nums.length === 0) return 0;        let slow = 0;        for (let fast = 1; fast &lt; nums.length; fast++) &#123;        if (nums[fast] !== nums[slow]) &#123;            slow++;            nums[slow] = nums[fast];        &#125;    &#125;        return slow + 1;&#125;;\n\n\n🧠 思考拓展\n如果要求每个元素最多出现两次怎么办？（参考 LeetCode 80）\n这道题为什么必须是原地修改？有什么实际应用场景？\n\n\n","categories":["算法"]},{"title":"Hello World","url":"/2025/04/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"学习计划","url":"/2025/04/23/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","content":"每日节奏建议：\n📖 技术知识学习：1.5h\n🧱 项目回顾 &amp; 系统设计：1h\n🧠 算法训练：1h\n🎤 面试题演练：1h\n📓 总结记录：0.5h\n\n\n🗓️ 第 1 周：UIKit、Block、Runtime\n\n\n星期\n学习内容\n\n\n\n周一\nUIKit 事件传递机制 &amp; Responder Chain\n\n\n周二\nView 布局流程（layoutSubviews 等）\n\n\n周三\nBlock 分类、变量捕获与作用域\n\n\n周四\nBlock 内存管理 &amp; 循环引用分析\n\n\n周五\nObjective-C Runtime 基础结构\n\n\n周六\nRuntime 实战技巧（Swizzling、消息转发）\n\n\n周日\n复盘总结 + 输出笔记（Runtime&#x2F;Block&#x2F;UI）\n\n\n\n🗓️ 第 2 周：RunLoop、线程、内存管理\n\n\n星期\n学习内容\n\n\n\n周一\nRunLoop 构成与线程保活\n\n\n周二\nRunLoop 卡顿优化场景实战\n\n\n周三\nGCD 进阶：barrier&#x2F;group&#x2F;target queue\n\n\n周四\nGCD vs NSOperation 框架对比\n\n\n周五\nARC 本质、Weak 实现、循环引用处理\n\n\n周六\n内存泄漏排查、僵尸对象与 MRC 回顾\n\n\n周日\n总结脑图：RunLoop + 多线程 + 内存管理\n\n\n\n🗓️ 第 3 周：项目复盘 + 网络 &amp; 缓存\n\n\n星期\n学习内容\n\n\n\n周一\n主项目架构梳理 + 架构图初稿\n\n\n周二\nNSURLSession 断点续传 + 网络封装\n\n\n周三\n网络库底层：AFNetworking、Alamofire\n\n\n周四\n缓存策略 + URLProtocol 拦截\n\n\n周五\n数据持久化方案（CoreData&#x2F;SQLite）\n\n\n周六\n离线缓存架构图 + 实际场景总结\n\n\n周日\n输出：项目亮点 bullet list（10 条）\n\n\n\n🗓️ 第 4 周：架构模式 &amp; 动态化技术\n\n\n星期\n学习内容\n\n\n\n周一\nMVC&#x2F;MVVM&#x2F;VIPER&#x2F;Redux 模式总结\n\n\n周二\n模块化设计 + 路由机制实践\n\n\n周三\n跨组件通信方案（Router &#x2F; URLScheme）\n\n\n周四\n热更新方案（JSPatch &#x2F; Flutter &#x2F; RN）\n\n\n周五\n字节跳动高频架构类面试题整理\n\n\n周六\n项目架构演讲模拟\n\n\n周日\n架构图最终版 + 项目复盘文档整理\n\n\n\n🗓️ 第 5 周：系统设计 &amp; 算法进阶\n\n\n星期\n学习内容\n\n\n\n周一\n系统设计题：视频播放 App 设计\n\n\n周二\n视频缓存、异常处理模块\n\n\n周三\n图片加载优化（LRU&#x2F;异步解码）\n\n\n周四\n多线程数据一致性场景题\n\n\n周五\n启动优化 &amp; 白屏优化场景\n\n\n周六\n算法专题：滑动窗口 + 搜索类\n\n\n周日\n输出系统设计答题稿（附图+要点）\n\n\n\n🗓️ 第 6 周：真题精练 + 模拟面试\n\n\n星期\n学习内容\n\n\n\n周一\n字节跳动 iOS 面经模拟一轮\n\n\n周二\n算法 + 项目 + 系统设计自测\n\n\n周三\n面经高频题口头回答训练\n\n\n周四\n系统设计 + 框架类问题演练\n\n\n周五\n算法面试题：手写经典题\n\n\n周六\n模拟面试（可找朋友&#x2F;AI 演练）\n\n\n周日\n总结错题、面试表现复盘笔记\n\n\n\n🗓️ 第 7 周：简历打磨 + 高频回顾\n\n\n星期\n学习内容\n\n\n\n周一\n简历优化 + STAR 法项目精炼\n\n\n周二\n高频 iOS 面试题 Top20 梳理\n\n\n周三\n项目深挖回答演练\n\n\n周四\n算法每日三题（链表&#x2F;DP&#x2F;字符串）\n\n\n周五\n突破知识短板模块\n\n\n周六\n录制项目讲解 or 技术讲演视频\n\n\n周日\n总结答题话术文档 &amp; PPT 资料\n\n\n\n🗓️ 第 8 周：冲刺 &amp; 模拟演练\n\n\n星期\n学习内容\n\n\n\n周一\n快速过一遍面试 50 问\n\n\n周二\n模拟完整项目答辩演讲\n\n\n周三\n高频算法刷题（6 题冲刺）\n\n\n周四\n模拟完整面试（全流程）\n\n\n周五\n总结所有笔记 + 精选答题卡\n\n\n周六\n心态调整 &amp; 准备环境\n\n\n周日\n正式面试 day 🚀（或休息备战）\n\n\n\n"}]